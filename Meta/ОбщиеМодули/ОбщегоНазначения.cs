using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace V82.ОбщиеМодули
{
	public partial class ОбщегоНазначения
	{
		////////////////////////////////////////////////////////////////////////////////
		// Общие процедуры и функции для работы с прикладными типами и коллекциями значений
		// Объединяет две таблицы значений по условию "И".
		// Возвращает таблицу значений, полученную в результате объединения двух таблиц по условию "И".
		//
		// Параметры:
		//  Таблица1         - ТаблицаЗначений - первая таблица значений для объединения
		//  Таблица2         - ТаблицаЗначений - вторая таблица значений для объединения
		//  ПоляТаблицы      - Строка - поля таблицы, перечисленные через запятую, по которым будут выполнятся объединение
		//  ИмяПоляИтератора - Строка - имя служебной колонки таблицы значений.
		//                              Это имя должно быть уникально во множестве имен колонок первой и второй таблиц.
		//                              Переменная ПоляТаблицы не должна содержать этого имени.
		//                              Значение по умолчанию "ИтераторПоляТаблицы"
		//
		// Возвращаемое значение:
		//  ТаблицаЗначений -  таблица значений, полученная в результате объединения двух таблиц по условию "И"
		//

		public object ОбъединитьТаблицыПоУсловиюИ(/*Таблица1, Таблица2, Знач ПоляТаблицы, ИмяПоляИтератора = "ИтераторПоляТаблицы"*/)
		{
			/*Таблица1.Свернуть(ПоляТаблицы);*/
			/*Таблица2.Свернуть(ПоляТаблицы);*/
			/*ДобавитьИтераторТаблице(Таблица1, +1, ИмяПоляИтератора);*/
			/*ДобавитьИтераторТаблице(Таблица2, -1, ИмяПоляИтератора);*/
			/*ТаблицаРезультат = Таблица1.Скопировать();*/
			/*ОбщегоНазначенияКлиентСервер.ДополнитьТаблицу(Таблица2, ТаблицаРезультат);*/
			/*ТаблицаРезультат.Свернуть(ПоляТаблицы, ИмяПоляИтератора);*/
			/*ТаблицаРезультат = ТаблицаРезультат.Скопировать(Новый Структура(ИмяПоляИтератора, 0));*/
			/*ТаблицаРезультат.Колонки.Удалить(ИмяПоляИтератора);*/
			return null;
		}
		// Добавляет колонку в таблицу значений. Заполняет колонку переданным значением
		//
		// Параметры:
		//  Таблица           - ТаблицаЗначений - таблица значений для добавления колонки
		//  ЗначениеИтератора - Произвольный - значение, которым будет заполнено новое поле таблицы
		//  ИмяПоляИтератора  - Строка - имя добавляемого поля
		//

		public void ДобавитьИтераторТаблице(/*Таблица, ЗначениеИтератора, ИмяПоляИтератора*/)
		{
			/*Таблица.Колонки.Добавить(ИмяПоляИтератора);*/
			/*Таблица.ЗаполнитьЗначения(ЗначениеИтератора, ИмяПоляИтератора);*/
		}
		// Заполняет массив-приемник уникальными значениями из массива-источника.
		// Если элемент в массиве-приемнике уже существует, то добавления нового элемента не происходит.
		//
		// Параметры:
		//  МассивПриемник – Массив – массив, который заполняется уникальными значениями
		//  МассивИсточник – Массив – массив, из которого подбираются элементы в массив-приемник.
		//

		public void ЗаполнитьМассивУникальнымиЗначениями(/*МассивПриемник, МассивИсточник*/)
		{
		}
		// Процедура удаляет из массива МассивРеквизитов элементы, соответствующие именам
		// реквизитов объекта из массива МассивНепроверяемыхРеквизитов.
		// Для использования в обработчиках события ОбработкаПроверкиЗаполнения.
		//
		// Параметры:
		//	МассивРеквизитов              - Массив - массив строк с именами реквизитов объекта.
		//	МассивНепроверяемыхРеквизитов - Массив строк с именами реквизитов объекта, не требующих проверки.
		//

		public void УдалитьНепроверяемыеРеквизитыИзМассива(/*МассивРеквизитов, МассивНепроверяемыхРеквизитов*/)
		{
		}
		//	Преобразует таблицу значений в массив.
		//	Может использоваться для передачи на клиента данных, полученных
		//	на сервере в виде таблицы значений в том случае, если таблица
		//	значений содержит только такие значения, которые могут
		//  быть переданы на клиента
		//
		//	Полученный массив содержит структуры, каждая из которых повторяет
		//	структуру колонок таблицы значений.
		//
		//	Не рекомендуется использовать для преобразования таблиц значений
		//	с большим количеством строк.
		//
		//	Параметры: ТаблицаЗначений
		//	Возвращаемое значение: Массив
		//

		public object ТаблицаЗначенийВМассив(/*ТаблицаЗначений*/)
		{
			/*Массив = Новый Массив();*/
			/*СтруктураСтрокой = "";*/
			/*НужнаЗапятая = Ложь;*/
			return null;
		}
		// Функция СтрокаТаблицыЗначенийВСтруктуру создает
		// структуру со свойствами, как колонки таблицы
		// значений передаваемой строки
		// и устанавливает этим свойствам значения
		// из строки таблицы значений
		//
		// Параметры:
		//  СтрокаТаблицыЗначений - СтрокаТаблицыЗначений
		//
		// ВозвращаемоеЗначение:
		//  Структура
		//

		public object СтрокаТаблицыЗначенийВСтруктуру(/*СтрокаТаблицыЗначений*/)
		{
			/*Структура = Новый Структура;*/
			return null;
		}
		// Получает строку, содержащую ключи структуры, разделенные символом разделителя.
		//
		// Параметры:
		//	Структура - Структура - Структура, ключи которой преобразуются в строку
		//	Разделитель - Строка - Разделитель, который вставляется в строку между ключами структуры
		//
		// Возвращаемое значение:
		//	Строка - Строка, содержащая ключи структуры разделенные резделителем
		//

		public object КлючиСтруктурыВСтроку(/*Структура, Разделитель = ","*/)
		{
			/*Результат = "";*/
			return null;
		}
		// Преобразует текст формата XML в таблицу значений,
		// при этом колонки таблицы формируются на основе описания в XML.
		//
		// Параметры:
		//  ТекстXML     - текст в формате XML.
		//
		// Схема XML:
		//<?xml version="1.0" encoding="utf-8"?>
		//<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" xmlns:xs="http://www.w3.org/2001/XMLSchema">
		//  <xs:element name="Items">
		//	<xs:complexType>
		//	  <xs:sequence>
		//		<xs:element maxOccurs="unbounded" name="Item">
		//		  <xs:complexType>
		//			<xs:attribute name="Code" type="xs:integer" use="required" />
		//			<xs:attribute name="Name" type="xs:string" use="required" />
		//			<xs:attribute name="Socr" type="xs:string" use="required" />
		//			<xs:attribute name="Index" type="xs:string" use="required" />
		//		  </xs:complexType>
		//		</xs:element>
		//	  </xs:sequence>
		//	  <xs:attribute name="Description" type="xs:string" use="required" />
		//	  <xs:attribute name="Columns" type="xs:string" use="required" />
		//	</xs:complexType>
		//  </xs:element>
		//</xs:schema>
		//
		// Примеры XML-файлов см. в демонстрационной конфигурации.
		//
		// Пример использования:
		//   КлассификаторТаблица = ПрочитатьXMLВТаблицу(РегистрыСведений.АдресныйКлассификатор.
		//       ПолучитьМакет("КлассификаторАдресныхОбъектовРоссии").ПолучитьТекст());
		//
		// Возвращаемое значение:
		//  ТаблицаЗначений.
		//

		public object ПрочитатьXMLВТаблицу(/*ТекстXML*/)
		{
			/*Чтение = Новый ЧтениеXML;*/
			/*Чтение.УстановитьСтроку(ТекстXML);*/
			/*// Прочитаем первый узел и проверим его
*/
			if(true/*Не Чтение.Прочитать()*/)
			{
				/*ВызватьИсключение("Пустой XML");*/
			}
			/*// Получим описание таблицы и создадим ее
*/
			/*ИмяТаблицы = Чтение.ПолучитьАтрибут("Description");*/
			/*ИменаКолонок = СтрЗаменить(Чтение.ПолучитьАтрибут("Columns"), ",", Символы.ПС);*/
			/*Колонок = СтрЧислоСтрок(ИменаКолонок);*/
			/*ТаблицаЗначений = Новый ТаблицаЗначений;*/
			/*// Заполним значения в таблице
*/
			while(true/*Чтение.Прочитать()*/)
			{
				if(true/*Чтение.ТипУзла <> ТипУзлаXML.НачалоЭлемента*/)
				{
					/*Продолжить;*/
				}
				/*новСтр = ТаблицаЗначений.Добавить();*/
			}
			/*// Заполним результат
*/
			/*Результат = Новый Структура;*/
			/*Результат.Вставить("ИмяТаблицы", ИмяТаблицы);*/
			/*Результат.Вставить("Данные", ТаблицаЗначений);*/
			return null;
		}
		// ПрочитатьXMLВТаблицу()
		// Возвращает признак того, что реквизит входит в подмножество стандартных реквизитов
		//
		// Параметры:
		//  СтандартныеРеквизиты – ОписанияСтандартныхРеквизитов - тип и значение описывает коллекцию настроек различных стандартных реквизитов;
		//  ИмяРеквизита – Строка – реквизит который необходимо проверить на принадлежность множеству стандартных реквизитов;
		//
		//  Возвращаемое значение:
		// Тип: Булево. Истина -  реквизит входит в подмножество стандартных реквизитов; Ложь – нет.
		//

		public object ЭтоСтандартныйРеквизит(/*СтандартныеРеквизиты, ИмяРеквизита*/)
		{
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// Общие процедуры и функции для работы с данными в базе
		// Проверяет проведенность документов
		//
		// Параметры:
		//  Документы - Массив - документы, проведенность которых необходимо проверить
		//
		// Возвращаемое значение:
		//  Массив - непроведенные документы из массива Документы
		//

		public object ПроверитьПроведенностьДокументов(/*знач Документы*/)
		{
			/*Результат = Новый Массив;*/
			/*ШаблонЗапроса = 	
		"ВЫБРАТЬ
		|	Документ.Ссылка КАК Ссылка
		|ИЗ
		|	&ИмяДокумента КАК Документ
		|ГДЕ
		|	Документ.Ссылка В(&МассивДокументов)
		|	И (НЕ Документ.Проведен)";*/
			/*ТекстОбъединитьВсе =
		"
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|";*/
			/*ИменаДокументов = Новый Массив;*/
			/*ТекстЗапроса = "";*/
			/*Запрос = Новый Запрос;*/
			/*Запрос.Текст = ТекстЗапроса;*/
			/*Запрос.УстановитьПараметр("МассивДокументов", Документы);*/
			if(true/*Не ПустаяСтрока(ТекстЗапроса)*/)
			{
				/*Результат = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");*/
			}
			return null;
		}
		// Процедура выполняет проведение документов перед формированием печатной формы.
		//
		// Параметры:
		//	Документы                - Массив - документы, которые необходимо провести
		//  ТипПроведенныхДокументов - Тип    - возвращает тип документов в массиве
		//
		// Возвращаемое значение:
		//	Массив - документы, которые провести не удалось, и описания ошибок.
		//

		public object ПровестиДокументы(/*Документы, ТипПроведенныхДокументов*/)
		{
			/*ИмяДокумента = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(
		Документы[0].Метаданные().ПолноеИмя(), ".")[1];*/
			/*ТипПроведенныхДокументов = ТипЗнч(Документы[0]);*/
			/*НепроведенныеДокументы = Новый Массив;*/
			return null;
		}
		// Возвращает структуру, содержащую значения реквизитов прочитанные из информационной базы
		// по ссылке на объект.
		//
		//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
		//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
		//  то следует использовать предварительный переход в привилегированный режим.
		//
		// Параметры:
		//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
		//  ИменаРеквизитов - Строка или Структура - если Строка, то имена реквизитов,
		//               перечисленные через запятую, в формате требований к свойствам структуры.
		//               Например, "Код, Наименование, Родитель".
		//               Если Структура, то в качестве ключа передается псевдоним поля для
		//               возвращаемой структуры с результатом, а в качестве значения (опционально)
		//               - фактическое имя поля в таблице.
		//               Если значение не определено, то имя поля берется из ключа.
		//
		// Возвращаемое значение:
		//  Структура    - содержит список свойств, как список имен в строке
		//                 ИменаРеквизитов, со значениям реквизитов, прочитанных
		//                 из информационной базы.
		//

		public object ПолучитьЗначенияРеквизитов(/*Ссылка, ИменаРеквизитов*/)
		{
			if(true/*ТипЗнч(ИменаРеквизитов) = Тип("Структура")*/)
			{
				/*СтруктураРеквизитов = ИменаРеквизитов;*/
			}
			/*ТекстПолей = "";*/
			/*Запрос = Новый Запрос(
		"ВЫБРАТЬ
		|" + ТекстПолей + "
		|ИЗ
		|	" + Ссылка.Метаданные().ПолноеИмя() + " КАК ПсевдонимЗаданнойТаблицы
		|ГДЕ
		|	ПсевдонимЗаданнойТаблицы.Ссылка = &Ссылка
		|");*/
			/*Запрос.УстановитьПараметр("Ссылка", Ссылка);*/
			/*Выборка = Запрос.Выполнить().Выбрать();*/
			/*Выборка.Следующий();*/
			/*Результат = Новый Структура;*/
			/*ЗаполнитьЗначенияСвойств(Результат, Выборка);*/
			return null;
		}
		// Функция ПолучитьЗначениеРеквизита возвращает значение
		// реквизита, прочитанного из информационной базы по ссылке на объект.
		//
		//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
		//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
		//  то следует использовать предварительный переход в привилегированный режим.
		//
		// Параметры:
		//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
		//  ИмяРеквизита - Строка, например, "Код".
		//
		// Возвращаемое значение:
		//  Произвольный    - зависит от типа значения прочитанного реквизита.
		//

		public object ПолучитьЗначениеРеквизита(/*Ссылка, ИмяРеквизита*/)
		{
			/*Результат = ПолучитьЗначенияРеквизитов(Ссылка, ИмяРеквизита);*/
			return null;
		}
		// Выполняет сравнение версий двух однотипных объектов.
		//
		//  Параметры:
		// Данные1 (обязательный). Тип:
		//  СправочникОбъект,
		//  ДокументОбъект,
		//  ПланВидовХарактеристикОбъект,
		//  ПланВидовРасчетаОбъект,
		//  ПланСчетовОбъект,
		//  ПланОбменаОбъект,
		//  БизнесПроцессОбъект,
		//  ЗадачаОбъект.
		// Первая версия данных для сравнения.
		//
		// Данные2 (обязательный). Тип: см. тип параметра Данные1
		// Вторая версия данных для сравнения.
		//
		// СписокСвойств (необязательный). Тип: Строка.
		// Список свойств объекта и табличных частей, разделенных запятыми.
		// Если параметр задан, то сравнение версий данных будет выполняться согласно
		// заданным свойствам, при этом параметр ИсключаяСвойства будет проигнорирован.
		//
		// ИсключаяСвойства (необязательный). Тип: Строка.
		// Список свойств объекта и табличных частей, разделенных запятыми.
		// Если параметр задан, то сравнение версий данных будет выполняться
		// для всех свойств и табличных частей, исключая заданные свойства.
		//
		// Возвращаемое значение:
		// Тип: Булево.
		// Возвращает Истина, если версии данных различаются; Ложь, если версии совпадают.
		//

		public object ДанныеРазличаются(/*Данные1, Данные2, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено*/)
		{
			if(true/*ТипЗнч(Данные1) <> ТипЗнч(Данные2)*/)
			{
			}
			/*ОбъектМетаданных = Данные1.Метаданные();*/
			if(true/*ЭтоСправочник(ОбъектМетаданных)*/)
			{
				if(true/*Данные1.ЭтоГруппа*/)
				{
					/*Объект1 = Справочники[ОбъектМетаданных.Имя].СоздатьГруппу();*/
				}
				if(true/*Данные2.ЭтоГруппа*/)
				{
					/*Объект2 = Справочники[ОбъектМетаданных.Имя].СоздатьГруппу();*/
				}
			}
			/*ЗаполнитьЗначенияСвойств(Объект1, Данные1, СписокСвойств, ИсключаяСвойства);*/
			/*ЗаполнитьЗначенияСвойств(Объект2, Данные2, СписокСвойств, ИсключаяСвойства);*/
			/*ТабличныеЧасти = ТабличныеЧастиОбъекта(ОбъектМетаданных);*/
			if(true/*СписокСвойств <> Неопределено*/)
			{
			}
			return null;
		}

		public object ДанныеИнформационнойБазыСтрокой(/*Данные*/)
		{
			/*ЗаписьXML = Новый ЗаписьXML;*/
			/*ЗаписьXML.УстановитьСтроку();*/
			/*ЗаписатьXML(ЗаписьXML, Данные, НазначениеТипаXML.Явное);*/
			return null;
		}

		public object ТабличныеЧастиОбъекта(/*ОбъектМетаданных*/)
		{
			/*Результат = Новый Массив;*/
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// Процедуры и функции для работы с внешним соединением
		// Возвращает имя COM-класса для работы с 1С:Предприятием 8 через COM-соединение.
		//

		public object ИмяCOMСоединителя(/**/)
		{
			/*СистемнаяИнфо = Новый СистемнаяИнформация;*/
			/*ПодстрокиВерсии = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(
		СистемнаяИнфо.ВерсияПриложения, ".");*/
			return null;
		}
		// Устанавливает внешнее соединение с информационной базой по переданным параметрам подключения и возвращает указатель на это соединение
		//
		// Параметры:
		//  Параметры - Структура - содержит параметры для установки внешнего соединения с информационной базой.
		//  Структура должна содержать следующие ключи (см. функция ОбщегоНазначенияКлиентСервер.СтруктураПараметровДляУстановкиВнешнегоСоединения):
		//
		//	  ВариантРаботыИнформационнойБазы             - (Число)  Вариант работы информационной базы: 0 – файловый; 1 – клиент-серверный
		//	  КаталогИнформационнойБазы                   - (Строка) Каталог информационной базы для файлового режима работы
		//	  ИмяСервера1СПредприятия                     - (Строка) Имя сервера1С:Предприятия
		//	  ИмяИнформационнойБазыНаСервере1СПредприятия - (Строка) Имя информационной базы на сервере1С:Предприятия
		//	  АутентификацияОперационнойСистемы           - (Булево) Признак аутентификации операционной системы при создании внешнего подключения к информационной базе
		//	  ИмяПользователя                             - (Строка) Имя пользователя информационной базы
		//	  ПарольПользователя                          - (Строка) Пароль пользователя информационной базы
		//
		//  СтрокаСообщенияОбОшибке (необязательный) – Строка – если в процессе установки внешнего соединения возникает ошибка,
		//                                                     то подробное описание ошибки помещается в этот параметр
		//
		// Возвращаемое значение:
		//  Тип: COM-объект, Неопределенно.
		//  в случае успешной установки внешнего соединения возвращается указатель на COM-объект соединения;
		//  в случае ошибки возвращается Неопределенно.
		//

		public object УстановитьВнешнееСоединение(/*Параметры, СтрокаСообщенияОбОшибке = "", ОшибкаПодключенияКомпоненты = Ложь*/)
		{
			/*// возвращаемое значение функции (COM-объект)
*/
			/*Connection = Неопределено;*/
			/*Попытка
		COMConnector = Новый COMObject(ИмяCOMСоединителя());*/
			/*// "V82.COMConnector"
*/
			/*Исключение
		СтрокаСообщенияОбОшибке = НСтр("ru = 'При установке внешнего соединения произошла ошибка: %1'");*/
			/*СтрокаСообщенияОбОшибке = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));*/
			/*ОшибкаПодключенияКомпоненты = Истина;*/
			/*КонецПопытки;*/
			if(true/*Параметры.ВариантРаботыИнформационнойБазы = 0*/)
			{
				if(true/*ПустаяСтрока(Параметры.КаталогИнформационнойБазы)*/)
				{
					/*СтрокаСообщенияОбОшибке = НСтр("ru = 'Не задано месторасположение каталога информационной базы.'");*/
				}
				if(true/*Параметры.АутентификацияОперационнойСистемы*/)
				{
					/*СтрокаСоединения = "File = ""&КаталогИнформационнойБазы""";*/
					/*СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&КаталогИнформационнойБазы", Параметры.КаталогИнформационнойБазы);*/
				}
			}
			/*Попытка
		Connection = COMConnector.Connect(СтрокаСоединения);*/
			/*Исключение
		
		ПодробноеПредставлениеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());*/
			/*СтрокаСообщенияОбОшибке = НСтр("ru = 'При установке внешнего соединения произошла ошибка: %1'");*/
			/*СтрокаСообщенияОбОшибке = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, ПодробноеПредставлениеОшибки);*/
			/*КонецПопытки;*/
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// Функции для работы с журналом регистрации
		// Процедура пакетной записи сообщений в журнал регистрации
		//
		// Параметры: СобытияДляЖурналаРегистрации - массив структур, клиентская глобальная переменная
		// Каждая структура - сообщение для журнала регистрации.
		// После записи переменная очищается.

		public void ЗаписатьСобытияВЖурналРегистрации(/*СобытияДляЖурналаРегистрации*/)
		{
			if(true/*ТипЗнч(СобытияДляЖурналаРегистрации) <> Тип("СписокЗначений")*/)
			{
			}
			if(true/*СобытияДляЖурналаРегистрации.Количество() = 0*/)
			{
			}
			/*СобытияДляЖурналаРегистрации.Очистить();*/
		}
		// Процедура ведения в журнале регистрации событий
		//
		// Параметры: СписокУровней - список значений,
		// Наименования уровней регистрации событий, которые необходимо включить

		public void ВключитьИспользованиеЖурналаРегистрации(/*СписокУровней = Неопределено*/)
		{
			/*УстановитьПривилегированныйРежим(Истина);*/
			/*Попытка
		УстановитьМонопольныйРежим(Истина);*/
			/*МассивУровней = Новый Массив();*/
			if(true/*СписокУровней = Неопределено*/)
			{
				/*МассивУровней.Добавить(УровеньЖурналаРегистрации.Информация);*/
				/*МассивУровней.Добавить(УровеньЖурналаРегистрации.Ошибка);*/
				/*МассивУровней.Добавить(УровеньЖурналаРегистрации.Предупреждение);*/
				/*МассивУровней.Добавить(УровеньЖурналаРегистрации.Примечание);*/
			}
			/*УстановитьИспользованиеЖурналаРегистрации(МассивУровней);*/
			/*УстановитьМонопольныйРежим(Ложь);*/
			/*Исключение
		УстановитьПривилегированныйРежим(Ложь);*/
			/*ВызватьИсключение
	КонецПопытки;*/
			/*УстановитьПривилегированныйРежим(Ложь);*/
		}
		// Проверяет, включена ли регистрация событий в журнале регистрации
		//
		// Параметры:
		// СписокПроверок - СписокЗначений, список строк-представлений режимов использования журнала регистрации, которые надо проверить на включение.
		//					Если Неопределено - тогда проверяются все режимы.
		//
		// Возвращаемое значение: Истина, когда заданные режимы включены. Иначе - ложь.

		public object ПроверитьВключениеЖурналаРегистрации(/*СписокПроверок = Неопределено*/)
		{
			/*МассивРежимов = ПолучитьИспользованиеЖурналаРегистрации();*/
			if(true/*СписокПроверок = Неопределено*/)
			{
			}
			return null;
		}

		public object УровеньСобытияПоПредставлению(/*ПредставлениеУровня*/)
		{
			if(true/*ПредставлениеУровня = "Информация"*/)
			{
			}
			return null;
		}

		public object УровниСобытияЖурналаРегистрацииПоСтроке(/*СписокУровней*/)
		{
			/*МассивНазванийУровней = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СписокУровней);*/
			/*МассивУровней = Новый Массив;*/
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// Процедуры и функции для работы с типами, объектами метаданных и их строковыми представлениями.
		// Получает дерево метаданных конфигурации с заданным отбором по объектам метаданных.
		//
		// Параметры:
		// Отбор – Структура – содержит значения элементов отбора.
		//						Если параметр задан, то будет получено дерево метаданных в соответствии с заданным отбором.
		//						Ключ (Строка) – имя свойства элемента метаданных;
		//						Значение (Массив) – множество значений для отбора.
		//
		// Пример инициализации переменной "Отбор":
		//
		// Массив = Новый Массив;
		// Массив.Добавить("Константа.ИспользоватьОбменДанными");
		// Массив.Добавить("Справочник.Валюты");
		// Массив.Добавить("Справочник.Организации");
		// Отбор = Новый Структура;
		// Отбор.Вставить("ПолноеИмя", Массив);
		//
		//  Возвращаемое значение:
		//  Тип: ДеревоЗначений - дерево описания метаданных конфигурации
		//

		public object ПолучитьДеревоМетаданныхКонфигурации(/*Отбор = Неопределено*/)
		{
			/*ИспользоватьОтбор = (Отбор <> Неопределено);*/
			/*КоллекцииОбъектовМетаданных = Новый ТаблицаЗначений;*/
			/*КоллекцииОбъектовМетаданных.Колонки.Добавить("Имя");*/
			/*КоллекцииОбъектовМетаданных.Колонки.Добавить("Синоним");*/
			/*КоллекцииОбъектовМетаданных.Колонки.Добавить("Картинка");*/
			/*КоллекцииОбъектовМетаданных.Колонки.Добавить("КартинкаОбъекта");*/
			/*НоваяСтрокаКоллекцииОбъектовМетаданных("Константы",               "Константы",                 БиблиотекаКартинок.Константа,              БиблиотекаКартинок.Константа,                    КоллекцииОбъектовМетаданных);*/
			/*НоваяСтрокаКоллекцииОбъектовМетаданных("Справочники",             "Справочники",               БиблиотекаКартинок.Справочник,             БиблиотекаКартинок.Справочник,                   КоллекцииОбъектовМетаданных);*/
			/*НоваяСтрокаКоллекцииОбъектовМетаданных("Документы",               "Документы",                 БиблиотекаКартинок.Документ,               БиблиотекаКартинок.ДокументОбъект,               КоллекцииОбъектовМетаданных);*/
			/*НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыВидовХарактеристик", "Планы видов характеристик", БиблиотекаКартинок.ПланВидовХарактеристик, БиблиотекаКартинок.ПланВидовХарактеристикОбъект, КоллекцииОбъектовМетаданных);*/
			/*НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыСчетов",             "Планы счетов",              БиблиотекаКартинок.ПланСчетов,             БиблиотекаКартинок.ПланСчетовОбъект,             КоллекцииОбъектовМетаданных);*/
			/*НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыВидовРасчета",       "Планы видов характеристик", БиблиотекаКартинок.ПланВидовХарактеристик, БиблиотекаКартинок.ПланВидовХарактеристикОбъект, КоллекцииОбъектовМетаданных);*/
			/*НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыСведений",        "Регистры сведений",         БиблиотекаКартинок.РегистрСведений,        БиблиотекаКартинок.РегистрСведений,              КоллекцииОбъектовМетаданных);*/
			/*НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыНакопления",      "Регистры накопления",       БиблиотекаКартинок.РегистрНакопления,      БиблиотекаКартинок.РегистрНакопления,            КоллекцииОбъектовМетаданных);*/
			/*НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыБухгалтерии",     "Регистры бухгалтерии",      БиблиотекаКартинок.РегистрБухгалтерии,     БиблиотекаКартинок.РегистрБухгалтерии,           КоллекцииОбъектовМетаданных);*/
			/*НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыРасчета",         "Регистры расчета",          БиблиотекаКартинок.РегистрРасчета,         БиблиотекаКартинок.РегистрРасчета,               КоллекцииОбъектовМетаданных);*/
			/*НоваяСтрокаКоллекцииОбъектовМетаданных("БизнесПроцессы",          "Бизнес-процессы",           БиблиотекаКартинок.БизнесПроцесс,          БиблиотекаКартинок.БизнесПроцессОбъект,          КоллекцииОбъектовМетаданных);*/
			/*НоваяСтрокаКоллекцииОбъектовМетаданных("Задачи",                  "Задачи",                    БиблиотекаКартинок.Задача,                 БиблиотекаКартинок.ЗадачаОбъект,                 КоллекцииОбъектовМетаданных);*/
			/*// возвращаемое значение функции
*/
			/*ДеревоМетаданных = Новый ДеревоЗначений;*/
			/*ДеревоМетаданных.Колонки.Добавить("Имя");*/
			/*ДеревоМетаданных.Колонки.Добавить("ПолноеИмя");*/
			/*ДеревоМетаданных.Колонки.Добавить("Синоним");*/
			/*ДеревоМетаданных.Колонки.Добавить("Картинка");*/
			/*// удаляем строки без подчиненных элементов
*/
			if(true/*ИспользоватьОтбор*/)
			{
				/*// используем обратный порядок обхода дерева значений
*/
				/*КолвоЭлементовКоллекции = ДеревоМетаданных.Строки.Количество();*/
			}
			return null;
		}

		public void НоваяСтрокаКоллекцииОбъектовМетаданных(/*Имя, Синоним, Картинка, КартинкаОбъекта, Таб*/)
		{
			/*НоваяСтрока = Таб.Добавить();*/
			/*НоваяСтрока.Имя               = Имя;*/
			/*НоваяСтрока.Синоним           = Синоним;*/
			/*НоваяСтрока.Картинка          = Картинка;*/
			/*НоваяСтрока.КартинкаОбъекта   = КартинкаОбъекта;*/
		}
		// Возвращает строку реквизитов объекта метаданных с заданным типом
		//
		// Параметры:
		//  Ссылка – ЛюбаяСсылка – ссылка на элемент базы данных, для которого требуется получить результат функции
		//  Тип    – Тип – тип значения реквизита
		//
		//  Возвращаемое значение:
		// Тип: Строка – строка реквизитов объекта метаданных конфигурации, разделенные символом ","
		//

		public object ИменаРеквизитовПоТипу(/*Ссылка, Тип*/)
		{
			/*Результат = "";*/
			/*МетаданныеОбъекта = Ссылка.Метаданные();*/
			return null;
		}
		// Получает имя значения перечисления как объекта метаданных
		//
		// Параметры:
		//  Значение - значение перечисления для которого необходимо получить имя перечисления
		//
		// Возвращаемое значение:
		//  Строка - имя значения перечисления как объекта метаданных
		//

		public object ИмяЗначенияПеречисления(/*Значение*/)
		{
			/*ОбъектМетаданных = Значение.Метаданные();*/
			/*ИндексЗначения = Перечисления[ОбъектМетаданных.Имя].Индекс(Значение);*/
			return null;
		}
		// Возвращает имя базового типа по переданному значению объекта метаданных
		//
		// Параметры:
		//  ОбъектМетаданных - объект метаданных, по которому необходимо определить базовый тип
		//
		// Возвращаемое значение:
		//  Строка - имя базового типа по переданному значению объекта метаданных
		//

		public object ИмяБазовогоТипаПоОбъектуМетаданных(/*ОбъектМетаданных*/)
		{
			if(true/*Метаданные.Документы.Содержит(ОбъектМетаданных)*/)
			{
			}
			return null;
		}
		// Возвращает менеджер объекта по полному имени объекта метаданных
		//
		// Не обрабатываются точки маршрутов бизнес-процессов
		//
		// Параметры:
		//  ПолноеИмя    - Строка, полное имя объекта метаданных,
		//                 например, "Справочник.Организации"
		//
		// Возвращаемое значение:
		//  СправочникМенеджер, ДокументМенеджер, ...
		//

		public object МенеджерОбъектаПоПолномуИмени(/*ПолноеИмя*/)
		{
			/*ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмя, ".");*/
			/*КлассОМ = ЧастиИмени[0];*/
			/*ИмяОМ   = ЧастиИмени[1];*/
			if(true/*ВРег(КлассОМ) = "ПЛАНОБМЕНА"*/)
			{
			}
			return null;
		}
		// Возвращает менеджер объекта по ссылке на объект
		//
		// Не обрабатываются точки маршрутов бизнес-процессов
		//
		// Параметры:
		//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
		//
		// Возвращаемое значение:
		//  СправочникМенеджер, ДокументМенеджер, ...
		//

		public object МенеджерОбъектаПоСсылке(/*Ссылка*/)
		{
			/*ИмяОбъекта = Ссылка.Метаданные().Имя;*/
			/*ТипСсылки = ТипЗнч(Ссылка);*/
			if(true/*Справочники.ТипВсеСсылки().СодержитТип(ТипСсылки)*/)
			{
			}
			return null;
		}
		// Проверяет физическое наличие записи в информационной базе данных о переданном значении ссылки
		//
		// Параметры:
		//  ЛюбаяСсылка - значение любой ссылки информационной базы данных
		//
		// Возвращаемое значение:
		//  Истина - ссылка физически существует;
		//  Ложь   - ссылка физически не существует
		//

		public object СсылкаСуществует(/*ЛюбаяСсылка*/)
		{
			/*ТекстЗапроса = "
		|ВЫБРАТЬ
		|	Ссылка
		|ИЗ
		|	[ИмяТаблицы]
		|ГДЕ
		|	Ссылка = &Ссылка
		|";*/
			/*ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ИмяТаблицы]", ИмяТаблицыПоСсылке(ЛюбаяСсылка));*/
			/*Запрос = Новый Запрос;*/
			/*Запрос.Текст = ТекстЗапроса;*/
			/*Запрос.УстановитьПараметр("Ссылка", ЛюбаяСсылка);*/
			/*УстановитьПривилегированныйРежим(Истина);*/
			return null;
		}
		// Функция ВидОбъектаПоСсылке возвращает имя вида объектов метаданных
		// по ссылке на объект.
		//
		// Не обрабатываются точки маршрутов бизнес-процессов.
		//
		// Параметры:
		//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
		//
		// Возвращаемое значение:
		//  Строка       - имя вида объектов метаданных, например, "Справочник", "Документ" ...
		//

		public object ВидОбъектаПоСсылке(/*Ссылка*/)
		{
			return null;
		}
		// Функция возвращает имя вида объектов метаданных по типу объекта.
		//
		// Не обрабатываются точки маршрутов бизнес-процессов.
		//
		// Параметры:
		//  Тип       - Тип прикладного объекта, определенный в конфигурации
		//
		// Возвращаемое значение:
		//  Строка       - имя вида объектов метаданных, например, "Справочник", "Документ" ...
		//

		public object ВидОбъектаПоТипу(/*Тип*/)
		{
			if(true/*Справочники.ТипВсеСсылки().СодержитТип(Тип)*/)
			{
			}
			return null;
		}
		// Возвращает полное имя объекта метаданных по переданному значению ссылки
		// Например,
		//  "Справочник.Номенклатура";
		//  "Документ.ПриходнаяНакладная"
		//
		// Параметры:
		//  Ссылка - ЛюбаяСсылка - значение ссылки, для которого необходимо получить имя таблицы ИБ
		//
		// Возвращаемое значение:
		//  Строка - полное имя объекта метаданных для указанного значения ссылки
		//

		public object ИмяТаблицыПоСсылке(/*Ссылка*/)
		{
			return null;
		}
		// Возвращает строковое представление типа.
		// Для ссылочных типов возвращает в формате "СправочникСсылка.ИмяОбъекта" или "ДокументСсылка.ИмяОбъекта"
		// Для остальных типов приводит тип к строке, например "Число".
		//

		public object СтроковоеПредставлениеТипа(/*Тип*/)
		{
			/*Представление = "";*/
			if(true/*ЭтоСсылка(Тип)*/)
			{
				/*ПолноеИмя = Метаданные.НайтиПоТипу(Тип).ПолноеИмя();*/
				/*ИмяОбъекта = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмя, ".")[1];*/
				if(true/*Справочники.ТипВсеСсылки().СодержитТип(Тип)*/)
				{
					/*Представление = "СправочникСсылка";*/
				}
				/*Результат = ?(Представление = "", Представление, Представление + "." + ИмяОбъекта);*/
			}
			return null;
		}
		// Проверить, что значение имеет ссылочный тип данных.
		//
		// Параметры:
		//  Значение       - ссылка на объект, - элемент справочника, документ, ...
		//
		// Возвращаемое значение:
		//  Булево       - Истина, если тип значения ссылочный.
		//

		public object ЗначениеСсылочногоТипа(/*Значение*/)
		{
			if(true/*Значение = Неопределено*/)
			{
			}
			if(true/*Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение))*/)
			{
			}
			if(true/*Документы.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение))*/)
			{
			}
			if(true/*Перечисления.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение))*/)
			{
			}
			if(true/*ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение))*/)
			{
			}
			if(true/*ПланыСчетов.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение))*/)
			{
			}
			if(true/*ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение))*/)
			{
			}
			if(true/*БизнесПроцессы.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение))*/)
			{
			}
			if(true/*БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(ТипЗнч(Значение))*/)
			{
			}
			if(true/*Задачи.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение))*/)
			{
			}
			if(true/*ПланыОбмена.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение))*/)
			{
			}
			return null;
		}
		// Проверка того, что тип имеет ссылочный тип данных
		//

		public object ЭтоСсылка(/*Тип*/)
		{
			return null;
		}
		// Является ли объект группой
		// В качестве параметра может принимать только справочник или ПВХ
		//

		public object ОбъектЯвляетсяГруппой(/*Объект*/)
		{
			/*МетаданныеОбъекта = Объект.Метаданные();*/
			if(true/*ЭтоСправочник(МетаданныеОбъекта)
	И НЕ (МетаданныеОбъекта.Иерархический И МетаданныеОбъекта.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов)*/)
			{
			}
			if(true/*ЗначениеСсылочногоТипа(Объект)*/)
			{
			}
			/*Ссылка = Объект.Ссылка;*/
			if(true/*Не ЗначениеЗаполнено(Ссылка)*/)
			{
			}
			return null;
		}
		// Проверяет наличие табличной части у справочника
		//
		//Параметры
		//  ИмяСправочника    - Строка - имя справочника, для которого осуществляется проверка.
		//  ИмяТабличнойЧасти - Строка - имя табличной части, наличие которой проверяется.
		//
		//Возвращаемое значение:
		//  Булево   - Истина, если табличная часть есть, ложь в обратном случае
		//
		//Пример:
		//  Если НЕ ОбщегоНазначения.НаличиеТабличнойЧастиУСправочника(ИмяСправочника,"КонтактнаяИнформация") Тогда
		//  	Возврат;
		//  КонецЕсли;
		//

		public object НаличиеТабличнойЧастиУСправочника(/*ИмяСправочника,ИмяТабличнойЧасти*/)
		{
			return null;
		}
		// Возвращает описание предмета в виде текстовой строки.
		//
		// Параметры
		//  СсылкаНаПредмет  – ЛюбаяСсылка – объект ссылочного типа.
		//
		// Возвращаемое значение:
		//   Строка
		//

		public object ПредметСтрокой(/*СсылкаНаПредмет*/)
		{
			/*Результат = "";*/
			/*СтандартныеПодсистемыПереопределяемый.УстановитьПредставлениеПредмета(СсылкаНаПредмет, Результат);*/
			/*ОбщегоНазначенияПереопределяемый.УстановитьПредставлениеПредмета(СсылкаНаПредмет, Результат);*/
			if(true/*ПустаяСтрока(Результат)*/)
			{
				if(true/*СсылкаНаПредмет = Неопределено или СсылкаНаПредмет.Пустая()*/)
				{
					/*Результат = НСтр("ru = 'не задан'");*/
				}
			}
			return null;
		}
		// Формирует расширенное представление объекта.
		// Расширенное представление объекта складывается из представления объекта, кода и наименования.
		// Если для объекта не удалось получить расширенное представление,
		// то возвращается стандартное представление объекта, формируемое платформой.
		//
		// Пример возвращаемого значения функции:
		// "Контрагент 0А-0001234, ООО Телекоммуникационные системы"
		//
		//  Параметры:
		// Объект. Тип: СправочникСсылка,
		//				ПланСчетовСсылка,
		//				ПланОбменаСсылка,
		//				ПланВидовХарактеристикСсылка,
		//				ПланВидовРасчетаСсылка.
		// Объект, для которого требуется получить расширенное представление.
		//
		//  Возвращаемое значение:
		// Тип. Строка.
		// Расширенное представление объекта.
		//

		public object РасширенноеПредставлениеОбъекта(/*Объект*/)
		{
			/*ОбъектМетаданных = Объект.Метаданные();*/
			/*ИмяБазовогоТипа = ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных);*/
			if(true/*ИмяБазовогоТипа = ИмяТипаСправочники()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыСчетов()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыОбмена()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовХарактеристик()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовРасчета()*/)
			{
				if(true/*ЭтоСтандартныйРеквизит(ОбъектМетаданных.СтандартныеРеквизиты, "Код")
			И ЭтоСтандартныйРеквизит(ОбъектМетаданных.СтандартныеРеквизиты, "Наименование")*/)
				{
					/*ЗначенияРеквизитов = ПолучитьЗначенияРеквизитов(Объект, "Код, Наименование");*/
					/*ПредставлениеОбъекта = ?(ПустаяСтрока(ОбъектМетаданных.ПредставлениеОбъекта), 
										?(ПустаяСтрока(ОбъектМетаданных.Синоним), ОбъектМетаданных.Имя, ОбъектМетаданных.Синоним
										),
									ОбъектМетаданных.ПредставлениеОбъекта
			);*/
					/*Результат = "[ПредставлениеОбъекта] [Код], [Наименование]";*/
					/*Результат = СтрЗаменить(Результат, "[ПредставлениеОбъекта]", ПредставлениеОбъекта);*/
					/*Результат = СтрЗаменить(Результат, "[Код]",          ?(ПустаяСтрока(ЗначенияРеквизитов.Код), "<>", ЗначенияРеквизитов.Код));*/
					/*Результат = СтрЗаменить(Результат, "[Наименование]", ?(ПустаяСтрока(ЗначенияРеквизитов.Наименование), "<>", ЗначенияРеквизитов.Наименование));*/
				}
			}
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// Функции определения типов объектов метаданных
		// Ссылочные типы данных
		// Определяет принадлежность объекта метаданных к общему типу "Документ"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоДокумент(/*ОбъектМетаданных*/)
		{
			return null;
		}
		// Определяет принадлежность объекта метаданных к общему типу "Справочник"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоСправочник(/*ОбъектМетаданных*/)
		{
			return null;
		}
		// Определяет принадлежность объекта метаданных к общему типу "Перечисление"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоПеречисление(/*ОбъектМетаданных*/)
		{
			return null;
		}
		// Определяет принадлежность объекта метаданных к общему типу "План обмена"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоПланОбмена(/*ОбъектМетаданных*/)
		{
			return null;
		}
		// Определяет принадлежность объекта метаданных к общему типу "План видов характеристик"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоПланВидовХарактеристик(/*ОбъектМетаданных*/)
		{
			return null;
		}
		// Определяет принадлежность объекта метаданных к общему типу "Бизнес-процесс"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоБизнесПроцесс(/*ОбъектМетаданных*/)
		{
			return null;
		}
		// Определяет принадлежность объекта метаданных к общему типу "Задача"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоЗадача(/*ОбъектМетаданных*/)
		{
			return null;
		}
		// Определяет принадлежность объекта метаданных к общему типу "План счетов"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоПланСчетов(/*ОбъектМетаданных*/)
		{
			return null;
		}
		// Определяет принадлежность объекта метаданных к общему типу "План видов расчета"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоПланВидовРасчета(/*ОбъектМетаданных*/)
		{
			return null;
		}
		// Регистры
		// Определяет принадлежность объекта метаданных к общему типу "Регистр сведений"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоРегистрСведений(/*ОбъектМетаданных*/)
		{
			return null;
		}
		// Определяет принадлежность объекта метаданных к общему типу "Регистр накопления"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоРегистрНакопления(/*ОбъектМетаданных*/)
		{
			return null;
		}
		// Определяет принадлежность объекта метаданных к общему типу "Регистр бухгалтерии"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоРегистрБухгалтерии(/*ОбъектМетаданных*/)
		{
			return null;
		}
		// Определяет принадлежность объекта метаданных к общему типу "Регистр расчета"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоРегистрРасчета(/*ОбъектМетаданных*/)
		{
			return null;
		}
		// Константы
		// Определяет принадлежность объекта метаданных к общему типу "Константа"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоКонстанта(/*ОбъектМетаданных*/)
		{
			return null;
		}
		// Журналы документов
		// Определяет принадлежность объекта метаданных к общему типу "Журнал документов"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоЖурналДокументов(/*ОбъектМетаданных*/)
		{
			return null;
		}
		// Общие
		// Определяет принадлежность объекта метаданных к типу регистр
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоРегистр(/*ОбъектМетаданных*/)
		{
			/*ИмяБазовогоТипа = ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных);*/
			return null;
		}
		// Определяет принадлежность объекта метаданных к ссылочному типу
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоОбъектСсылочногоТипа(/*ОбъектМетаданных*/)
		{
			/*ИмяБазовогоТипа = ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных);*/
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// Имена типов.
		// Возвращает значение для идентификации общего типа "Регистры сведений"
		//
		// Тип: Строка
		//

		public object ИмяТипаРегистрыСведений(/**/)
		{
			return null;
		}
		// Возвращает значение для идентификации общего типа "Регистры накопления"
		//
		// Тип: Строка
		//

		public object ИмяТипаРегистрыНакопления(/**/)
		{
			return null;
		}
		// Возвращает значение для идентификации общего типа "Регистры бухгалтерии"
		//
		// Тип: Строка
		//

		public object ИмяТипаРегистрыБухгалтерии(/**/)
		{
			return null;
		}
		// Возвращает значение для идентификации общего типа "Регистры расчета"
		//
		// Тип: Строка
		//

		public object ИмяТипаРегистрыРасчета(/**/)
		{
			return null;
		}
		// Возвращает значение для идентификации общего типа "Документы"
		//
		// Тип: Строка
		//

		public object ИмяТипаДокументы(/**/)
		{
			return null;
		}
		// Возвращает значение для идентификации общего типа "Справочники"
		//
		// Тип: Строка
		//

		public object ИмяТипаСправочники(/**/)
		{
			return null;
		}
		// Возвращает значение для идентификации общего типа "Перечисления"
		//
		// Тип: Строка
		//

		public object ИмяТипаПеречисления(/**/)
		{
			return null;
		}
		// Возвращает значение для идентификации общего типа "ПланыОбмена"
		//
		// Тип: Строка
		//

		public object ИмяТипаПланыОбмена(/**/)
		{
			return null;
		}
		// Возвращает значение для идентификации общего типа "Планы видов характеристик"
		//
		// Тип: Строка
		//

		public object ИмяТипаПланыВидовХарактеристик(/**/)
		{
			return null;
		}
		// Возвращает значение для идентификации общего типа "Бизнес-процессы"
		//
		// Тип: Строка
		//

		public object ИмяТипаБизнесПроцессы(/**/)
		{
			return null;
		}
		// Возвращает значение для идентификации общего типа "Задачи"
		//
		// Тип: Строка
		//

		public object ИмяТипаЗадачи(/**/)
		{
			return null;
		}
		// Возвращает значение для идентификации общего типа "Планы счетов"
		//
		// Тип: Строка
		//

		public object ИмяТипаПланыСчетов(/**/)
		{
			return null;
		}
		// Возвращает значение для идентификации общего типа "Планы видов расчета"
		//
		// Тип: Строка
		//

		public object ИмяТипаПланыВидовРасчета(/**/)
		{
			return null;
		}
		// Возвращает значение для идентификации общего типа "Константы"
		//
		// Тип: Строка
		//

		public object ИмяТипаКонстанты(/**/)
		{
			return null;
		}
		// Возвращает значение для идентификации общего типа "Журналы документов"
		//
		// Тип: Строка
		//

		public object ИмяТипаЖурналыДокументов(/**/)
		{
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		//  Сохранение и чтение настроек
		// Сохраняет массив пользовательских настроек МассивСтруктур.
		// Может применяться для случаев вызова с клиента.
		//
		// Параметры:
		//    МассивСтруктур - Массив - массив структур с полями "Объект", "Настройка", "Значение".
		//    НужноОбновитьПовторноИспользуемыеЗначения - Булево - требуется обновить повторно используемые значения
		//

		public void ХранилищеОбщихНастроекСохранитьМассив(/*МассивСтруктур, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь*/)
		{
			if(true/*Не ПравоДоступа("СохранениеДанныхПользователя", Метаданные)*/)
			{
			}
			if(true/*НужноОбновитьПовторноИспользуемыеЗначения*/)
			{
				/*ОбновитьПовторноИспользуемыеЗначения();*/
			}
		}
		// Сохраняет массив пользовательских настроек МассивСтруктур и
		// обновляет повторно используемые значения.
		// Может применяться для случаев вызова с клиента.
		//
		// Параметры:
		//    МассивСтруктур - Массив - массив структур с полями "Объект", "Настройка", "Значение".
		//

		public void ХранилищеОбщихНастроекСохранитьМассивИОбновитьПовторноИспользуемыеЗначения(/*МассивСтруктур*/)
		{
			/*ХранилищеОбщихНастроекСохранитьМассив(МассивСтруктур, Истина);*/
		}
		// Сохраняет пользовательскую настройку по имени.
		//
		// Параметры:
		//    соответствуют методу ХранилищеОбщихНастроек.Сохранить
		//

		public void ХранилищеОбщихНастроекСохранить(/*КлючОбъекта, КлючНастроек = Неопределено, Значение,
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь*/)
		{
			if(true/*НЕ ПравоДоступа("СохранениеДанныхПользователя", Метаданные)*/)
			{
			}
			/*ХранилищеОбщихНастроек.Сохранить(КлючОбъекта, КлючНастроек, Значение, ОписаниеНастроек, ИмяПользователя);*/
			if(true/*НужноОбновитьПовторноИспользуемыеЗначения*/)
			{
				/*ОбновитьПовторноИспользуемыеЗначения();*/
			}
		}
		// Сохраняет пользовательскую настройку по имени и
		// обновляет повторно используемые значения.
		//
		// Параметры:
		//    соответствуют методу ХранилищеОбщихНастроек.Сохранить
		//

		public void ХранилищеОбщихНастроекСохранитьИОбновитьПовторноИспользуемыеЗначения(/*КлючОбъекта, КлючНастроек, Значение*/)
		{
			/*ХранилищеОбщихНастроекСохранить(КлючОбъекта, КлючНастроек, Значение,,,Истина);*/
		}
		// Возвращает значение пользовательской настройки по имени.
		//
		// Параметры:
		//    соответствуют методу ХранилищеОбщихНастроек.Загрузить
		//

		public object ХранилищеОбщихНастроекЗагрузить(/*КлючОбъекта, КлючНастроек = Неопределено, ЗначениеПоУмолчанию = Неопределено, 
		ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено*/)
		{
			/*Результат = Неопределено;*/
			if(true/*ПравоДоступа("СохранениеДанныхПользователя", Метаданные)*/)
			{
				/*Результат = ХранилищеОбщихНастроек.Загрузить(КлючОбъекта, КлючНастроек, ОписаниеНастроек, ИмяПользователя);*/
			}
			if(true/*(Результат = Неопределено) И (ЗначениеПоУмолчанию <> Неопределено)*/)
			{
				/*Результат = ЗначениеПоУмолчанию;*/
			}
			return null;
		}
		// Сохраняет пользовательскую настройку по имени.
		//
		// Параметры:
		//    соответствуют методу ХранилищеНастроекДанныхФорм.Сохранить
		//

		public void ХранилищеНастроекДанныхФормСохранить(/*КлючОбъекта, КлючНастроек = Неопределено, Значение,
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь*/)
		{
			/*ХранилищеСохранить(
		ХранилищеНастроекДанныхФорм, 
		КлючОбъекта, 
		КлючНастроек, 
		Значение,
		ОписаниеНастроек, 
		ИмяПользователя, 
		НужноОбновитьПовторноИспользуемыеЗначения
	);*/
		}
		// Возвращает значение пользовательской настройки по имени.
		//
		// Параметры:
		//    соответствуют методу ХранилищеНастроекДанныхФорм.Загрузить
		//

		public object ХранилищеНастроекДанныхФормЗагрузить(/*КлючОбъекта, КлючНастроек = Неопределено, ЗначениеПоУмолчанию = Неопределено, 
		ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено*/)
		{
			return null;
		}
		// Сохраняет пользовательскую настройку по имени.
		//

		public void ХранилищеСохранить(/*МенеджерХранилища, КлючОбъекта, КлючНастроек, Значение,
	ОписаниеНастроек, ИмяПользователя, НужноОбновитьПовторноИспользуемыеЗначения*/)
		{
			if(true/*НЕ ПравоДоступа("СохранениеДанныхПользователя", Метаданные)*/)
			{
			}
			/*МенеджерХранилища.Сохранить(КлючОбъекта, КлючНастроек, Значение, ОписаниеНастроек, ИмяПользователя);*/
			if(true/*НужноОбновитьПовторноИспользуемыеЗначения*/)
			{
				/*ОбновитьПовторноИспользуемыеЗначения();*/
			}
		}
		// Возвращает значение пользовательской настройки по имени.
		//

		public object ХранилищеЗагрузить(/*МенеджерХранилища, КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию, 
	ОписаниеНастроек, ИмяПользователя*/)
		{
			/*Результат = Неопределено;*/
			if(true/*ПравоДоступа("СохранениеДанныхПользователя", Метаданные)*/)
			{
				/*Результат = МенеджерХранилища.Загрузить(КлючОбъекта, КлючНастроек, ОписаниеНастроек, ИмяПользователя);*/
			}
			if(true/*(Результат = Неопределено) И (ЗначениеПоУмолчанию <> Неопределено)*/)
			{
				/*Результат = ЗначениеПоУмолчанию;*/
			}
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// Общие процедуры и функции
		// Функция возвращает ссылку на текущего пользователя базы данных,
		// установленного по учетной записи пользователя конфигурации.
		//
		// Возвращаемое значение:
		//  СправочникСсылка.Пользователи
		//

		public object ТекущийПользователь(/**/)
		{
			return null;
		}
		// Выполнить экспортную процедуру без параметров по имени.
		//
		// Параметры
		//  ИмяЭкспортнойПроцедуры – Строка    – имя экспортной процедуры в формате
		//                                       <имя объекта>.<имя процедуры>, где <имя объекта> - это
		//                                       общий модуль или модуль менеджера объекта.
		//
		// Пример
		//  ВыполнитьБезопасно("МойОбщийМодуль.МояПроцедура");
		//

		public void ВыполнитьБезопасно(/*Знач ИмяЭкспортнойПроцедуры*/)
		{
			if(true/*Не ПроверитьИмяЭкспортнойПроцедуры(ИмяЭкспортнойПроцедуры, ТекстСообщения)*/)
			{
				/*ВызватьИсключение ТекстСообщения;*/
			}
			/*Выполнить ИмяЭкспортнойПроцедуры + "();";*/
		}
		// Проверяет имя экспортной процедуры на валидность для использования
		// в инструкции Выполнить встроенного языка. При некорректном имени
		// вызывается исключение.
		//

		public object ПроверитьИмяЭкспортнойПроцедуры(/*Знач ИмяЭкспортнойПроцедуры, ТекстСообщения*/)
		{
			/*// Проверка предусловий на формат ИмяЭкспортнойПроцедуры.
*/
			/*ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЭкспортнойПроцедуры, ".");*/
			if(true/*ЧастиИмени.Количество() <> 2 И ЧастиИмени.Количество() <> 3*/)
			{
				/*ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
			ИмяЭкспортнойПроцедуры);*/
			}
			/*ИмяОбъекта = ЧастиИмени[0];*/
			if(true/*ЧастиИмени.Количество() = 2 И Метаданные.ОбщиеМодули.Найти(ИмяОбъекта) = Неопределено*/)
			{
				/*ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
			ИмяЭкспортнойПроцедуры);*/
			}
			if(true/*ЧастиИмени.Количество() = 3*/)
			{
				/*ДопустимыеИменаТипов = Новый Массив;*/
				/*ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаКонстанты()));*/
				/*ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыСведений()));*/
				/*ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыНакопления()));*/
				/*ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыБухгалтерии()));*/
				/*ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыРасчета()));*/
				/*ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаСправочники()));*/
				/*ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаДокументы()));*/
				/*ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаБизнесПроцессы()));*/
				/*ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаЗадачи()));*/
				/*ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыСчетов()));*/
				/*ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыОбмена()));*/
				/*ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыВидовХарактеристик()));*/
				/*ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыВидовРасчета()));*/
				/*ИмяТипа = ВРег(ЧастиИмени[0]);*/
				if(true/*ДопустимыеИменаТипов.Найти(ИмяТипа) = Неопределено*/)
				{
					/*ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
				ИмяЭкспортнойПроцедуры);*/
				}
			}
			return null;
		}
		// Объединяет исключения поиска ссылок.
		//

		public object ПолучитьОбщийСписокИсключенийПоискаСсылок(/**/)
		{
			/*ОбщийМассивИсключенийСсылок = Новый Массив;*/
			/*ЗаполнитьМассивУникальнымиЗначениями(ОбщийМассивИсключенийСсылок, СтандартныеПодсистемыПереопределяемый.ИсключенияПоискаСсылок());*/
			/*ЗаполнитьМассивУникальнымиЗначениями(ОбщийМассивИсключенийСсылок, ОбщегоНазначенияПереопределяемый.ПолучитьИсключенияПоискаСсылок());*/
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// Вспомогательные процедуры и функции
		// Функция ИнформационнаяБазаФайловая определяет режим эксплуатации
		// информационной базы файловый (Истина) или Серверный (Ложь).
		//  При проверке используется СтрокаСоединенияИнформационнойБазы, которую
		// можно указать явно.
		//
		// Параметры:
		//  СтрокаСоединенияИнформационнойБазы - Строка - параметр используется, если
		//                 нужно проверить строку соединения не текущей информационной базы.
		//
		// Возвращаемое значение:
		//  Булево.
		//

		public object ИнформационнаяБазаФайловая(/*Знач СтрокаСоединенияИнформационнойБазы = ""*/)
		{
			if(true/*ПустаяСтрока(СтрокаСоединенияИнформационнойБазы)*/)
			{
				/*СтрокаСоединенияИнформационнойБазы =  СтрокаСоединенияИнформационнойБазы();*/
			}
			return null;
		}
		// Получить представление информационной базы для отображения пользователю.
		//
		// Возвращаемое значение:
		//   Строка      - Представление информационной базы
		//
		// Пример возвращаемого результата:
		// - для ИБ в файлом режиме: \\FileServer\1c_ib\
		// - для ИБ в серверном режиме: ServerName:1111 / information_base_name
		//

		public object ПолучитьПредставлениеИнформационнойБазы(/**/)
		{
			/*СтрокаСоединенияСБД = СтрокаСоединенияИнформационнойБазы();*/
			if(true/*ИнформационнаяБазаФайловая(СтрокаСоединенияСБД)*/)
			{
				/*ПутьКБД = Сред(СтрокаСоединенияСБД, 6, СтрДлина(СтрокаСоединенияСБД) - 6);*/
			}
			return null;
		}
		// Проверить, что описание типа состоит из единственного типа значения и
		// совпадает с нужным типом.
		//
		// Возвращаемое значение:
		//   Булево      - Совпадает или нет
		//

		public object ОписаниеТипаСостоитИзТипа(/*ОписаниеТипа, ТипЗначения*/)
		{
			if(true/*ОписаниеТипа.Типы().Количество() = 1
	   И ОписаниеТипа.Типы().Получить(0) = ТипЗначения*/)
			{
			}
			return null;
		}
		// Получает таблицу значений с описанием требуемых свойств всех реквизитов объекта метаданного
		// Получает значения свойств стандартных реквизитов и пользовательских реквизитов (созданных в режиме конфигуратора)
		//
		// Параметры:
		//  ОбъектМетаданных  - Объект метаданных конфигурации, для которого необходимо получить значение свойств реквизитов.
		//                      Например: Метаданные.Документ.РеализацияТоваровИУслуг
		//  Свойства - Строка - свойства реквизитов, перечисленных через запятую, значение которых необходимо получить.
		//                      Например: "Имя, Тип, Синоним, Подсказка"
		//
		// Возвращаемое значение:
		//  ТаблицаЗначений - таблица значений с описанием требуемых свойств всех реквизитов объекта метаданного
		//

		public object ПолучитьТаблицуОписанияСвойствОбъекта(/*ОбъектМетаданных, Свойства*/)
		{
			/*МассивСвойств = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Свойства);*/
			/*// возвращаемое значение функции
*/
			/*ТаблицаОписанияСвойствОбъекта = Новый ТаблицаЗначений;*/
			/*// добавляем в таблицу поля согласно именам переданных свойств
*/
			/*// заполняем строку таблицы свойствами реквизитов объекта метаданных
*/
			/*// заполняем строку таблицы свойствами стандартных реквизитов объекта метаданных
*/
			return null;
		}
		// Процедура предназначена для заполнения реквизита формы типа «ДеревоЗначений»
		//
		// Параметры:
		// КоллекцияЭлементовДерева – реквизит формы, который имеет тип «ДеревоЗначений»;
		// 							  реквизит заполняется значениями из второго параметра процедуры.
		// ДеревоЗначений           – ДеревоЗначений – параметр содержит данные для заполнения.
		//

		public void ЗаполнитьКоллекциюЭлементовДереваДанныхФормы(/*КоллекцияЭлементовДерева, ДеревоЗначений*/)
		{
		}
		// Проверяет наличие табличной части у документа
		//
		//Параметры
		//  ИмяДокумента      - Строка - имя документа, для которого осуществляется проверка.
		//  ИмяТабличнойЧасти - Строка - имя табличной части, наличие которой проверяется.
		//
		//Возвращаемое значение:
		//  Булево   - Истина, если табличная часть есть, ложь в обратном случае
		//

		public object НаличиеТабличнойЧастиУДокумента(/*ИмяДокумента, ИмяТабличнойЧасти*/)
		{
			return null;
		}

		public object СравнитьТипСсылкиДокумента(/*Ссылка, ИмяДокумента*/)
		{
			if(true/*Метаданные.Документы.Найти(ИмяДокумента) = Неопределено*/)
			{
			}
			return null;
		}
		// Переадресация вызова функции ПолучитьЗначениеПеременной
		//

		public object ПолучитьЗначениеПеременной(/*ИмяПараметра, Кэш = Неопределено, КэшИзменен = Ложь*/)
		{
			return null;
		}
		// Получение представления для документа, удостоверяющего личность
		//
		// Параметры
		//  ДанныеФизЛица  – Коллекция данных физ. лица (структура, строка таблицы, ...), содержащая значения:
		//                   ДокументВид, ДокументСерия, ДокументНомер, ДокументДатаВыдачи, ДокументКемВыдан
		//
		// Возвращаемое значение:
		//   Строка   – Представление документа, удостоверяющего личность
		//

		public object ПолучитьПредставлениеДокументаФизЛица(/*ДанныеФизЛица*/)
		{
			return null;
		}
		// ПолучитьПредставлениеДокументаФизЛица()
		// Функция формирует фамилию и инициалы либо по наименованию элемента спр-ка ФизическиеЛица
		//  либо по переданным строкам.
		//  Если передан Объект, то извлеченная из него строка считается совокупностью
		//  Фамилия + Имя + Отчество, разделенными пробелами.
		//
		// Параметры
		//  Объект		- строка или ссылка или объект элемента спр-ка ФизическиеЛица.
		//  Фамилия		- фамилия физ. лица.
		//  Имя			- имя физ. лица.
		//  Отчество	- отчество физ. лица.
		//
		// Возвращаемое значение
		//  Фамилия и Инициалы одной строкой. Побочные эффекты - переданная целая строка
		//  Побочные эффекты - переданная целая строка разбивается на подстроки, соответствующие
		//  отдельным Фамилии,Имени и Отчеству
		//

		public object ФамилияИнициалыФизЛица(/*Объект = "", Фамилия = " ", Имя = " ", Отчество = " "*/)
		{
			if(true/*Не ЗначениеЗаполнено(Фамилия) И Не ЗначениеЗаполнено(Имя)*/)
			{
				/*ФИО = ФамилияИмяОтчествоФизЛица(Объект);*/
				/*Фамилия = ФИО.Фамилия;*/
				/*Имя		= ФИО.Имя;*/
				/*Отчество= ФИО.Отчество;*/
			}
			return null;
		}
		// Функция формирует фамилию и инициалы либо по наименованию элемента спр-ка ФизическиеЛица
		//  либо по переданным строкам.
		//  Если передан Объект, то извлеченная из него строка считается совокупностью
		//  Фамилия + Имя + Отчество, разделенными пробелами.
		//
		// Параметры
		//  Объект		- строка или ссылка или объект элемента спр-ка ФизическиеЛица.
		//  Фамилия		- фамилия физ. лица.
		//  Имя			- имя физ. лица.
		//  Отчество	- отчество физ. лица.
		//
		// Возвращаемое значение
		//  Фамилия и Инициалы одной строкой. Побочные эффекты - переданная целая строка
		//  Побочные эффекты - переданная целая строка разбивается на подстроки, соответствующие
		//  отдельным Фамилии,Имени и Отчеству
		//

		public object ИнициалыФизЛицаФамилия(/*Объект = "", Фамилия = " ", Имя = " ", Отчество = " "*/)
		{
			if(true/*НЕ ЗначениеЗаполнено("" + Фамилия + Имя + Отчество)*/)
			{
				/*ФИО = ФамилияИмяОтчествоФизЛица(Объект);*/
				/*Фамилия = ФИО.Фамилия;*/
				/*Имя		= ФИО.Имя;*/
				/*Отчество= ФИО.Отчество;*/
			}
			return null;
		}

		public object ФамилияИмяОтчествоФизЛица(/*Объект*/)
		{
			/*ТипОбъекта = ТипЗнч(Объект);*/
			/*ФИО = Новый Массив;*/
			if(true/*ТипОбъекта <> Тип("Неопределено")*/)
			{
				/*СписокТиповСсылок	= ОбщегоНазначенияПереопределяемый.ВернутьСписокТиповСсылокДляФормированияФИО();*/
				/*СписокТиповОбъектов	= ОбщегоНазначенияПереопределяемый.ВернутьСписокТиповОбъектовДляФормированияФИО();*/
				if(true/*ТипОбъекта = Тип("Строка")*/)
				{
					/*ФИО = РазложитьСтрокуВМассивПодстрок(СокрЛП(Объект)," ");*/
				}
			}
			/*КоличествоПодстрок = ФИО.Количество();*/
			/*Результат = Новый Структура;*/
			/*Результат.Вставить("Фамилия",	?(КоличествоПодстрок > 0,ФИО[0],""));*/
			/*Результат.Вставить("Имя",		?(КоличествоПодстрок > 1,ФИО[1],""));*/
			/*Результат.Вставить("Отчество",	?(КоличествоПодстрок > 2,ФИО[2],""));*/
			return null;
		}
		// Функция формирует фамилию и инициалы работника в заданном падеже
		// по переданным данным о работнике.
		//  либо по переданным строкам.
		//
		// Параметры
		//  Работник	- строка (Фамилия + Имя + Отчество, разделенными пробелами)
		//                или ссылка на элемент справочника ФизическиеЛица или Сотрудники.
		//  Падеж (необязательный), тип число
		//   Падеж, в который необходимо поставить ФИО.
		//   1 - Именительный
		//   2 - Родительный
		//   3 - Дательный
		//   4 - Винительный
		//   5 - Творительный
		//   6 - Предложный
		//
		//  Пол (необязательный), тип ПеречислениеСсылка.ПолФизическихЛиц
		//   Данный параметр предназначен для разрешения возможных неоднозначностей
		//   В остальных случаях рекомендуется опускать этот параметр.
		// Возвращаемое значение
		//  Фамилия и Инициалы одной строкой.
		//

		public object ПредставлениеРаботника(/*Работник, Знач Падеж = 1, Знач Пол = Неопределено*/)
		{
			/*ТипДанных = ТипЗнч(Работник);*/
			if(true/*ТипДанных = Тип("Строка")*/)
			{
				/*РаботникФИО = Работник;*/
				/*РаботникПол = Пол;*/
			}
			/*ФИО = ОбщегоНазначения.ФамилияИнициалыФизЛица(РаботникФИО);*/
			/*ПозицияПервогоПробела = Найти(ФИО + " "," ");*/
			/*Фамилия  = Лев(ФИО,ПозицияПервогоПробела-1);*/
			/*Инициалы = Сред(ФИО,ПозицияПервогоПробела+1);*/
			/*РезультатСклонения = "";*/
			if(true/*УниверсальныеМеханизмы.Просклонять(глЗначениеПеременной("глКомпонентаСклоненияФИО"), Фамилия, Падеж, РаботникПол, РезультатСклонения)*/)
			{
				/*ФИО = РезультатСклонения + " " + Инициалы;*/
			}
			return null;
		}
		// Функция возвращает совокупность данных о физическом лице в виде структуры,
		// В совокупность данных входит ФИО, должность в заданной организации,
		// паспортные данные и др.
		//
		// Параметры:
		//  Организация  - СправочникСсылка.Организации - организация, по которой
		//                 определяется должность и подразделение работника
		//  ФизЛицо      - СправочникСсылка.ФизическиеЛица - физическое лицо,
		//                 по которому возвращается совокупность данных
		//  ДатаСреза    - Дата - дата, на которую считываются данные
		//  ФИОКратко    - Булево - если Истина (по умолчанию), Представление физ.лица включает фамилию и инициалы, если Ложь - фамилию и полностью имя и отчество
		//
		// Возвращаемое значение:
		//  Структура    - Структура с совокупностью данных о физическом лице:
		//                 - Фамилия
		//                 - Имя
		//                 - Отчетсво
		//                 - Представление (Фамилия И.О.)
		//                 - Подразделение
		//                 - ДокументВид
		//                 - ДокументСерия
		//                 - ДокументНомер
		//                 - ДокументДатаВыдачи
		//                 - ДокументКемВыдан
		//                 - ДокументКодПодразделения
		//

		public object ДанныеФизЛица(/*Организация, ФизЛицо, ДатаСреза, ФИОКратко = Истина*/)
		{
			/*ЗапросПоЛицам = Новый Запрос();*/
			/*ЗапросПоЛицам.УстановитьПараметр("ДатаСреза",   ДатаСреза);*/
			/*ЗапросПоЛицам.УстановитьПараметр("Организация", Организация);*/
			/*ЗапросПоЛицам.УстановитьПараметр("ФизЛицо", ФизЛицо);*/
			/*ЗапросПоЛицам.Текст =
	"ВЫБРАТЬ
	|	ФизическиеЛица.Ссылка КАК ФизЛицо
	|ПОМЕСТИТЬ ФизЛица
	|ИЗ
	|	Справочник.ФизическиеЛица КАК ФизическиеЛица
	|ГДЕ
	|	ФизическиеЛица.Ссылка = &ФизЛицо
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	РаботникиОрганизацийСрезПоследних.Сотрудник.Код КАК ТабельныйНомер,
	|	РаботникиОрганизацийСрезПоследних.Сотрудник.Физлицо КАК ФизЛицо,
	|	ВЫБОР
	|		КОГДА РаботникиОрганизацийСрезПоследних.ПериодЗавершения <= &ДатаСреза
	|				И РаботникиОрганизацийСрезПоследних.ПериодЗавершения <> ДАТАВРЕМЯ(1, 1, 1, 0, 0, 0)
	|			ТОГДА РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизацииЗавершения
	|		ИНАЧЕ РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизации
	|	КОНЕЦ КАК ПодразделениеОрганизации,
	|	ВЫБОР
	|		КОГДА РаботникиОрганизацийСрезПоследних.ПериодЗавершения <= &ДатаСреза
	|				И РаботникиОрганизацийСрезПоследних.ПериодЗавершения <> ДАТАВРЕМЯ(1, 1, 1, 0, 0, 0)
	|			ТОГДА РаботникиОрганизацийСрезПоследних.ДолжностьЗавершения
	|		ИНАЧЕ РаботникиОрганизацийСрезПоследних.Должность
	|	КОНЕЦ КАК Должность
	|ПОМЕСТИТЬ СведенияПоРаботникамОрганизации
	|ИЗ
	|	РегистрСведений.РаботникиОрганизаций.СрезПоследних(
	|			&ДатаСреза,
	|			Сотрудник.ФизЛицо = &ФизЛицо
	|				И Организация = &Организация) КАК РаботникиОрганизацийСрезПоследних
	|ГДЕ
	|	РаботникиОрганизацийСрезПоследних.ПричинаИзмененияСостояния <> ЗНАЧЕНИЕ(Перечисление.ПричиныИзмененияСостояния.Увольнение)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ФИОФизЛицСрезПоследних.Фамилия,
	|	ФИОФизЛицСрезПоследних.Имя,
	|	ФИОФизЛицСрезПоследних.Отчество,
	|	СведенияПоРаботникамОрганизации.ТабельныйНомер,
	|	СведенияПоРаботникамОрганизации.Должность,
	|	СведенияПоРаботникамОрганизации.ПодразделениеОрганизации,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументВид,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументСерия,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументНомер,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументДатаВыдачи,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументКемВыдан,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументКодПодразделения
	|ИЗ
	|	ФизЛица КАК ФизЛица
	|		
	|		ЛЕВОЕ СОЕДИНЕНИЕ 
	|			РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо = &ФизЛицо) КАК ФИОФизЛицСрезПоследних
	|		ПО 
	|			ФизЛица.ФизЛицо = ФИОФизЛицСрезПоследних.ФизЛицо
	|		
	|		ЛЕВОЕ СОЕДИНЕНИЕ 
	|			РегистрСведений.ПаспортныеДанныеФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо = &ФизЛицо) КАК ПаспортныеДанныеФизЛицСрезПоследних
	|		ПО 
	|			ФизЛица.ФизЛицо = ПаспортныеДанныеФизЛицСрезПоследних.ФизЛицо
	|		
	|		ЛЕВОЕ СОЕДИНЕНИЕ 
	|			СведенияПоРаботникамОрганизации КАК СведенияПоРаботникамОрганизации
	|		ПО 
	|			ФизЛица.ФизЛицо = СведенияПоРаботникамОрганизации.ФизЛицо";*/
			/*Данные = ЗапросПоЛицам.Выполнить().Выбрать();*/
			/*Данные.Следующий();*/
			/*Результат = Новый Структура("Фамилия, Имя, Отчество, Представление, 
								|ТабельныйНомер, Должность, ПодразделениеОрганизации, 
								|ДокументВид, ДокументСерия, ДокументНомер,  
								|ДокументДатаВыдачи, ДокументКемВыдан, ДокументКодПодразделения, 
								|ПредставлениеДокумента");*/
			/*ЗаполнитьЗначенияСвойств(Результат, Данные);*/
			/*Результат.Представление          = ПолучитьФамилиюИмяОтчество(Данные.Фамилия, Данные.Имя, Данные.Отчество, ФИОКратко);*/
			/*Результат.ПредставлениеДокумента = ПолучитьПредставлениеДокументаФизЛица(Данные);*/
			return null;
		}
		// ДанныеФизЛица
		// Функция возвращает совокупность данных о физических лицах в виде таблицы
		// значений. В совокупность данных входит ФИО, должность в заданной
		// организации, паспортные данные и др.
		//
		// Параметры:
		//  Организация  - СправочникСсылка.Организации - организация, по которой
		//                 определяется должность и подразделение работника(ов)
		//  ФизЛицо      - СправочникСсылка.ФизическиеЛица или Массив - физическое лицо
		//                 или список физ. лиц, по которым возвращается совокупность
		//                 данных
		//  ДатаСреза    - Дата - дата, на которую считываются данные
		//
		// Возвращаемое значение:
		//  ТаблицаЗначений - Таблица с совокупностью данных о физическом лице.
		//                  Колонки: возвращаемой таблицы:
		//                  - Фамилия
		//                  - Имя
		//                  - Отчетсво
		//                  - Представление (Фамилия И.О.)
		//                  - Подразделение
		//                  - ДокументВид
		//                  - ДокументСерия
		//                  - ДокументНомер
		//                  - ДокументДатаВыдачи
		//                  - ДокументКемВыдан
		//                  - ДокументКодПодразделения
		//

		public object ДанныеФизЛиц(/*Организация, ФизЛицо, ДатаСреза*/)
		{
			/*ЗапросПоЛицам = Новый Запрос();*/
			/*ЗапросПоЛицам.УстановитьПараметр("ДатаСреза",   ДатаСреза);*/
			/*ЗапросПоЛицам.УстановитьПараметр("Организация", Организация);*/
			/*ЗапросПоЛицам.УстановитьПараметр("ФизЛицо", ФизЛицо);*/
			/*ЗапросПоЛицам.Текст =
	"ВЫБРАТЬ
	|	ФизическиеЛица.Ссылка КАК ФизЛицо
	|ПОМЕСТИТЬ ФизЛица
	|ИЗ
	|	Справочник.ФизическиеЛица КАК ФизическиеЛица
	|ГДЕ
	|	ФизическиеЛица.Ссылка В(&ФизЛицо)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	РаботникиОрганизацийСрезПоследних.Сотрудник.Код КАК ТабельныйНомер,
	|	РаботникиОрганизацийСрезПоследних.Сотрудник.Физлицо КАК ФизЛицо,
	|	ВЫБОР
	|		КОГДА РаботникиОрганизацийСрезПоследних.ПериодЗавершения <= &ДатаСреза
	|				И РаботникиОрганизацийСрезПоследних.ПериодЗавершения <> ДАТАВРЕМЯ(1, 1, 1, 0, 0, 0)
	|			ТОГДА РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизацииЗавершения
	|		ИНАЧЕ РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизации
	|	КОНЕЦ КАК ПодразделениеОрганизации,
	|	ВЫБОР
	|		КОГДА РаботникиОрганизацийСрезПоследних.ПериодЗавершения <= &ДатаСреза
	|				И РаботникиОрганизацийСрезПоследних.ПериодЗавершения <> ДАТАВРЕМЯ(1, 1, 1, 0, 0, 0)
	|			ТОГДА РаботникиОрганизацийСрезПоследних.ДолжностьЗавершения
	|		ИНАЧЕ РаботникиОрганизацийСрезПоследних.Должность
	|	КОНЕЦ КАК Должность
	|ПОМЕСТИТЬ СведенияПоРаботникамОрганизации
	|ИЗ
	|	РегистрСведений.РаботникиОрганизаций.СрезПоследних(
	|			&ДатаСреза,
	|			Сотрудник.ФизЛицо В (&ФизЛицо)
	|				И Организация = &Организация) КАК РаботникиОрганизацийСрезПоследних
	|ГДЕ
	|	РаботникиОрганизацийСрезПоследних.ПричинаИзмененияСостояния <> ЗНАЧЕНИЕ(Перечисление.ПричиныИзмененияСостояния.Увольнение)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ФИОФизЛицСрезПоследних.Фамилия,
	|	ФИОФизЛицСрезПоследних.Имя,
	|	ФИОФизЛицСрезПоследних.Отчество,
	|	СведенияПоРаботникамОрганизации.ТабельныйНомер,
	|	СведенияПоРаботникамОрганизации.Должность,
	|	СведенияПоРаботникамОрганизации.ПодразделениеОрганизации,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументВид,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументСерия,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументНомер,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументДатаВыдачи,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументКемВыдан,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументКодПодразделения
	|ИЗ
	|	ФизЛица КАК ФизЛица
	|		
	|		ЛЕВОЕ СОЕДИНЕНИЕ 
	|			РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо В (&ФизЛицо)) КАК ФИОФизЛицСрезПоследних
	|		ПО 
	|			ФизЛица.ФизЛицо = ФИОФизЛицСрезПоследних.ФизЛицо
	|		
	|		ЛЕВОЕ СОЕДИНЕНИЕ 
	|			РегистрСведений.ПаспортныеДанныеФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо В (&ФизЛицо)) КАК ПаспортныеДанныеФизЛицСрезПоследних
	|		ПО 
	|			ФизЛица.ФизЛицо = ПаспортныеДанныеФизЛицСрезПоследних.ФизЛицо
	|		
	|		ЛЕВОЕ СОЕДИНЕНИЕ 
	|			СведенияПоРаботникамОрганизации КАК СведенияПоРаботникамОрганизации
	|		ПО 
	|			ФизЛица.ФизЛицо = СведенияПоРаботникамОрганизации.ФизЛицо";*/
			/*Данные = ЗапросПоЛицам.Выполнить().Выбрать();*/
			/*ТабРезультат = Новый ТаблицаЗначений();*/
			/*ТабРезультат.Колонки.Добавить("Фамилия");*/
			/*ТабРезультат.Колонки.Добавить("Имя");*/
			/*ТабРезультат.Колонки.Добавить("Отчество");*/
			/*ТабРезультат.Колонки.Добавить("Представление");*/
			/*ТабРезультат.Колонки.Добавить("ТабельныйНомер");*/
			/*ТабРезультат.Колонки.Добавить("Должность");*/
			/*ТабРезультат.Колонки.Добавить("ПодразделениеОрганизации");*/
			/*ТабРезультат.Колонки.Добавить("ДокументВид");*/
			/*ТабРезультат.Колонки.Добавить("ДокументСерия");*/
			/*ТабРезультат.Колонки.Добавить("ДокументНомер");*/
			/*ТабРезультат.Колонки.Добавить("ДокументДатаВыдачи");*/
			/*ТабРезультат.Колонки.Добавить("ДокументКемВыдан");*/
			/*ТабРезультат.Колонки.Добавить("ДокументКодПодразделения");*/
			/*ТабРезультат.Колонки.Добавить("ПредставлениеДокумента");*/
			while(true/*Данные.Следующий()*/)
			{
				/*Результат = ТабРезультат.Добавить();*/
				/*ЗаполнитьЗначенияСвойств(Результат, Данные);*/
				/*Результат.Представление          = ПолучитьФамилиюИмяОтчество(Данные.Фамилия, Данные.Имя, Данные.Отчество);*/
				/*Результат.ПредставлениеДокумента = ПолучитьПредставлениеДокументаФизЛица(Данные);*/
			}
			return null;
		}
		// ДанныеФизЛиц
		// Функция формирует фамилию и инициалы
		//
		// Параметры
		//  Фамилия  - фамилия физ. лица.
		//  Имя      - имя физ. лица.
		//  Отчество - отчество физ. лица.
		//
		// Возвращаемое значение
		//  Фамилия, имя, отчество одной строкой.
		//

		public object ПолучитьФамилиюИмяОтчество(/*Фамилия = " ", Имя = " ", Отчество = " ", ФИОКратко = Истина*/)
		{
			if(true/*ФИОКратко*/)
			{
			}
			return null;
		}
		// ПолучитьФамилиюИмяОтчество()

		public object ПолучитьМассивПрефиксовРИБ(/**/)
		{
			/*МассивПрефиксов = Новый Массив();*/
			/*Запрос = Новый Запрос();*/
			/*Запрос.Текст = "ВЫБРАТЬ Различные
	               |	ПрефиксыИнформационныхБаз.Префикс КАК Префикс
	               |ИЗ
	               |	РегистрСведений.ПрефиксыИнформационныхБаз КАК ПрефиксыИнформационныхБаз";*/
			/*ВыборкаУзлов = Запрос.Выполнить().Выбрать();*/
			while(true/*ВыборкаУзлов.Следующий()*/)
			{
				if(true/*Не ПустаяСтрока(ВыборкаУзлов.Префикс)*/)
				{
					/*МассивПрефиксов.Добавить(ВыборкаУзлов.Префикс);*/
				}
			}
			return null;
		}

		public object СформироватьМассивПрефиксовДляРИБИОрганизации(/*Организация*/)
		{
			/*МассивПрефиксов = ПолучитьМассивПрефиксовРИБ();*/
			if(true/*ЗначениеЗаполнено(Организация)*/)
			{
				/*Префикс = СокрЛП(Организация.Префикс);*/
				if(true/*Префикс <> ""*/)
				{
					/*МассивПрефиксов.Добавить(Префикс);*/
				}
			}
			if(true/*МассивПрефиксов.Количество() = 0*/)
			{
				/*МассивПрефиксов.Добавить("");*/
			}
			return null;
		}
		// Заполнение отбора значениями из таблицы значений.
		// Соответствие полей устанавливается по представлению и типам значений
		//
		// Параметры
		//  Отбор  – Отбор           – Отбор, который требуется заполнить значениями
		//  ТЗ     – ТаблицаЗначений – Таблица содержит значения для отбора.
		//                             Структура колонок повторяет структуру отбора
		//

		public void ЗаполнитьОтборПоТаблицеЗначений(/*Отбор, ТЗ*/)
		{
		}
		// УстановитьОтборИзТаблицы(Отбор, ТЗ)
		// Функция выделяет первое слово в предложении

		public object ВыделитьСлово(/*ИсходнаяСтрока*/)
		{
			/*Буфер = СокрЛ(ИсходнаяСтрока);*/
			/*ПозицияПослПробела = Найти(Буфер, " ");*/
			if(true/*ПозицияПослПробела = 0*/)
			{
				/*ИсходнаяСтрока = "";*/
			}
			/*ВыделенноеСлово = СокрЛП(Лев(Буфер, ПозицияПослПробела));*/
			/*ИсходнаяСтрока = Сред(ИсходнаяСтрока, ПозицияПослПробела + 1);*/
			return null;
		}
		// Функция преобразует строку к множественному числу
		//
		// Параметры:
		//  Слово1 - форма слова в ед числе      ("шкаф")
		//  Слово2 - форма слова для числит 2-4  ("шкафа")
		//  Слово3 - форма слова для числит 5-10 ("шкафов")
		//  ЦелоеЧисло - целое число
		//
		// Возвращаемое значение:
		//  строку - одну из строк в зависимости от параметра ЦелоеЧисло
		//
		// Описание:
		//  Предназначена для формирования "правильной" подписи к числительным
		//

		public object ФормаМножественногоЧисла(/*Слово1, Слово2, Слово3, Знач ЦелоеЧисло*/)
		{
			/*// Изменим знак целого числа, иначе отрицательные числа будут неправильно преобразовываться
*/
			if(true/*ЦелоеЧисло < 0*/)
			{
				/*ЦелоеЧисло = -1 * ЦелоеЧисло;*/
			}
			if(true/*ЦелоеЧисло <> Цел(ЦелоеЧисло)*/)
			{
				/*// для нецелых чисел - всегда вторая форма
*/
			}
			/*// остаток
*/
			/*Остаток = ЦелоеЧисло%10;*/
			if(true/*(ЦелоеЧисло >10) И (ЦелоеЧисло<20)*/)
			{
				/*// для второго десятка - всегда третья форма
*/
			}
			return null;
		}
		// Процедура вычисляет количество лет, месяцев и дней между двумя датами
		//
		// Параметры
		//  Дата1	– дата, первая дата (более поздняя, часто текущая, стаж определяется по состоянию на эту дату)
		//  Дата2	– дата, вторая дата (ранняя дата, с нее начинается "течение" стажа)
		//  Лет		– Число, в этот параметр будет записано кол-во лет между двумя датами (Дата1-Дата2)
		//  Месяцев	– Число, в этот параметр будет записано кол-во месяцев между двумя датами (Дата1-Дата2)
		//  Дней	– Число, в этот параметр будет записано кол-во дней между двумя датами (Дата1-Дата2)
		//

		public void РазобратьРазностьДат(/*Дата1, Дата2, Лет = 0, Месяцев = 0, Дней = 0*/)
		{
			/*Лет		= 0;*/
			/*Месяцев	= 0;*/
			/*Дней	= 0;*/
			if(true/*Дата1 > Дата2*/)
			{
				/*ВременнаяДата = Дата1;*/
				if(true/*День(ВременнаяДата) < День(Дата2)*/)
				{
					/*Дней = (ВременнаяДата - ДобавитьМесяц(ВременнаяДата,-1))/86400;*/
					/*ВременнаяДата = ДобавитьМесяц(ВременнаяДата,-1);*/
				}
				if(true/*Месяц(ВременнаяДата) < Месяц(Дата2)*/)
				{
					/*ВременнаяДата = ДобавитьМесяц(ВременнаяДата,-12);*/
					/*Месяцев = 12;*/
				}
				/*Лет		= Макс(			 Год(ВременнаяДата)		- Год(Дата2),	0);*/
				/*Месяцев	= Макс(Месяцев	+ Месяц(ВременнаяДата)	- Месяц(Дата2),	0);*/
				/*Дней	= Макс(Дней		+ День(ВременнаяДата)	- День(Дата2),	0);*/
				/*// скорректируем отображаемое значение, если "вмешалось" разное количество дней в месяцах
*/
				if(true/*Дата2 <> (ДобавитьМесяц(Дата1,-Лет*12-Месяцев)-Дней*86400)*/)
				{
					/*Дней = Дней + ((ДобавитьМесяц(Дата1,-Лет*12-Месяцев)-Дней*86400) - Дата2)/86400;*/
					/*//(День(КонецМесяца(Дата2)) - День(НачалоМесяца(Дата2))) - (День(КонецМесяца(ДобавитьМесяц(Дата1,-1))) - День(НачалоМесяца(ДобавитьМесяц(Дата1,-1))));
*/
				}
			}
		}
		// РазобратьРазностьДат
		// Функция определяет дату и время начала календарной декады для указанной даты.
		//
		// Параметры:
		//  ТекущаяДата - Исходная дата.
		//
		// Возвращаемое значение:
		//  Дата.
		//

		public object ПолучитьНачалоДекады(/*ИсходнаяДата*/)
		{
			/*ДеньМесяца = День(ИсходнаяДата);*/
			if(true/*ДеньМесяца <= 10*/)
			{
				/*Результат = НачалоМесяца(ИсходнаяДата);*/
			}
			return null;
		}
		// ПолучитьНачалоДекады()
		// Функция определяет дату и время конца календарной декады для указанной даты.
		//
		// Параметры:
		//  ТекущаяДата - Исходная дата.
		//
		// Возвращаемое значение:
		//  Дата.
		//

		public object ПолучитьКонецДекады(/*ИсходнаяДата*/)
		{
			/*ДеньМесяца = День(ИсходнаяДата);*/
			if(true/*ДеньМесяца <= 10*/)
			{
				/*Результат = КонецДня(НачалоМесяца(ИсходнаяДата) + 60 * 60 * 24 * 9);*/
			}
			return null;
		}
		// ПолучитьКонецДекады()
		// Функция определяет дату и время начала полугодия для указанной даты.
		//
		// Параметры:
		//  ТекущаяДата - Исходная дата.
		//
		// Возвращаемое значение:
		//  Дата.
		//

		public object ПолучитьНачалоПолугодия(/*ИсходнаяДата*/)
		{
			if(true/*Месяц(ИсходнаяДата) < 7*/)
			{
				/*Результат = НачалоГода(ИсходнаяДата);*/
			}
			return null;
		}
		// ПолучитьНачалоПолугодия()
		// Функция определяет дату и время конца полугодия для указанной даты.
		//
		// Параметры:
		//  ТекущаяДата - Исходная дата.
		//
		// Возвращаемое значение:
		//  Дата.
		//

		public object ПолучитьКонецПолугодия(/*ИсходнаяДата*/)
		{
			if(true/*Месяц(ИсходнаяДата) < 7*/)
			{
				/*Результат = ДобавитьМесяц(КонецГода(ИсходнаяДата), -6);*/
			}
			return null;
		}
		// ПолучитьКонецПолугодия()
		// функция из исходной строки формирует строку для поиска данных в запросе

		public object СформироватьСтрокуДляПоискаВЗапросе(/*Знач СтрокаПоиска*/)
		{
			/*ИтоговаяСтрокаДляПоиска = СтрокаПоиска;*/
			/*ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "~", "~~");*/
			/*ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "%", "~%");*/
			/*ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "_", "~_");*/
			/*ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "[", "~[");*/
			/*ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "-", "~-");*/
			return null;
		}
		// Функция формирует представление заголовка документа
		//
		// Возвращаемое значение:
		//  Строка - представление номера документа
		//

		public object СформироватьЗаголовокДокумента(/*ДокументОбъект, НазваниеДокумента = ""*/)
		{
			if(true/*ДокументОбъект = Неопределено*/)
			{
			}
			return null;
		}
		// СформироватьЗаголовокДокумента()
		// Функция формирует представление суммы прописью в указанной валюте
		//
		// Возвращаемое значение:
		//  Строка - сумма прописью
		//

		public object СформироватьСуммуПрописью(/*Сумма, Валюта*/)
		{
			if(true/*Валюта.ПараметрыПрописиНаРусском = ""*/)
			{
			}
			return null;
		}
		// СформироватьСуммуПрописью()

		public void ДобавитьПрефиксОрганизации(/*ДокументОбъект, Префикс*/)
		{
			/*// Если в документе нет реквизита "Организация" или для организации не задан префикс,
*/
			/*// то используем пустой префикс, иначе используем префикс организации.
*/
			/*Префикс = "0";*/
			if(true/*ДокументОбъект.Метаданные().Реквизиты.Найти("Организация") <> Неопределено*/)
			{
				/*ПрефиксОрганизации = ПолучитьЗначениеРеквизита(ДокументОбъект.Организация, "Префикс");*/
				if(true/*ЗначениеЗаполнено(ПрефиксОрганизации)*/)
				{
					/*Префикс = ПрефиксОрганизации;*/
				}
			}
		}
		// процедура формирования номера документа

		public void ПриУстановкеНовогоНомераДляДокументов(/*Источник, СтандартнаяОбработка, Префикс*/)
		{
			/*ДобавитьПрефиксОрганизации(Источник, Префикс);*/
			/*ДобавитьПрефиксУзла(Префикс);*/
		}
		//Процедура выполняет удаление движений документа по регистрам при отмене проведения
		//	Является обработчиком подписки на событие "ОбработкаУдаленияПроведенияДокумента"
		//

		public void ОбработкаУдаленияПроведенияДокумента(/*Источник, Отказ*/)
		{
			/*УдалитьДвиженияРегистратора(Источник, Отказ);*/
			if(true/*Источник.ДополнительныеСвойства.Свойство("ТаблицаСтаройРегистрацииВПоследовательности")
	  И Источник.ДополнительныеСвойства.ТаблицаСтаройРегистрацииВПоследовательности.Количество() > 0*/)
			{
				/*УправлениеЗапасамиПартионныйУчет.СдвинутьГраницуПоследовательностиНазад(Источник.Дата, Источник.Ссылка, Источник.ДополнительныеСвойства.ТаблицаСтаройРегистрацииВПоследовательности);*/
			}
		}

		public void ПриУстановкеНовогоКодаДляСправочникаИлиПВХ(/*Источник, СтандартнаяОбработка, Префикс*/)
		{
			/*ДобавитьПрефиксУзла(Префикс);*/
		}
		// Проверяет дату на заполненность по аналогии с системной функцией "ПустаяСтрока".
		//

		public object ПустаяДата(/*ПроверяемаяДата*/)
		{
			if(true/*ТипЗнч(ПроверяемаяДата) = Тип("Дата") 
	   И ПроверяемаяДата = Дата(1,1,1)*/)
			{
			}
			return null;
		}
		// ПустаяДата()
		// Функция возвращает массив вышестоящих групп указанного элемента.
		//
		// Переметры:
		//  Элемент      - Элемент справочника, для которого ищется родитель
		//
		// Возвращаемое значение
		//  Массив вышестояших групп
		//

		public object ПолучитьСписокВышеСтоящихГрупп(/*ЭлементСправочника*/)
		{
			/*Результат = Новый Массив;*/
			if(true/*НЕ ЗначениеЗаполнено(ЭлементСправочника)*/)
			{
			}
			/*МетаданныеСправочника = ЭлементСправочника.Метаданные();*/
			if(true/*НЕ МетаданныеСправочника.Иерархический*/)
			{
			}
			/*ИмяСправочника = МетаданныеСправочника.Имя;*/
			/*Запрос = Новый Запрос;*/
			/*Запрос.Текст = "
	|ВЫБРАТЬ
	|	Справочник1.Родитель КАК Родитель1,
	|	Справочник2.Родитель КАК Родитель2,
	|	Справочник3.Родитель КАК Родитель3,
	|	Справочник4.Родитель КАК Родитель4,
	|	Справочник5.Родитель КАК Родитель5
	|ИЗ
	|	Справочник." + ИмяСправочника + " КАК Справочник1
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник2
	|		ПО (Справочник2.Ссылка = Справочник1.Родитель)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник3
	|		ПО (Справочник3.Ссылка = Справочник2.Родитель)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник4
	|		ПО (Справочник4.Ссылка = Справочник3.Родитель)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник5
	|		ПО (Справочник5.Ссылка = Справочник4.Родитель)
	|ГДЕ
	|	Справочник1.Ссылка = &Ссылка";*/
			/*ТекущийЭлемент = ЭлементСправочника;*/
			while(true/*ЗначениеЗаполнено(ТекущийЭлемент)*/)
			{
				/*Запрос.УстановитьПараметр("Ссылка", ТекущийЭлемент);*/
				/*Выборка = Запрос.Выполнить().Выбрать();*/
				if(true/*Выборка.Следующий()*/)
				{
				}
			}
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ ЗАПИСИ НАБОРОВ ЗАПИСЕЙ РЕГИСТРОВ, КОНСТАНТ
		// Проверяет значения констант из коллекции с текущим значением в ИБ,
		// не проверяется для типа данных ХранилищеЗначений
		//
		// Параметры:
		//  КоллекцияКонстантДляПроверки  - структура
		//									ключ 		- строка, имя константы
		//									значение 	- значение константы
		//
		// Возвращаемое значение:
		//  Массив констант значение которых изменилось по сравнению с переданной коллекцией
		//

		public object СоздатьМассивИзмененныхКонстант(/*КоллекцияКонстантДляПроверки*/)
		{
			/*МассивИзмененныхКонстант = Новый Массив;*/
			return null;
		}
		// Функция выполняет запись переданного набора записей и
		// формирует сообщение об ошибке, если не удалось записать набор
		//
		// Параметры
		//  НаборЗаписей  - набор записей регистра сведений, который необходимо записать
		//
		// Возвращаемое значение:
		//   Булево   - Истина, когда набор записей записан
		//

		public object ЗаписатьНабор(/*НаборЗаписей*/)
		{
			/*Попытка
		НаборЗаписей.Записать();*/
			/*Исключение
		ВывестиИнформациюОбОшибке(ПолучитьПричинуОшибки(ИнформацияОбОшибке()).Описание);*/
			/*КонецПопытки;*/
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕХАНИЗМОМ НАСТРОЙКИ ПОРЯДКА ЭЛЕМЕНТОВ СПРАВОЧНИКА
		// Вспомогательная функция для определнения условий запроса в механизме
		// изменения порядка следования элементов. Ставит условия на родителя и владельца
		//
		// Параметры
		//  Элемент - СправочникСсылка, для которого необходимо изменить порядок
		//  Запрос - Запрос, в который дописываем условия
		//
		//  Возвращаемое значение:
		//   Строка - условие запроса
		//

		public object ПолучитьДополнениеЗапроса(/*Элемент, Запрос, БезПервогоИ = Ложь*/)
		{
			/*ТекстЗапроса = "";*/
			if(true/*Элемент.Метаданные().Иерархический = Истина*/)
			{
				/*Запрос.УстановитьПараметр("ТекущийРодитель", Элемент.Родитель);*/
				if(true/*НЕ БезПервогоИ*/)
				{
					/*ТекстЗапроса = ТекстЗапроса + "
			|	И
			|";*/
				}
				/*ТекстЗапроса = ТекстЗапроса + "
		|	СправочникПорядка.Родитель = &ТекущийРодитель
		|";*/
			}
			if(true/*Элемент.Метаданные().Владельцы.Количество() > 0*/)
			{
				/*Запрос.УстановитьПараметр("ТекущийВладелец", Элемент.Владелец);*/
				if(true/*НЕ (ПустаяСтрока(ТекстЗапроса) И БезПервогоИ)*/)
				{
					/*ТекстЗапроса = ТекстЗапроса + "
			|	И
			|";*/
				}
				/*ТекстЗапроса = ТекстЗапроса + "
		|	СправочникПорядка.Владелец = &ТекущийВладелец
		|";*/
			}
			return null;
		}
		// Возвращает значение порядка для нового элемента справочника.
		//
		// Параметры
		//  ЭлементОбъект - СправочникОбъект - новый объект
		//
		// Возвращаемое значение:
		//   Число - новый порядок
		//

		public object НазначитьНовыйПорядок(/*ЭлементОбъект*/)
		{
			/*ИмяТаблицы = ЭлементОбъект.Метаданные().Имя;*/
			/*Запрос = Новый Запрос;*/
			/*Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	|	СправочникПорядка.Порядок
	|ИЗ
	|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка";*/
			/*ДополнениеЗапроса = ПолучитьДополнениеЗапроса(ЭлементОбъект, Запрос, Истина);*/
			if(true/*НЕ ПустаяСтрока(ДополнениеЗапроса)*/)
			{
				/*Запрос.Текст = Запрос.Текст + "
		|ГДЕ
		|" + ДополнениеЗапроса + "
		|";*/
			}
			/*Запрос.Текст = Запрос.Текст + "
	|УПОРЯДОЧИТЬ ПО
	|	СправочникПорядка.Порядок УБЫВ
	|";*/
			/*РезультатЗапроса = Запрос.Выполнить();*/
			if(true/*РезультатЗапроса.Пустой()*/)
			{
			}
			return null;
		}
		// Процедура вызывается перед записью объекта, для которого необходимо
		// контролировать порядок элементов.
		//
		// Параметры
		//  Отказ - Булево, отказ от записи объекта
		//  ЭтотОбъект - СправочникОбъект
		//  КонтролироватьПорядок - Булево, контролировать порядок при записи объекта или нет
		//

		public void ПередЗаписьюОбъектаПорядка(/*Отказ, ЭтотОбъект, КонтролироватьПорядок*/)
		{
			if(true/*ЭтотОбъект.ЭтоНовый()*/)
			{
				/*ЭтотОбъект.Порядок = НазначитьНовыйПорядок(ЭтотОбъект);*/
			}
			if(true/*КонтролироватьПорядок*/)
			{
				/*ИмяТаблицы = ЭтотОбъект.Метаданные().Имя;*/
				/*Запрос = Новый Запрос;*/
				/*Запрос.УстановитьПараметр("ТекущийПорядок", ЭтотОбъект.Порядок);*/
				/*Запрос.Текст = "
		|ВЫБРАТЬ ПЕРВЫЕ 1
		|	СправочникПорядка.Порядок
		|ИЗ
		|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
		|ГДЕ
		|	СправочникПорядка.Порядок = &ТекущийПорядок
		|";*/
				if(true/*НЕ ЭтотОбъект.ЭтоНовый()*/)
				{
					/*Запрос.УстановитьПараметр("ТекущаяСсылка", ЭтотОбъект.Ссылка);*/
					/*Запрос.Текст = Запрос.Текст + "
			|И
			|	СправочникПорядка.Ссылка <> &ТекущаяСсылка
			|";*/
				}
				/*Запрос.Текст = Запрос.Текст + ПолучитьДополнениеЗапроса(ЭтотОбъект, Запрос);*/
				if(true/*НЕ Запрос.Выполнить().Пустой()*/)
				{
					/*Отказ = Истина;*/
					/*#Если Клиент Тогда
				Сообщить("Не уникальный порядок элемента справочника.");*/
					/*#КонецЕсли;*/
				}
			}
		}
		// Процедура изменяет порядок следования объектов с настраиваемым из ВЯ
		// порядком следования.
		//
		// Параметры:
		//  ЭлементСсылка - СправочникСсылка, элемент для которого необходимо изменить порядок
		//  НаправлениеПорядка - Строка, "Вверх" или "Вниз"
		//

		public void ИзменитьПорядок(/*ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг = Истина*/)
		{
			/*ЭлементЗамены = ОпределитьНовыйПорядок(ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг);*/
			if(true/*ЭлементЗамены = Неопределено*/)
			{
			}
			/*НовыйПорядокЗамены   = ЭлементЗамены.Порядок;*/
			/*НовыйПорядокЭлемента = ЭлементСсылка.Порядок;*/
			if(true/*НаправлениеПорядка = "Вверх"*/)
			{
				if(true/*НовыйПорядокЗамены < НовыйПорядокЭлемента*/)
				{
					/*ПромежуточныйПорядок = НовыйПорядокЗамены;*/
					/*НовыйПорядокЗамены   = НовыйПорядокЭлемента;*/
					/*НовыйПорядокЭлемента = ПромежуточныйПорядок;*/
				}
			}
			/*НачатьТранзакцию();*/
			/*ФиксироватьТранзакцию = Истина;*/
			if(true/*НовыйПорядокЗамены <> ЭлементЗамены.Порядок*/)
			{
				/*ОбъектЗамены = ЭлементЗамены.ПолучитьОбъект();*/
				/*ОбъектЗамены.Порядок = НовыйПорядокЗамены;*/
				/*ОбъектЗамены.КонтролироватьПорядок = Ложь;*/
				/*Попытка
			ОбъектЗамены.Записать();*/
				/*Исключение
			СообщитьОбОшибке(ОписаниеОшибки());*/
				/*ФиксироватьТранзакцию = Ложь;*/
				/*КонецПопытки;*/
			}
			if(true/*ФиксироватьТранзакцию*/)
			{
				/*ОбъектЭлемента = ЭлементСсылка.ПолучитьОбъект();*/
				/*ОбъектЭлемента.Порядок = НовыйПорядокЭлемента;*/
				/*Попытка
			ОбъектЭлемента.Записать();*/
				/*Исключение
			СообщитьОбОшибке(ОписаниеОшибки());*/
				/*ФиксироватьТранзакцию = Ложь;*/
				/*КонецПопытки;*/
			}
			if(true/*ФиксироватьТранзакцию*/)
			{
				/*ЗафиксироватьТранзакцию();*/
			}
		}
		// Функция определяет элемент справочника, с которым необходимо
		// произвести "рокировку" текущего элемента
		//
		// Параметры
		//  ЭлементСсылка - СпраовочникСсылка, элемент для изменения порядка
		//  НаправлениеПорядка - Строка, "Вверх" или "Вниз"
		//
		// Возвращаемое значение:
		//   СправочникСсылка
		//

		public object ОпределитьНовыйПорядок(/*ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг*/)
		{
			/*ТекущийПорядок = ЭлементСсылка.Порядок;*/
			/*ИмяТаблицы = ЭлементСсылка.Метаданные().Имя;*/
			/*Запрос = Новый Запрос;*/
			/*Запрос.УстановитьПараметр("ТекущийПорядок", ТекущийПорядок);*/
			/*Запрос.Текст = "
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	СправочникПорядка.Ссылка
	|ИЗ
	|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
	|ГДЕ
	|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "<", ">") + " &ТекущийПорядок " + ПолучитьДополнениеЗапроса(ЭлементСсылка, Запрос) + "
	|УПОРЯДОЧИТЬ ПО
	|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "УБЫВ", "ВОЗР") + "
	|";*/
			/*РезультатЗапроса = Запрос.Выполнить();*/
			if(true/*НЕ РезультатЗапроса.Пустой()*/)
			{
				/*Выборка = РезультатЗапроса.Выбрать();*/
				/*Выборка.Следующий();*/
			}
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ ПРОВЕРКИ НАЛИЧИЯ И ЗАПОЛНЕНИЯ РЕВИЗИТОВ
		// Предназначена для получения пустого значения заданного типа:
		//	примитивного, или ссылочного. Используется
		//
		// Параметры:
		//	ЗаданныйТип   - тип, пустое значение которого нужно получить
		//

		public object ПустоеЗначениеТипа(/*ЗаданныйТип*/)
		{
			if(true/*ЗаданныйТип = Тип("Число")*/)
			{
			}
			return null;
		}
		// ПустоеЗначениеТипа();
		//Предназначена для получения массива пустых значений, содержащих значение Неопределено и значения переданного типа или описания типов

		public object МассивПустыхЗначений(/*ОписаниеТипов*/)
		{
			/*МассивЗначений = новый Массив;*/
			/*МассивЗначений.Добавить(неопределено);*/
			if(true/*ТипЗнч(ОписаниеТипов)=Тип("ОписаниеТипов")*/)
			{
			}
			return null;
		}
		// Позволяет определить есть ли среди реквизитов табличной части документа
		// реквизит с переданным именем.
		//
		// Параметры:
		//  ИмяРеквизита - строковое имя искомого реквизита,
		//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
		//  ИмяТабЧасти  - строковое имя табличной части документа, среди реквизитов которого производится поиск
		//
		// Возвращаемое значение:
		//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
		//

		public object ЕстьРеквизитТабЧастиДокумента(/*ИмяРеквизита, МетаданныеДокумента, ИмяТабЧасти*/)
		{
			/*ТабЧасть = МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабЧасти);*/
			/*// есть таб. часть в документе
*/
			return null;
		}
		// ЕстьРеквизитТабЧастиДокумента()
		// Функция проверяет наличие в строке только цифр
		//
		// Параметры
		//  СтрокаПроверки - Строка для проверки только цифр
		//
		// Возвращаемое значение:
		//   Булево
		//

		public object ЕстьНеЦифры(/*Знач СтрокаПроверки*/)
		{
			/*СписокКодовЧисел = Новый СписокЗначений;*/
			/*СтрокаПроверки = СокрЛП(СтрокаПроверки);*/
			if(true/*ТипЗнч(СтрокаПроверки) <> Тип("Строка")*/)
			{
			}
			return null;
		}
		// Если в шапке переданного документа есть реквизит с указанным именем, то возвращается его значение.
		// Если такого реквизита нет - возвращается Неопределено.
		//
		// Параметры:
		//  ИмяРеквизита - Строка. Имя искомого реквизита.
		//  ДокументОбъект - объект переданного документа.
		//  МетаданныеДокумента - Метаданные переданного документа.
		//  ПустоеЗначение - значение, которое должно вернуться, если в шапке нет такого реквизита,
		//  если не передано, то возвращается значение Неопределено.
		//
		// Возвращаемое значение:
		//  Значение реквизита - значение найденного реквизита или ПустоеЗначение.
		//

		public object ПолучитьРеквизитШапки(/*ИмяРеквизита, ДокументОбъект, МетаданныеДокумента, ПустоеЗначение = Неопределено*/)
		{
			/*ЗначениеРеквизита = ?(МетаданныеДокумента.Реквизиты.Найти(ИмяРеквизита) <> Неопределено,
	                      ДокументОбъект[ИмяРеквизита], ПустоеЗначение);*/
			return null;
		}
		// ПолучитьРеквизитШапки()
		///////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ ЗАГРУЗКИ КЛАССИФИКАТОРОВ

		public void ЗагрузитьКлассификаторИзXML(/*ПустойЭлементСправочника, ИмяФайлаПоУмолчанию*/)
		{
			/*ФормаЗагрузки = ПолучитьОбщуюФорму("ФормаЗагрузкиКлассификатораИзXML");*/
			/*ФормаЗагрузки.ПустойЭлементСправочника = ПустойЭлементСправочника;*/
			/*ФормаЗагрузки.ИмяФайлаПоУмолчанию = ИмяФайлаПоУмолчанию;*/
			/*ФормаЗагрузки.Открыть();*/
		}
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕХАНИЗМОМ ОТПРАВКИ СООБЩЕНИЙ В ОТДЕЛ ТЕХНИЧЕСКОЙ ПОДДЕРЖКИ ПОЛЬЗОВАТЕЛЕЙ
		// Функнция проверяет заполнения обязательных параметров для отправки сообщения
		//  в отдел технической поддержки.
		//
		// Параметры
		//  ТаблицаДанных - Таблица значений
		//
		// Возвращаемое значение:
		//   Булево - результат корректости проверки
		//

		public object ПроверитьСтруктуруЗаполненияПараметровДляОтправкиСообщенияВОтделТехническойПоддержки(/*ТаблицаДанных, ПубликоватьСообщения = Истина*/)
		{
			/*ЗначениеПроверки = Истина;*/
			/*СтрокаЗаголовкаОшибки = "Не заполнены настройки для отправки сообщения.";*/
			/*СписокИменОбязательныхРеквизитов = Новый СписокЗначений;*/
			/*СписокИменОбязательныхРеквизитов.Добавить("ПараметрыОтправкиЭлектронногоСообщения_АдресЭлектроннойПочтыОтделаТехническойПоддержки");*/
			/*СписокИменОбязательныхРеквизитов.Добавить("ОсновныеДанные_РегистрационныйНомерПрограммы");*/
			/*СписокИменОбязательныхРеквизитов.Добавить("Владелец_Организация");*/
			return null;
		}
		// ПроверитьСтруктуруЗаполненияПараметровДляОтправкиСообщенияВОтделТехническойПоддержки()
		// Процедура формирует таблицу значений со структурой для заполнения данными
		// с информацией обращения в отдел технической поддержки
		//
		// Параметры:
		//  ТаблицаДанных - таблица значений для заполнения
		//  ФормаНастройкиПараметров - общая форма настройки параметров для отправки в отдел технической поддержки
		//

		public void ЗаполнитьСтруктуруДанныхНастройкиОбращенияВОтделТехподдержкиПоУмолчанию(/*ТаблицаДанных, ФормаНастройкиПараметров = Неопределено*/)
		{
			/*// Структура данных - таблица значений:
*/
			/*//  Колонки:
*/
			/*//   ИмяРездела
*/
			/*//   ПредставлениеРаздела
*/
			/*//   ДанныеРаздела
*/
			/*// Структура данных раздела
*/
			/*//  Ключ - Имя значения настройки, как оно задано в форме настройки параметров обращения
*/
			/*//  Значение - Массив значений
*/
			/*// 
*/
			/*// Массив значений:
*/
			/*//  [0] - Представление наименования параметра для печати
*/
			/*//  [1] - Значение параметра
*/
			if(true/*ТипЗнч(ТаблицаДанных) <> Тип("ТаблицаЗначений")*/)
			{
				/*ТаблицаДанных = Новый ТаблицаЗначений;*/
			}
			if(true/*ТаблицаДанных.Колонки.Количество() = 0*/)
			{
				/*ТаблицаДанных.Колонки.Добавить("ИндексСортировки"    , Новый ОписаниеТипов("Число"));*/
				/*ТаблицаДанных.Колонки.Добавить("ИмяРаздела"          , Новый ОписаниеТипов("Строка"));*/
				/*ТаблицаДанных.Колонки.Добавить("ПредставлениеРаздела", Новый ОписаниеТипов("Строка"));*/
				/*ТаблицаДанных.Колонки.Добавить("ДанныеРаздела"       , Новый ОписаниеТипов("Структура"));*/
			}
			/*ТаблицаДанных.Индексы.Добавить("ИмяРаздела");*/
			if(true/*ФормаНастройкиПараметров = Неопределено*/)
			{
				/*ФормаНастройкиПараметров = ПолучитьОбщуюФорму("НастройкаПараметровОбращенияВОтделТехническойПоддержки");*/
			}
			/*ТаблицаДанных.Сортировать("ИндексСортировки ВОЗР");*/
		}
		// Функция формирует текст сообщения на линию техподдержки
		//
		// Параметры
		//  НЕТ
		//
		// Возвращаемое значение:
		//   Текст сообщения
		//

		public object ПолучитьТекстСообщенияВОтделТехническойПоддержки(/**/)
		{
			/*ТекстВозврата = "";*/
			/*ТекстВозврата = ТекстВозврата + Символы.ПС;*/
			/*ТекстВозврата = ТекстВозврата + Символы.ПС;*/
			/*ТекстВозврата = ТекстВозврата + Символы.ПС + "============ Сведения об использовании ПП 1С:Предприятие 8 ============";*/
			/*ТаблицаДанных = Константы.ПараметрыСообщенияПриОбращенииВОтделТехническойПоддержки.Получить().Получить();*/
			/*// Сформируем обязательный информационный раздел
*/
			/*СистемИнфо = Новый СистемнаяИнформация;*/
			/*ТекстВозврата = ТекстВозврата + Символы.ПС;*/
			/*ТекстВозврата = ТекстВозврата + Символы.ПС + "1. ДАННЫЕ ТЕКУЩЕГО КОМПЬЮТЕРА И КОНФИГУРАЦИИ";*/
			/*ТекстВозврата = ТекстВозврата + Символы.ПС + "Версия 1С:Предприятия 8: "   + СистемИнфо.ВерсияПриложения;*/
			/*ТекстВозврата = ТекстВозврата + Символы.ПС + "Конфигурация: "              + Метаданные.Синоним;*/
			/*ТекстВозврата = ТекстВозврата + Символы.ПС + "Версия конфигурации: "       + Метаданные.Версия;*/
			/*ТекстВозврата = ТекстВозврата + Символы.ПС + "Поставщик: "                 + Метаданные.Поставщик;*/
			/*ТекстВозврата = ТекстВозврата + Символы.ПС + "Операционная система: "      + СистемИнфо.ВерсияОС;*/
			/*ТекстВозврата = ТекстВозврата + Символы.ПС + "Оперативная память (МБ): "   + СистемИнфо.ОперативнаяПамять;*/
			/*ТекстВозврата = ТекстВозврата + Символы.ПС + "Процессор: "                 + СистемИнфо.Процессор;*/
			/*НомерСтрокиРаздела = 1;*/
			if(true/*ТипЗнч(ТаблицаДанных) = Тип("ТаблицаЗначений")*/)
			{
			}
			return null;
		}
		// ПолучитьТекстСообщенияВОтделТехническойПоддержки()
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ТИПАМИ
		// Служебная функция, предназначенная для получения описания типов строки, заданной длины.
		//
		// Параметры:
		//  ДлинаСтроки - число, длина строки.
		//
		// Возвращаемое значение:
		//  Объект "ОписаниеТипов" для строки указанной длины.
		//

		public object ПолучитьОписаниеТиповСтроки(/*ДлинаСтроки*/)
		{
			return null;
		}
		// ПолучитьОписаниеТиповСтроки()
		// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
		//
		// Параметры:
		//  Разрядность 			- число, разряд числа.
		//  РазрядностьДробнойЧасти - число, разряд дробной части.
		//
		// Возвращаемое значение:
		//  Объект "ОписаниеТипов" для числа указанной разрядности.
		//

		public object ПолучитьОписаниеТиповЧисла(/*Разрядность, РазрядностьДробнойЧасти = 0, ЗнакЧисла = Неопределено*/)
		{
			if(true/*ЗнакЧисла = Неопределено*/)
			{
				/*КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти);*/
			}
			return null;
		}
		// ПолучитьОписаниеТиповЧисла()
		// Служебная функция, предназначенная для получения описания типов даты
		//
		// Параметры:
		//  ЧастиДаты - системное перечисление ЧастиДаты.
		//

		public object ПолучитьОписаниеТиповДаты(/*ЧастиДаты*/)
		{
			return null;
		}
		// ПолучитьОписаниеТиповДаты()
		//функция выполняет приведение строки к числу
		// Параметры:
		//  ЧислоСтрокой           - Строка - Строка приводимая к числу
		//  ВозвращатьНеопределено - Булево - Если Истина и строка содержит некорректное значение, то возвращать Неопределено
		//
		// Возвращаемое значение:
		//  Число
		//

		public object ПривестиСтрокуКЧислу(/*ЧислоСтрокой, ВозвращатьНеопределено = Ложь*/)
		{
			/*ОписаниеТипаЧисла = Новый ОписаниеТипов("Число");*/
			/*ЗначениеЧисла = ОписаниеТипаЧисла.ПривестиЗначение(ЧислоСтрокой);*/
			if(true/*ВозвращатьНеопределено И (ЗначениеЧисла = 0)*/)
			{
				/*Стр = Строка(ЧислоСтрокой);*/
				if(true/*Стр = ""*/)
				{
				}
				/*Стр = СтрЗаменить(СокрЛП(Стр), "0", "");*/
				if(true/*(Стр <> "") И (Стр <> ".") И (Стр <> ",")*/)
				{
				}
			}
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ СО СВОЙСТВАМИ И КАТЕГОРИЯМИ ОБЪЕКТОВ
		//Функция возвращает список доступных назначений для "Свойств и категорий объектов"
		//по переданной ссылке
		// Параметры:
		//	Ссылка - Ссылка на справочник или документ
		//
		// Возвращаемое значение:
		// Список значений: доступные назначения для свойств и категорий

		public object ПолучитьСписокНазначенийСвойствКатегорийОбъектовПоСсылке(/*Ссылка*/)
		{
			/*Результат = Новый СписокЗначений;*/
			if(true/*Ссылка = Неопределено*/)
			{
			}
			/*ТипСсылки = ТипЗнч(Ссылка);*/
			/*ЭтоХарактеристика = (ТипСсылки = Тип("СправочникСсылка.ХарактеристикиНоменклатуры"));*/
			/*Запрос = Новый Запрос;*/
			/*Запрос.УстановитьПараметр("НазначениеХарактеристика", ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_ХарактеристикиНоменклатуры);*/
			/*ТекстЗапроса = "
	|ВЫБРАТЬ
	|	Назначения.Ссылка КАК Ссылка,
	|	Назначения.ТипЗначения КАК ТипЗначения
	|ИЗ
	|	ПланВидовХарактеристик.НазначенияСвойствКатегорийОбъектов КАК Назначения
	|ГДЕ
	|	НЕ Назначения.ЭтоГруппа
	|";*/
			if(true/*ЭтоХарактеристика*/)
			{
				/*ТекстЗапроса = ТекстЗапроса + "
		|	И Назначения.Ссылка = &НазначениеХарактеристика
		|";*/
			}
			/*Запрос.Текст = ТекстЗапроса;*/
			/*Выборка = Запрос.Выполнить().Выбрать();*/
			while(true/*Выборка.Следующий()*/)
			{
				if(true/*ЭтоХарактеристика Или Выборка.ТипЗначения.СодержитТип(ТипСсылки)*/)
				{
					/*Результат.Добавить(Выборка.Ссылка);*/
				}
			}
			return null;
		}
		// ПолучитьСписокНазначенийСвойствКатегорийОбъектовПоСсылке()
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МАССИВАМИ
		// функция ищет элемент в массиве. Если находит - возвращает его индекс, иначе -1

		public object ВернутьИндексВМассиве(/*МассивДанные, Элемент*/)
		{
			if(true/*МассивДанные = Неопределено*/)
			{
			}
			/*// не нашли элемент
*/
			return null;
		}
		// Удаление из массива пустых элементов
		//
		// Параметры:
		//   МассивЭлементов - Массив
		//

		public void УдалитьНеЗаполненныеЭлементыМассива(/*МассивЭлементов*/)
		{
			/*Колво = МассивЭлементов.Количество();*/
		}
		////////////////////////////////////////////////////////////////////////////////
		//  ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УНИВЕРСАЛЬНЫМИ КОЛЛЕКЦИЯМИ ЗНАЧЕНИЙ
		// Создает копию переданного массива, структуры или соответствия
		//
		// Параметры:
		//  КоллекцияИсходная: тип Массив, Структура, Соответствие - исходная коллекция
		// Возвращаемое значение:
		//  КоллекцияКопия:  тип Массив, Структура, Соответствие - копия исходной коллекции
		//

		public object СкопироватьУниверсальнуюКоллекцию(/*КоллекцияИсходная*/)
		{
			if(true/*ТипЗнч(КоллекцияИсходная)=Тип("Массив")*/)
			{
				/*КоллекцияКопия=Новый Массив;*/
			}
			return null;
		}
		// СкопироватьУниверсальнуюКоллекцию()
		// Разворачивает таблицу  значений по вложенной таблице
		//
		// Параметры
		//  ТаблицаЗначений  – <ТаблицаЗначений> – базовая таблица
		//  КолонкаВложеннойТаблицы  – <Строка> – Наименование колонки влолженной таблицы
		//  СписокРаспределяемыхКолонок  – <Структура> – Структура с именами колонок базовой таблицы, значения которых будут распределяться по колонке вложенной таблицы
		//         						Ключ - Имя колонки базовой таблицы
		//         						Значение - Имя колонки вложенной таблицы. Если во вложенной таблице колонка не обнаружена - обработка прекращается.
		// Возвращаемое значение:
		//   <ТаблицаЗначений>   – таблица значений, развернутая по значениям вложенной таблицы.
		//
		// При совпадении имен базовой и вложенной таблиц - если

		public object РазвернутьПоВложеннойТаблице(/*ТаблицаЗначений, КолонкаВложеннойТаблицы,СписокРаспределяемыхКолонок, СписокИсключаемыхКолонок, СообщатьОбОшибке = Истина*/)
		{
			if(true/*ТаблицаЗначений.Количество()=0*/)
			{
				/*// Таблица не заполнена, софрмировать новую таблицу не представляется возможнным
*/
				/*// Отсуттствует вложенная таблица, структуру данных выходной таблицы сформировать невозможно
*/
				if(true/*СообщатьОбОшибке*/)
				{
					/*СообщитьОбОшибке("Отсутствуют строки в базовой таблице, распределение по вложенной таблице невозможно.",,,СтатусСообщения.Внимание);*/
				}
			}
			/*КолонкиВложеннойТаблицы = ТаблицаЗначений[0][КолонкаВложеннойТаблицы].Колонки;*/
			/*//Заполним значения по тем колонкам, по которым не были заполены значения ранее
*/
			/*НоваяТаблицаЗначений = Новый ТаблицаЗначений();*/
			/*// Для каждого СтрокаБазовойТаблицы Из ТаблицаЗначений Цикл 
*/
			/*// Распределение базовых данных по распределяемым колонкам
*/
			/*НоваяТаблицаЗначений = СформироватьКорректирующиеЗаписи(ТаблицаЗначений,НоваяТаблицаЗначений,СписокРаспределяемыхКолонок);*/
			return null;
		}
		// РазвернутьПоВложеннойТаблице()
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ ВЫВОДА СООБЩЕНИЙ

		public object ОпределитьВажностьСобытияЖурналаРегистрации(/*Статус*/)
		{
			/*ВидСобытия = УровеньЖурналаРегистрации.Информация;*/
			if(true/*Статус = СтатусСообщения.Внимание*/)
			{
				/*ВидСобытия = УровеньЖурналаРегистрации.Предупреждение;*/
			}
			return null;
		}
		//Процедура проверяет необходимость вывода сообщения в журнал регистрации, при необходимости выводит сообщение в журнал регистрации
		// Параметры:
		//	ТекстСообщения - Строка - Текст сообщения
		//	Статус - ПеречислениеСсылка.ВидыСообщений - Вид сообщения
		//		   - СтатусСообщения - Статус сообщения (используется для совместимости со старыми вызовами процедуры Сообщить)
		//	Заголовок - Строка - Текст заголовка
		//

		public void ДублироватьСообщениеВЖурналРегистрации(/*ТекстСообщения, Статус, Заголовок=""*/)
		{
			/*//Если сообщение выводится во внешнем соединении, оно всегда должно быть выведено в журнал регистрации (независимо от настроек)
*/
			/*//Это необходимо для того, чтобы в ЖР были видны сообщения при автоматическом обновлении
*/
			/*#Если НЕ ВнешнееСоединение Тогда
	ДублироватьСообщенияВЖурналРегистрации = глЗначениеПеременной("ДублироватьСообщенияВЖурналРегистрации");*/
			if(true/*НЕ ДублироватьСообщенияВЖурналРегистрации*/)
			{
			}
			/*#КонецЕсли
	Важность = ОпределитьВажностьСобытияЖурналаРегистрации(Статус);*/
			if(true/*Заголовок <> ""*/)
			{
				/*//вывод заголовка как отдельной записи в журнал
*/
				/*ЗаписьЖурналаРегистрации("Сообщение", УровеньЖурналаРегистрации.Примечание, , ,Заголовок);*/
			}
			/*ЗаписьЖурналаРегистрации("Сообщение", Важность, , ,ТекстСообщения);*/
		}
		// Процедура выводит пользователю сообщение: в журнал регистрации, в панель комментариев, в окно сообщений (в зависимости от настроек).
		//
		// Параметры:
		//	ТекстСообщения - Строка - Текст сообщения
		//	Статус - ПеречислениеСсылка.ВидыСообщений - Вид сообщения
		//		   - СтатусСообщения - Статус сообщения (используется для совместимости со старыми вызовами процедуры Сообщить)
		//	Заголовок - Строка - Текст заголовка
		//	РасшифровкаСообщения - Массив - Массив с данными расшифровки
		//						 - Ссылка - Ссылка на объект
		//	СтрокаРодитель - Родительская строка дерева значений для вывода сообщения
		//	РаскрытьСообщение - Булево - Признак раскрытия строки дерева сообщений
		//
		// Возвращаемое значение:
		//	СтрокаДереваЗначенний - Строка дерева значений, в которую записано текущее сообщение
		//Если вывод сообщений в панель комментариев не предусмотрен, возвращается Неопределено

		public object Сообщение(/*Знач ТекстСообщения, Статус = Неопределено, Заголовок = "", РасшифровкаСообщения = Неопределено, СтрокаРодитель = Неопределено, РаскрытьСообщение = Истина, ЭтоСообщениеОбОшибке = Ложь*/)
		{
			/*ДублироватьСообщениеВЖурналРегистрации(ТекстСообщения, Статус, Заголовок);*/
			/*СтрокаДереваЗначений = ВыводСообщений.ВывестиСообщениеВПанельКомментариев(ТекстСообщения, Статус, Заголовок, РасшифровкаСообщения, СтрокаРодитель, РаскрытьСообщение);*/
			if(true/*СтрокаДереваЗначений = Неопределено*/)
			{
				/*//Сообщение в панель комментариев не выведено, значит необходимо вывести его в окно сообщений
*/
				/*ВыводСообщений.ВывестиСообщениеВОкноСообщений(ТекстСообщения, Статус, Заголовок, РасшифровкаСообщения, ЭтоСообщениеОбОшибке);*/
			}
			return null;
		}
		// Сообщение()
		////////////////////////////////////////////////////////////////////////////////
		// ВЫВОД ТРАССИРОВОЧНЫХ СООБЩЕНИЙ

		public void СообщитьОСостоянииОбновления(/*Подсистема, Действие, Комментарий="", Уровень=0, флЗавершающее=ложь*/)
		{
			/*СтрокаТабуляций = "";*/
			if(true/*флЗавершающее*/)
			{
				/*ВидСообщенияе = СтатусСообщения.Информация;*/
			}
			/*ОбщегоНазначения.Сообщение(СтрокаТабуляций + Подсистема + ": " + Действие + ?(Комментарий = "",""," (" + Комментарий + ")"),ВидСообщения);*/
		}

		public void СообщитьОСостоянииИзмененияНастройки(/*ИмяНастройки,Действие, Комментарий="", Уровень=0,текСтатусСообщения=неопределено*/)
		{
			if(true/*текСтатусСообщения = неопределено*/)
			{
				/*СтатусСообщенияДляВывода = СтатусСообщения.Информация;*/
			}
			/*СтрокаТабуляций = "";*/
			/*ОбщегоНазначения.Сообщение(СтрокаТабуляций + "Настройка учета: "+ИмяНастройки+". "+Действие + ?(Комментарий = "",""," (" + Комментарий + ")"),СтатусСообщенияДляВывода);*/
		}
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ОШИБКАМИ
		// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина".
		// В случае работы на клиенте вывобит сообщение в обработку комментирования
		// на сервере выводит в окно сообщений,
		// в случае внешнего соединения вызывает исключение.
		//
		// Параметры:
		//  ТекстСообщения  - строка, текст сообщения.
		//					  Строка может содержать символы %%, которые при формировании
		//					  сообщения заменяются на представления элементов расшифровки
		//  Отказ           - булево, признак отказа (необязательный).
		//  Заголовок	    - Заголовок сообщения, для вывода сообщения если работа на сервере или внешнее соединение
		//	Расшифровки 	- массив расшифровок для переданного ТекстСообщения
		//					  Представляет собой массив структур с полями Представление и Расшифровка
		//					  Поле Представление - текст, дополняющий ТекстСообщения
		//					  Поле Расшифровка - действие, выполняемое по расшифровке
		//

		public void ВывестиИнформациюОбОшибке(/*Знач ТекстСообщения, Отказ = Истина, Заголовок = "", ВидСообщения = Неопределено, Расшифровки = Неопределено, РодительскаяСтрока = НеОпределено, РаскрытьСообщение = Истина*/)
		{
			/*Отказ = Истина;*/
			if(true/*ВидСообщения = Неопределено*/)
			{
				/*ВидСообщения = Перечисления.ВидыСообщений.Ошибка;*/
			}
			/*Обработка = глЗначениеПеременной("глОбработкаСообщений");*/
			/*Обработка.ДобавитьСообщение(ТекстСообщения, ВидСообщения, Расшифровки, РодительскаяСтрока, РаскрытьСообщение);*/
			/*#ИначеЕсли ВнешнееСоединение Тогда
		
		ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);*/
			if(true/*ЗначениеЗаполнено(Заголовок)*/)
			{
				/*ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;*/
				/*Заголовок = "";*/
			}
			/*ВызватьИсключение (ТекстСообщения);*/
			if(true/*ЗначениеЗаполнено(Заголовок)*/)
			{
				/*Сообщить(Заголовок);*/
				/*Заголовок = "";*/
			}
			/*ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);*/
			/*Сообщить(ТекстСообщения, СтатусСообщения.Важное);*/
			/*#КонецЕсли;*/
		}
		// ВывестиИнформациюОбОшибке()
		// Функция убирает из текста сообщения служебную информацию.
		//
		// Параметры:
		//  ТекстСообщения, Строка, исходный текст сообщения
		//
		// Возвращаемое значение:
		//   Строка
		//

		public object СформироватьТекстСообщения(/*Знач ТекстСообщения*/)
		{
			/*НачалоСлужебногоСообщения    = Найти(ТекстСообщения, "{");*/
			/*ОкончаниеСлужебногоСообщения = Найти(ТекстСообщения, "}:");*/
			if(true/*ОкончаниеСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения < ОкончаниеСлужебногоСообщения*/)
			{
				/*ТекстСообщения = Лев(ТекстСообщения, (НачалоСлужебногоСообщения - 1)) +
		                 Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2));*/
			}
			return null;
		}

		public void СообщитьИнформациюПользователю(/*СтрокаСообщенияПользователю*/)
		{
			/*#Если Клиент Тогда
	Сообщить(СтрокаСообщенияПользователю);*/
			/*#КонецЕсли;*/
		}
		// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина".
		// В случае работы на клиенте или на сервере выводит в окно сообщений,
		// в случае внешнего соединения вызывает исключение.
		//
		// Параметры:
		//  ТекстСообщения - строка, текст сообщения.
		//  Отказ          - булево, признак отказа (необязательный).
		//	Заголовок - Строка - Текст заголовка
		//          (выводится пользователю в режиме обычного приложения;
		//           в заголовке должен быть описан контекст выполняемых действий, например "Проведение документа №... от ...")
		//	Статус - СтатусСообщения - Статус сообщения
		//	РасшифровкаСообщения - Массив - Массив с данными расшифровки
		//						 - Ссылка - Ссылка на объект
		//

		public void СообщитьОбОшибке(/*
	Знач ТекстСообщения, 
	Отказ = Ложь, 
	Заголовок = "",
	Статус = Неопределено,
	РасшифровкаСообщения = Неопределено
	*/)
		{
			if(true/*Статус = Неопределено*/)
			{
				/*Статус = СтатусСообщения.Важное;*/
			}
			/*ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);*/
			/*Отказ = Истина;*/
			/*//Для клиента и сервера запись в журнал регистрации попадет внутри процедуры Сообщение
*/
			/*ДублироватьСообщениеВЖурналРегистрации(ТекстСообщения, Статус, Заголовок);*/
			if(true/*ЗначениеЗаполнено(Заголовок)*/)
			{
				/*ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;*/
				/*Заголовок = "";*/
			}
			/*ВызватьИсключение (ТекстСообщения);*/
			/*#Иначе
		
		Сообщение(ТекстСообщения, Статус, Заголовок, РасшифровкаСообщения, Неопределено, Истина, Истина);*/
			/*#КонецЕсли;*/
		}
		// СообщитьОбОшибке()

		public void ПоказатьДиалогСИнформациейОбОшибке(/*ИнформацияОбОшибке*/)
		{
			/*#Если Клиент Тогда
		ПоказатьИнформациюОбОшибке(ИнформацияОбОшибке);*/
			/*#Иначе
		СообщитьОбОшибке(ПолучитьПричинуОшибки(ИнформацияОбОшибке).Описание);*/
			/*#КонецЕсли;*/
		}
		// Выводит сообщение "пользовательского" вида о невозможности заблокировать объект
		//

		public void СообщитьОбъектЗаблокирован(/*ПредставлениеОбъекта, ПредставлениеТипа, Отказ = Ложь*/)
		{
			/*ТекстСообщения = "Не удалось записать " + ПредставлениеТипа + " " + ПредставлениеОбъекта + "!" + Символы.ПС + "Возможно, его данные редактируются другим пользователем.";*/
			/*ТекстЗаголовка = "Ошибка блокировки объекта";*/
			/*Отказ = Истина;*/
			/*#Если Клиент Тогда
		РаботаСДиалогами.ВывестиПредупреждение(ТекстСообщения, ТекстЗаголовка);*/
			/*#Иначе
		СообщитьОбОшибке(ТекстСообщения, , ТекстЗаголовка);*/
			/*#КонецЕсли;*/
		}
		// СообщитьОбъектЗаблокирован
		// Формирует строку представления документа для сообщений при проведении.
		//
		// Параметры
		//  Источник - структура шапки или ссылка на проводимый документ.
		//
		// Возвращаемое значение
		//  Строка с представлением документа
		//

		public object ПредставлениеДокументаПриПроведении(/*Источник*/)
		{
			if(true/*ТипЗнч(Источник) = Тип("Структура")*/)
			{
				/*ПредставлениеДокумента = Источник.ПредставлениеДокумента;*/
				if(true/*Источник.Свойство("ВидОперации")*/)
				{
					/*ПредставлениеДокумента = ПредставлениеДокумента + " (" + Источник.ВидОперации + ")";*/
				}
			}
			/*ПредставлениеДокумента = "Проведение документа: " + ПредставлениеДокумента;*/
			return null;
		}
		// ПредставлениеДокументаПриПроведении
		// Предназначена для получения запросом представлений объектов
		// Поддерживает два синтаксиса
		// 1.
		// Параметры:
		//	СсылкиОбъектовПарам - массив ссылок
		// Возвращаемое значение
		//	Соответствие в котором ключ - одна из переданных ссылок,
		//  а значение - представление этой ссылки
		// 2.
		// Параметры:
		//	СсылкиОбъектовПарам - ссылка
		// Возвращаемое значение
		//	Строка предсатвления ссылки
		//
		// Пример использования:
		// 	МассивСсылок = Новый Массив;
		// 	МассивСсылок.Добавить(НоваяОрганизация);
		// 	МассивСсылок.Добавить(СтараяОрганизация);
		// 	Представления = ПолучитьПредставленияОбъектов(МассивСсылок);
		//	НоваяОрганизацияСтрокой = Представления[НоваяОрганизация];
		//	СтараяОрганизацияСтрокой = Представления[СтараяОрганизация];
		//

		public object ПолучитьПредставленияОбъектов(/*СсылкиОбъектовПарам*/)
		{
			/*// соответствие возвращается если передан массив ссылок
*/
			/*ПереданМассив = Истина;*/
			/*// Если передано одиночное значение - "превратим" его в массив
*/
			if(true/*ТипЗнч(СсылкиОбъектовПарам) <> Тип("Массив")*/)
			{
				/*Ссылка = СсылкиОбъектовПарам;*/
				/*СсылкиОбъектов = Новый Массив;*/
				/*СсылкиОбъектов.Добавить(Ссылка);*/
				/*ПереданМассив = Ложь;*/
			}
			/*// Обработаем массив СсылкиОбъектов и сформируем 
*/
			/*// соответствие ссылок по их типам
*/
			/*СсылкиПоТипам = Новый Соответствие;*/
			/*// формирование запроса
*/
			/*ТекстЗапроса = "";*/
			/*Запрос = Новый Запрос;*/
			/*ПервоеЗначение = Истина;*/
			/*// обработка запроса
*/
			/*Запрос.Текст = ТекстЗапроса;*/
			/*Выборка = Запрос.Выполнить().Выбрать();*/
			if(true/*ПереданМассив*/)
			{
				/*ВозвращаемоеСоответствие = Новый Соответствие;*/
				while(true/*Выборка.Следующий()*/)
				{
					/*ВозвращаемоеСоответствие[Выборка.Ссылка] = Выборка.Представление;*/
				}
				/*// дополним пустыми представлениями неполученных запросом ссылок
*/
			}
			return null;
		}
		// Проверяет принадлежность документа к видам учета
		//
		// Параметры:
		//  СтруктураШапкиДокумента - структура, содержащая реквизиты шапки документа
		//  Отказ                   - флаг отказа в проведении.
		//  Заголовок               - строка, заголовок сообщения об ошибке проведения.
		//  МожетБытьТолькоНалоговый- строка, заголовок сообщения об ошибке проведения.
		//

		public void ПроверитьПринадлежностьКВидамУчета(/*СтруктураШапкиДокумента, Отказ, Заголовок, МожетБытьТолькоНалоговый = Ложь*/)
		{
			/*ЕстьУпр = СтруктураШапкиДокумента.Свойство("ОтражатьВУправленческомУчете", Упр);*/
			/*ЕстьБух = СтруктураШапкиДокумента.Свойство("ОтражатьВБухгалтерскомУчете", Бух);*/
			/*ЕстьНал = СтруктураШапкиДокумента.Свойство("ОтражатьВНалоговомУчете", Нал);*/
			if(true/*ЕстьУпр ИЛИ ЕстьБух ИЛИ ЕстьНал*/)
			{
				if(true/*НЕ МожетБытьТолькоНалоговый*/)
				{
					if(true/*Упр <> Истина И Бух <> Истина*/)
					{
						/*СообщитьОбОшибке("Документ должен принадлежать хотя бы одному из видов учета: ""Управленческий"" и (или)  ""Бухгалтерский"".", Отказ, Заголовок);*/
					}
				}
			}
		}
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ПЕРЕЧИСЛЕНИЯМИ
		// Функция формирует список элементов перечисления
		//
		// Параметры
		//  ИмяПеречисления - имя перечисления, как оно задано в конфигураторе
		//
		// Возвращаемое значение:
		//   СписокЗначений - список элементов перечисления
		//

		public object ПолучитьСписокЭлементовПеречисления(/*ИмяПеречисления*/)
		{
			/*СписокЭлементовПеречисления = Новый СписокЗначений;*/
			/*Попытка
		КоллекцияЭлементовПеречисления = Перечисления[ИмяПеречисления];*/
			/*Исключение
		Возврат СписокЭлементовПеречисления;*/
			/*КонецПопытки;*/
			return null;
		}
		// ПолучитьСписокЭлементовПеречисления()
		// Процедура проверяет переданный параметр, если он не соответствует значению,
		// то присваивает ему указанное значение.
		//
		// Параметры:
		//  Параметр - параметр, значение которого проверяется и заполняется.
		//  Значение - значение для заполнения пустого параметра.
		//

		public void УстановитьНовоеЗначение(/*Параметр, Значение*/)
		{
			if(true/*Параметр <> Значение*/)
			{
				/*Параметр = Значение;*/
			}
		}
		// Предназначена для получения имени элемента перечисления по значению.
		//
		// Параметры:
		//	Элемент перечисления.
		//
		// Возвращаемое значение:
		//	Строка - имя элемента перечисления в метаданных.
		//

		public object ПолучитьИмяЭлементаПеречисленияПоЗначению(/*ЗначениеПеречисления*/)
		{
			/*ИмяЭлемента = Строка(ЗначениеПеречисления);*/
			return null;
		}
		// ПолучитьПериодичностьДляЗапросаПоЗначениюПеречисления()
		// сравнение значений перечислений на больше/меньше
		// применяется для перечислений, для которых последовательность
		// значений имеет определяющее значение
		//
		// Параметры:
		//  Значение1, Значение2 - сравниваемые значения перечислений
		//
		// Возвращаемое значение: число
		//   1 - если Значение1 > Значение2
		//  -1 - если Значение1 < Значение2
		//   0 - если Значение1 = Значение2
		//

		public object СравнениеПеречислений(/*Значение1, Значение2*/)
		{
			/*ИмяПеречисления = Метаданные.НайтиПоТипу(ТипЗнч(Значение1)).Имя;*/
			/*Менеджер = Перечисления[ИмяПеречисления];*/
			if(true/*Менеджер.Индекс(Значение1) > Менеджер.Индекс(Значение2)*/)
			{
			}
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕТАДАННЫМИ
		// Функция возвращает имя табличной части, к которой принадлежит переданная строка
		//
		// Параметры
		//  СтрокаТабличнойЧасти - ссылка на строку табличной части
		//
		// Возвращаемое значение:
		//   Строка - имя табличной части, как оно задано в конфигураторе
		//

		public object ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку(/*СтрокаТабличнойЧасти*/)
		{
			/*ИмяТабличнойЧасти = Метаданные.НайтиПоТипу(ТипЗнч(СтрокаТабличнойЧасти)).Имя;*/
			return null;
		}
		// ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку()
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ДВИЖЕНИЯМИ ДОКУМЕНТОВ
		// Функция возвращает массив, который содержит имена регистров
		// движения которых не надо удалять при очистке движений перед перепроведением
		//	Остатки, движения по таким регистрам не используются
		// 		ни в процедурах контроля остатков (товаров, задолженностей)
		// 		ни в логике формирования других движений (например, партии, авансы)
		//

		public object ПолучитьРегистрыДляОптимизацииПерезаписиДвижений(/*ТекущийРежимПроведенияДокумента*/)
		{
			/*МассивРегистров = Новый Массив;*/
			/*//В список регистров могут быть включены только те, движения которых записываются через коллекцию движений (Движения.<...>), 
*/
			/*//а не через набор записей 
*/
			/*// Регистры вида "Обороты", которые 
*/
			/*//- не используются для формирования движений 
*/
			/*//- двигаются документами, для которых применяется выборочное удаление движений
*/
			/*МассивРегистров.Добавить("ДвиженияДенежныхСредств");*/
			/*МассивРегистров.Добавить("Закупки");*/
			/*МассивРегистров.Добавить("Продажи");*/
			/*// Далее перечислены регистры, которые используются для контроля остатков, формирования движений 
*/
			/*// только при оперативном проведении. Их 
*/
			/*// - следует очищать если документ проводится оперативно
*/
			/*// - можно не очищать, если документ проводится неоперативно
*/
			if(true/*ТекущийРежимПроведенияДокумента = РежимПроведенияДокумента.Неоперативный*/)
			{
				/*МассивРегистров.Добавить("ВзаиморасчетыСКонтрагентами");*/
				/*МассивРегистров.Добавить("ДенежныеСредства");*/
				/*МассивРегистров.Добавить("ЗаказыПоставщикам");*/
				/*МассивРегистров.Добавить("РазмещениеЗаказовПокупателей");*/
				/*МассивРегистров.Добавить("РасчетыСКонтрагентами");*/
				/*МассивРегистров.Добавить("ТоварыВНТТ");*/
				/*МассивРегистров.Добавить("ТоварыВРезервеНаСкладах");*/
				/*МассивРегистров.Добавить("ТоварыВРознице");*/
				/*МассивРегистров.Добавить("ТоварыКПередачеОрганизаций");*/
				/*МассивРегистров.Добавить("ТоварыКПередачеСоСкладов");*/
				/*МассивРегистров.Добавить("ТоварыКПеремещениюВНТТ");*/
				/*МассивРегистров.Добавить("ТоварыКПолучениюНаСклады");*/
				/*МассивРегистров.Добавить("ТоварыНаСкладах");*/
				/*МассивРегистров.Добавить("ТоварыОрганизаций");*/
				/*МассивРегистров.Добавить("ТоварыПереданные");*/
				/*МассивРегистров.Добавить("ТоварыПолученные");*/
			}
			return null;
		}
		// ПолучитьРегистрыДляОптимизацииПерезаписиДвижений
		// Процедура удаления движений документа при перепроведении (отмене проведения)
		//
		// Параметры:
		//	ДокументОбъект 				- документ, движения которого удаляются
		//	Отказ 						- булево, признак отказа
		//	ВыборочноОчищатьРегистры 	- булево, признак выборочной очистки наборов записей
		//								Если Истина - часть наборов записей не будут очищены, будут очищены только коллекции движений
		//	РежимПроведенияДокумента 	- режим проведения (оперативный / неоперативный),
		//								нужен для составления списка регистров, которые не надо очищать
		//	Для документа ПринятиеКУчетуОС предусмотрена отдельная процедура УдалитьДвиженияПринятиеКУчетуОС

		public void УдалитьДвиженияРегистратора(/*ДокументОбъект, Отказ, ВыборочноОчищатьРегистры = Ложь, РежимПроведенияДокумента = Неопределено*/)
		{
			/*// Удалим те движения, которые уже записаны
*/
			/*УдалитьЗаписанныеДвиженияДокумента(ДокументОбъект, Отказ, ВыборочноОчищатьРегистры, РежимПроведенияДокумента);*/
			/*// Очистим непустые коллекции движений документа
*/
			/*ОчисткаКоллекцииДвиженийДокумента(ДокументОбъект);*/
			/*// Удаление записей регистрации из всех последовательностей - после удаления движений по регистрам
*/
			/*УдалитьРегистрациюДокументаВПоследовательностях(ДокументОбъект, Истина);*/
		}
		// Процедура очистки записанных движений документа
		//
		// Параметры:
		//	ДокументОбъект 				- документ, движения которого удаляются
		//	Отказ 						- булево, признак отказа
		//	ВыборочноОчищатьРегистры 	- булево, признак выборочной очистки наборов записей
		//								Если Истина - часть наборов записей не будут очищены, будут очищены только коллекции движений
		//	РежимПроведенияДокумента 	- режим проведения (оперативный / неоперативный),
		//								нужен для составления списка регистров, которые не надо очищать

		public void УдалитьЗаписанныеДвиженияДокумента(/*ДокументОбъект, Отказ, ВыборочноОчищатьРегистры, РежимПроведенияДокумента*/)
		{
			/*// Получим перечень регистров, движения по которым нужно очистить
*/
			/*МассивРегистров = ПроведениеДокументов.МассивРегистровНужноОчистить(ДокументОбъект);*/
			if(true/*МассивРегистров.Количество() = 0*/)
			{
			}
			/*// Если очищать регистры надо выборочно, то подготовим список таких регистров, 
*/
			/*//	которые можно не очищать при перепроведении
*/
			if(true/*ВыборочноОчищатьРегистры*/)
			{
				/*РегистрыДляОптимизацииПерезаписиДвижений = ПолучитьРегистрыДляОптимизацииПерезаписиДвижений(РежимПроведенияДокумента);*/
			}
			/*// Переменные логики отложенного проведения
*/
			/*ДокументИспользуетсяВОтложенномПроведении = Ложь;*/
			/*ВыполняетсяДопроведение                   = Ложь;*/
			/*ПроведениеПоВсемВидамУчета                = Ложь;*/
			/*СтруктураПараметровПроведения = ОтложенноеПроведениеДокументов.ПолучитьПараметрыПроведенияДокумента(ДокументОбъект);*/
			/*ДокументИспользуетсяВОтложенномПроведении = СтруктураПараметровПроведения.ДокументИспользуетсяВОтложенномПроведении;*/
			if(true/*ДокументИспользуетсяВОтложенномПроведении*/)
			{
				/*ВыполняетсяДопроведение = СтруктураПараметровПроведения.ВыполняетсяДопроведение;*/
				/*ПроведениеПоВсемВидамУчета = СтруктураПараметровПроведения.ПроведениеПоВсемВидамУчета;*/
				/*РегистрыОтложенногоПроведения = ОтложенноеПроведениеДокументов.ПолучитьРегистрыОтложенногоПроведения();*/
			}
			/*//Обойдем список регистров, по которым существуют движения, и выполним очистку необходимых регистров
*/
		}
		// Процедура удаления существующих движений документа ПринятиеКУчетуОС при перепроведении
		//	Отличается от универсальной процедуры УдалитьДвиженияРегистратора:
		//	- содержит специфичную для данного документа логику раздельного удаления движений по видам учета
		//	- не учитывает отложенное проведение (т.к. документ в отложенном проведении не участвует)
		//
		// Параметры
		//	ДокументОбъект 			- документ ПринятиеКУчетуОС, движения которого необходимо удалить
		//	СтруктураВидовУчета 	- Структура, содержащая перечень видов учета
		//								Для видов учета, по которым необходимо удалить движения, установлено значение Истина
		//								Движения документа удаляются выборочно - по выбранным видам учета
		//								Это необходимо при проведении по партиям (раздельное проведение документа по УУ, БУ + НУ)

		public void УдалитьЗаписанныеДвиженияДокументаПринятиеКУчетуОС(/*ДокументОбъект, СтруктураВидовУчета*/)
		{
			/*// Получим перечень регистров, движения по которым нужно очистить
*/
			/*МассивРегистров = ПроведениеДокументов.МассивРегистровНужноОчистить(ДокументОбъект);*/
			if(true/*МассивРегистров.Количество() = 0*/)
			{
			}
			/*//Признак - передана ли структура видов учета, в соответствии с которой надо выборочно удалять движения
*/
			/*ПроверитьПринадлежностьРегистраКВидамУчета = (СтруктураВидовУчета <> Неопределено И ТипЗНЧ(СтруктураВидовУчета) = Тип("Структура"));*/
			if(true/*ПроверитьПринадлежностьРегистраКВидамУчета*/)
			{
				/*// Получим список регистров с информацией: к какому виду учета они принадлежат
*/
				/*//	Далее используется при вызове функции РегистрПринадлежитВидамУчета
*/
				/*РегистрыПоВидамУчета = ПолучитьРегистрыПоВидамУчета();*/
			}
			/*//Обойдем список регистров, по которым существуют движения, и выполним очистку необходимых регистров
*/
		}
		//УдалитьЗаписанныеДвиженияДокументаПринятиеКУчетуОС
		// Процедура удаления движений документа ПринятиеКУчетуОС при перепроведении
		//	Отличается от универсальной процедуры УдалитьДвиженияРегистратора:
		//	- содержит специфичную для данного документа логику раздельного удаления движений по видам учета
		//	- не учитывает отложенное проведение (т.к. документ в отложенном проведении не участвует)
		//
		// Параметры
		//	ДокументОбъект 			- документ ПринятиеКУчетуОС, движения которого необходимо удалить
		//	Отказ 					- булево, признак отказа
		//	СтруктураВидовУчета 	- Структура, содержащая перечень видов учета
		//								Для видов учета, по которым необходимо удалить движения, установлено значение Истина
		//								Движения документа удаляются выборочно - по выбранным видам учета
		//								Это необходимо при проведении по партиям (раздельное проведение документа по УУ, БУ + НУ)

		public void УдалитьДвиженияПринятиеКУчетуОС(/*ДокументОбъект, Отказ, СтруктураВидовУчета*/)
		{
			/*// Удалим те движения, которые уже записаны
*/
			/*УдалитьЗаписанныеДвиженияДокументаПринятиеКУчетуОС(ДокументОбъект, СтруктураВидовУчета);*/
			/*// Очистим непустые коллекции движений документа
*/
			/*ОчисткаКоллекцииДвиженийДокумента(ДокументОбъект);*/
			/*// Удалим записи регистрации из всех последовательностей  - после удаления движений по регистрам
*/
			/*УдалитьРегистрациюДокументаВПоследовательностях(ДокументОбъект, Истина);*/
		}
		//УдалитьДвиженияПринятиеКУчетуОС
		// Процедура очищает коллекцию движений документа
		//

		public void ОчисткаКоллекцииДвиженийДокумента(/*ДокументОбъект*/)
		{
			if(true/*ДокументОбъект.Движения.Количество() = 0*/)
			{
			}
		}
		// Добавляет в таблицу значений строки из другой таблицы значений и
		// в них значения колонок с совпадающими наименованиями.
		//
		// Параметры:
		//  ТаблицаИсточник - таблица значений или массив строк таблицы значений, откуда берутся значения.
		//  ТаблицаПриемник - таблица значений, куда добавляются строки.
		//  ЗаполнятьНомераСтрокПоИсточнику - Булево - определяет необходимость сохранения информации
		//		об индексах строк таблицы-источника в таблице-приемнике.
		//		Используется в тех случаях, когда необходимо выполнить сопоставление строк приемника и источника.
		//

		public void ЗагрузитьВТаблицуЗначений(/*ТаблицаИсточник, ТаблицаПриемник, ЗаполнятьНомераСтрокПоИсточнику = Ложь*/)
		{
			/*// Заполним значения в совпадающих колонках.
*/
		}
		// ЗагрузитьВТаблицуЗначений()
		// Проверяет наличие требуемых данных в источнике и Формирует таблицу значений
		//
		// Параметры
		//  Источник  – ТаблицаЗначений или ТабличнаяЧасть или КоллекцияСтрокДереваЗначений с исходными данными
		//
		//  Реквизиты – структура – Структура реквизитов.
		//							Ключ 		- Наименование колонки в источнике
		//							Значение    - Наименование колонки в получаемой ТЗ
		//							Если значение опущено - приравнивается ключу.
		//	ПолучитьНомерСтрокиДокумента - булево
		//	                        Используется только при выгрузке из табличной части документа.
		//							В формируемой таблице создает новую колонку "НомерСтрокиДокумента"
		//								и заполняет её реальными номерами строк
		//
		//  КоллекцияКолонокДереваЗначений - только для коллекции строк дерева значений.
		// Возвращаемое значение:
		//  Таблица значений или Неопределено (если не хватает реквизитов)
		//

		public object СформироватьТаблицуЗначений(/*Источник,Реквизиты=Неопределено,ПолучитьНомерСтрокиДокумента = ложь,ФормироватьОтстутствующиеКолонки=Ложь,КоллекцияКолонокДереваЗначений=Неопределено*/)
		{
			/*ЭтоТаблицаЗначений=(ТипЗнч(Источник)= тип("ТаблицаЗначений"));*/
			/*ЭтоСтрокиДереваЗначений=(ТипЗнч(Источник)= тип("КоллекцияСтрокДереваЗначений"));*/
			if(true/*ЭтоСтрокиДереваЗначений и КоллекцияКолонокДереваЗначений = Неопределено*/)
			{
			}
			if(true/*НЕ ЗначениеЗаполнено(Реквизиты)*/)
			{
				if(true/*ЭтоТаблицаЗначений*/)
				{
					/*НоваяТЗ = Источник.Скопировать();*/
				}
			}
			if(true/*не ЭтоТаблицаЗначений  и не ЭтоСтрокиДереваЗначений*/)
			{
				/*РеквизитыТабличнойЧасти = Метаданные.НайтиПоТипу(ТипЗнч(Источник)).Реквизиты;*/
			}
			/*НоваяТЗ= Новый ТаблицаЗначений();*/
			if(true/*не ЭтоТаблицаЗначений и ПолучитьНомерСтрокиДокумента*/)
			{
				/*НоваяТЗ.Колонки.Добавить("НомерСтрокиДокумента",Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(5,0)));*/
			}
			while(true/*НоваяТЗ.Количество()<Источник.Количество()*/)
			{
				/*Строка = НоваяТЗ.Добавить();*/
				if(true/*не ЭтоТаблицаЗначений и ПолучитьНомерСтрокиДокумента*/)
				{
					/*Строка.НомерСтрокиДокумента = НоваяТЗ.Количество();*/
				}
			}
			return null;
		}
		// СформироватьТаблицуОплаты()
		// Формирует структуру, содержащую значения реквизитов шапки документа.
		//
		// Параметры:
		//  ДокументОбъект - объект документа для формирования структуры шапки.
		//
		// Возвращаемое значение:
		//  Сформированная структура.
		//

		public object СформироватьСтруктуруШапкиДокумента(/*ДокументОбъект*/)
		{
			/*СтруктураШапкиДокумента = Новый Структура;*/
			/*СтруктураШапкиДокумента.Вставить("Ссылка", ДокументОбъект.Ссылка);*/
			/*СтруктураШапкиДокумента.Вставить("Дата",   ДокументОбъект.Дата);*/
			/*ТипДокумента = ТипЗнч(ДокументОбъект);*/
			/*МетаданныеДокумента = Метаданные.НайтиПоТипу(ТипДокумента);*/
			/*СтруктураШапкиДокумента.Вставить("ВидДокумента",  				МетаданныеДокумента.Имя);*/
			/*СтруктураШапкиДокумента.Вставить("ПредставлениеДокумента", 		СокрЛП(ДокументОбъект));*/
			/*СтруктураШапкиДокумента.Вставить("ПредставлениеВидаДокумента",  МетаданныеДокумента.Представление());*/
			/*// Вставим свойства в структуру и далее при необходимости установим некоторые значения в Истину.
*/
			/*СтруктураШапкиДокумента.Вставить("ОрганизацияПрименяетУСН", 		 Ложь);*/
			/*СтруктураШапкиДокумента.Вставить("ОтражатьВНалоговомУчетеУСНДоходы", Ложь);*/
			/*СтруктураШапкиДокумента.Вставить("ОтражатьВНалоговомУчетеУСН", 		 Ложь);*/
			/*СтруктураШапкиДокумента.Вставить("ПоддержкаПБУ18", 					 Ложь);*/
			if(true/*СтруктураШапкиДокумента.Свойство("Организация")
	 И ЗначениеЗаполнено(СтруктураШапкиДокумента.Организация)
	 И СтруктураШапкиДокумента.Свойство("ОтражатьВБухгалтерскомУчете") 
	 И СтруктураШапкиДокумента.ОтражатьВБухгалтерскомУчете*/)
			{
				/*УчетнаяПолитика = ПолучитьПараметрыУчетнойПолитикиРегл(СтруктураШапкиДокумента.Дата, СтруктураШапкиДокумента.Организация);*/
				if(true/*ЗначениеЗаполнено(УчетнаяПолитика)*/)
				{
					/*СтруктураШапкиДокумента.ОрганизацияПрименяетУСН = УчетнаяПолитика.УСН;*/
					if(true/*СтруктураШапкиДокумента.Свойство("ОтражатьВНалоговомУчете") 
			 И СтруктураШапкиДокумента.ОтражатьВНалоговомУчете*/)
					{
						if(true/*УчетнаяПолитика.УСН*/)
						{
							/*СтруктураШапкиДокумента.ОтражатьВНалоговомУчете = Ложь;*/
							if(true/*УчетнаяПолитика.ОбъектНалогообложенияУСН = Перечисления.ОбъектыНалогообложенияПоУСН.Доходы*/)
							{
								/*СтруктураШапкиДокумента.ОтражатьВНалоговомУчетеУСНДоходы = Истина;*/
							}
						}
					}
				}
			}
			return null;
		}
		//Формирует структуру, содержащую значения реквизитов шапки документа.
		//Проверяет признаки отражения в учете
		//При необходимости корректирует признаки отражения в учете в связи с отложенным проведением или допроведением документа
		// Параметры:
		//  ДокументОбъект - объект документа для формирования структуры шапки,
		//	Отказ - признак отказа от проведения документа
		//	Заголовок - строка, заголовок для формирования сообщений об ошибках
		//	МожетБытьТолькоНалоговый - булево, признак того что флаг отражения в НУ может быть установлен независимо от флага отражения в БУ
		// Возвращаемое значение:
		//  Сформированная структура.
		//

		public object СформироватьСтруктуруШапкиДокументаИПроверитьОтражениеВУчете(/*ДокументОбъект, Отказ, Заголовок, МожетБытьТолькоНалоговый = Ложь*/)
		{
			/*СтруктураШапкиДокумента = СформироватьСтруктуруШапкиДокумента(ДокументОбъект);*/
			/*ПроверитьПринадлежностьКВидамУчета(СтруктураШапкиДокумента, Отказ, Заголовок);*/
			if(true/*Отказ*/)
			{
			}
			/*//Проверяем - возможно, документ должен проводиться отложенно
*/
			if(true/*ОтложенноеПроведениеДокументов.ДокументПодерживаетОтложенноеПроведение(ДокументОбъект,СтруктураШапкиДокумента)*/)
			{
				/*ОтложенноеПроведениеДокументов.ПодготовитьКПроведениюПоВидамУчета(ДокументОбъект.ДополнительныеСвойства, СтруктураШапкиДокумента);*/
			}
			return null;
		}
		// Выполняет движение по регистру.
		//
		// Параметры:
		//  НаборДвижений               - набор движений регистра,
		//  ПустыеКолонкиСоставногоТипа - структура, содержащая имена измерений,ресурсов и
		//  реквизитов составного типа, которые могут содержать пустые ссылки.
		//

		public void ВыполнитьДвижениеПоРегистру(/*НаборДвижений, ВидДвижения = Неопределено,
	                                  ПустыеКолонкиСоставногоТипа = Неопределено*/)
		{
			/*ТаблицаДвижений = НаборДвижений.мТаблицаДвижений;*/
			if(true/*ТаблицаДвижений.Количество() = 0*/)
			{
			}
			if(true/*ПустыеКолонкиСоставногоТипа = Неопределено*/)
			{
				/*ПустыеКолонкиСоставногоТипа = Новый Структура;*/
			}
			/*//
*/
			/*КолонкиТаблицы = ТаблицаДвижений.Колонки;*/
			/*//
*/
			/*МетаРег = НаборДвижений.Метаданные();*/
			/*ИзмеренияСостТипа = Новый Структура;*/
			/*ИзмеренияСостТипаСтр = "";*/
			if(true/*ИзмеренияСостТипаСтр <> ""*/)
			{
				/*ИзмеренияСостТипаСтр = Сред(ИзмеренияСостТипаСтр, 3);*/
			}
			/*ТипЧисло = Тип("Число");*/
			/*ТипСтрока = Тип("Строка");*/
			/*ТипДата = Тип("Дата");*/
			/*ЕстьПериод = НЕ ТаблицаДвижений.Колонки.Найти("Период") = Неопределено;*/
		}
		// ВыполнитьДвижениеПоРегистру()
		// Заполняет набор записей регистра СвободныеОстатки по данным базового регистра
		//
		// Параметры:
		//  НаборСвободныеОстатки	- таблица движений регистра СвободныеОстатки, которую нужно заполнить
		//  НаборБазовыйРегистр		- таблица движений регистра (базовый регистр) на основании которого необходимо заполнить регистр СвободныеОстатки
		//  ВидРегистраОснования	- перечисление <ВидыРегистровОснованийРегистраСвободныеОстатки>
		//

		public void ЗаполнитьСвободныеОстаткиПоДаннымБазовогоРегистра(/*НаборСвободныеОстатки, НаборБазовыйРегистр, ВидРегистраОснования*/)
		{
			if(true/*НаборБазовыйРегистр.Количество() = 0*/)
			{
			}
			/*ДатаНачалаИспользованияРегистраСвободныеОстатки = глЗначениеПеременной("ДатаНачалаИспользованияРегистраСвободныеОстатки");*/
			/*// Сначала проверим период записей, потом выполним заполнение
*/
			/*// Считаем, что период всех записей одинаковый
*/
			if(true/*НаборБазовыйРегистр[0].Период < ДатаНачалаИспользованияРегистраСвободныеОстатки*/)
			{
			}
			/*ОбратныйВидДвижения = (ВидРегистраОснования = Перечисления.ВидыРегистровОснованийРегистраСвободныеОстатки.ТоварыВРезервеНаСкладах
							ИЛИ ВидРегистраОснования = Перечисления.ВидыРегистровОснованийРегистраСвободныеОстатки.ТоварыКПередачеСоСкладов);*/
		}
		//
		// Выполняет движения по регистру СвободныеОстатки.
		//
		// Параметры:
		//  НаборДвижений			- таблица движений регистра (базовый регистр) на основании которого необходимо заполнить регистр СвободныеОстатки
		//  Регистратор				- документ, регистратор движений
		//  Замещение				- булево, замещать записи регистра
		//  ВидРегистраОснования	- перечисление <ВидыРегистровОснованийРегистраСвободныеОстатки>
		//

		public void ВыполнитьДвиженияПоРегиструСвободныеОстатки(/*НаборДвижений, Регистратор, Замещение, ВидРегистраОснования, Отказ = Ложь*/)
		{
			if(true/*НЕ глЗначениеПеременной("ИспользоватьРегистрСвободныеОстатки")*/)
			{
			}
			if(true/*ТипЗнч(Регистратор) = Тип("ДокументСсылка.КорректировкаЗаписейРегистров")*/)
			{
				/*// При изменении базовых регистров документом "Корректировка записей регистров"
*/
				/*// не выполняется автоматическое формирование движений по регистру
*/
			}
			/*НаборСвободныеОстатки = РегистрыНакопления.СвободныеОстатки.СоздатьНаборЗаписей();*/
			/*НаборСвободныеОстатки.Отбор.Регистратор.Установить(Регистратор);*/
			/*ЗаполнитьСвободныеОстаткиПоДаннымБазовогоРегистра(НаборСвободныеОстатки, НаборДвижений, ВидРегистраОснования);*/
			/*// Набор может не измениться
*/
			if(true/*НаборСвободныеОстатки.Модифицированность()*/)
			{
				/*НаборСвободныеОстатки.Записать(Ложь);*/
			}
			/*Исключение
		СообщитьОбОшибке(ОписаниеОшибки(), Отказ);*/
			/*ВызватьИсключение "Операция не выполнена";*/
			/*КонецПопытки;*/
		}
		// ВыполнитьДвиженияПоРегиструСвободныеОстатки
		// Процедура сворачивает движения по регистру накопления
		//

		public void СвернутьТаблицуДвиженийРегистраНакопления(/*НаборДвижений, ТабДвижений = Неопределено, УдалятьПустыеДвижения = Ложь*/)
		{
			if(true/*ТипЗнч(НаборДвижений) = Тип("Строка")*/)
			{
				/*МетаРег = Метаданные.РегистрыНакопления[НаборДвижений];*/
				/*ТаблицаДвижений = ТабДвижений;*/
			}
			if(true/*ТаблицаДвижений = Неопределено ИЛИ ТаблицаДвижений.Количество() = 0*/)
			{
			}
			/*Измерения = "Период,Регистратор,Активность";*/
			if(true/*МетаРег.ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Остатки*/)
			{
				/*Измерения = Измерения + ",ВидДвижения";*/
			}
			/*Ресурсы = "";*/
			/*ТаблицаДвижений.Свернуть(Измерения, Ресурсы);*/
			if(true/*УдалятьПустыеДвижения*/)
			{
				/*СтруктРесурсы   = Новый Структура(Ресурсы);*/
				/*МассивПустСтрок = Новый Массив;*/
				/*СтруктПоиска    = Новый Структура;*/
				/*МассивПустСтрок = ТаблицаДвижений.НайтиСтроки(СтруктПоиска);*/
			}
		}
		// СвернутьТаблицуДвиженийРегистраНакопления()
		// Получить движение(набор записей) для документа-объекта
		//
		// Параметры
		//  Объект  – 	ДокументОбъект – Документ. для которого производится поиск движения
		//  ТипДвижения  – Регистр<...>Менеджер – менеджер регистра, движение по которому пытаемся сформировать
		//             или <Строка> - имя регистра, движение по которому пытаемся сформировать
		//
		// Возвращаемое значение:
		//   Регистр<...>НаборЗаписей   – набор записей для объекта
		//   или Неопределено - если такого регистра не существует или документ не является регистратором регистра
		//

		public object ПолучитьДвижение(/*Объект, ТипДвижения, Сообщать=Ложь*/)
		{
			if(true/*ТипЗнч(ТипДвижения) = Тип("Строка")*/)
			{
				/*Движение = Объект.Движения.Найти(ТипДвижения);*/
				/*ДвижениеНевозможно = Движение = Неопределено;*/
			}
			if(true/*Сообщать И ДвижениеНевозможно*/)
			{
				if(true/*ТипЗнч(ТипДвижения) = Тип("Строка")*/)
				{
					/*ПредставлениеТипаДвижения = ТипДвижения;*/
				}
				/*СообщитьОбОшибке("Требуется подключение """ + ТипЗнч(Объект) + """ к формированиям движения по регистру """ + ПредставлениеТипаДвижения + """!");*/
			}
			return null;
		}
		// ПолучитьДвижение()
		// Получить набор записей по регистру по ссылке на документ
		//
		// Параметры
		//  Ссылка  		– ДокументСсылка		– Ссылка на документ, для которого производится поиск движений по регистру (набора записей)
		//  РегистрДвижения – Регистр<...>Менеджер	– менеджер регистра, движение по которому пытаемся обнаружить
		//  ПрочитатьЗаписи - Булево 				- Прочитать существующий набор записей для документа (если документ может формировать движения по указанному регистру).
		//
		// Возвращаемое значение:
		//   Регистр<...>НаборЗаписей – Набор записей по регистру с отбором по документу,
		//	 Неопределено 				в случае если документ не может формировать движений по регистру.
		//

		public object ПолучитьНаборЗаписейПоСсылке(/*Ссылка, РегистрДвижения, ПрочитатьЗаписи = Ложь, Сообщать=Ложь*/)
		{
			/*Движения = неопределено;*/
			if(true/*Ссылка.Метаданные().Движения.Содержит(Метаданные.НайтиПоТипу(ТипЗнч(РегистрДвижения)))*/)
			{
				/*Движения = РегистрДвижения.СоздатьНаборЗаписей();*/
				/*Движения.Отбор.Регистратор.Установить(Ссылка);*/
				if(true/*ПрочитатьЗаписи*/)
				{
					/*Движения.Прочитать();*/
				}
			}
			return null;
		}
		// ПолучитьНаборЗаписейПоСсылке()
		// Процедура сворачивает переданный набор записей регистра бухгалтерии по измерениям и реквизитам
		// Параметры: НаборЗаписейРегистраБухгалтерии, тип - набор записей регистров бухгалтерии Налоговый или Хозрасчетный
		//            СтрокаГруппировка, тип - строка - список колонок таблицы значений по которым будет выполняться группировка
		//            СтрокаСуммирование, тип - строка - список колонок таблицы значений которые будут суммироваться
		//            ВестиРеглУчетРасчетовСПерсоналомСводно, тип - булево - признак ведения сводного учета расчетов с персоналом
		//            МассивСчетовРасчетовСПерсоналом, тип - массив - список счетов учета расчетов с персоналом

		public void СвернутьНаборЗаписейРегистраБухгалтерии(/*НаборЗаписейРегистраБухгалтерии,
							СтрокаГруппировка, СтрокаСуммирование,
							ВестиРеглУчетРасчетовСПерсоналомСводно = Ложь, МассивСчетовРасчетовСПерсоналом = Неопределено*/)
		{
			/*КоличествоЗаписейНабораЗаписей = НаборЗаписейРегистраБухгалтерии.Количество();*/
			/*// Если количество записей равно 0 - не требуется выполнять сворачивание
*/
			if(true/*КоличествоЗаписейНабораЗаписей = 0*/)
			{
			}
			/*ТаблицаЗаписейРегистраБухгалтерии = НаборЗаписейРегистраБухгалтерии.Выгрузить();*/
			/*// Данная колонка в таблице не нужна
*/
			/*ТаблицаЗаписейРегистраБухгалтерии.Колонки.Удалить("НомерСтроки");*/
			/*// Признак наличия проводок по счетам учета расчетов с персоналом
*/
			/*ЕстьСчетаУчетаРасчетовСПерсоналом = Ложь;*/
			/*// Признак произведенной очистки субконто
*/
			/*ЕстьОчищенныеСубконто = Ложь;*/
			/*// Если способ ведения расчетов с персоналом - сводно,
*/
			/*// то перед сворачиванием могут потребоваться дополнительные действия по очистке аналитики в проводках
*/
			if(true/*ВестиРеглУчетРасчетовСПерсоналомСводно*/)
			{
				/*ТаблицаЗаписейРегистраБухгалтерии.Индексы.Добавить("СчетДт");*/
				/*ТаблицаЗаписейРегистраБухгалтерии.Индексы.Добавить("СчетКт");*/
				/*// Определим, есть ли проводки со счетами учета расчетов с персоналом
*/
				/*// Для таких проводок потребуется выполнить очистку значений субконто
*/
				/*// Обнаружены проводки, у которых указаны счета расчетов с персоналом
*/
				if(true/*ЕстьСчетаУчетаРасчетовСПерсоналом*/)
				{
					/*// Создаем массив префиксов имен колонок таблицы записей регистра
*/
					/*// С его помощью будем обращатся к именам колонок счетов и субконто Дт и Кт в цикле
*/
					/*// чтобы не дублировать код, различающийся только именами колонок таблицы записей регистра
*/
					/*ПрефиксыКолонок = Новый Массив;*/
					/*ПрефиксыКолонок.Добавить("Дт");*/
					/*ПрефиксыКолонок.Добавить("Кт");*/
					/*// Готовим соответствие счета расчетов и количества субконто счета
*/
					/*СоответствиеКоличествоСубконтоСчета = Новый Соответствие;*/
					/*// Готовим соответствие видов очищаемых субконто и пустых значений субконто
*/
					/*СоответствиеПустыхЗначенийСубконто = Новый Соответствие;*/
					/*ВидСубконто = ПланыВидовХарактеристик.ВидыСубконтоХозрасчетные.РаботникиОрганизации;*/
					/*СоответствиеПустыхЗначенийСубконто.Вставить(ВидСубконто,
				Новый Структура("ПустоеЗначениеСубконто", ВидСубконто.ТипЗначения.ПривестиЗначение()));*/
					/*ВидСубконто = ПланыВидовХарактеристик.ВидыСубконтоХозрасчетные.ВидНачисленийОплатыТрудаПоСтатье255НК;*/
					/*СоответствиеПустыхЗначенийСубконто.Вставить(ВидСубконто,
				Новый Структура("ПустоеЗначениеСубконто", ВидСубконто.ТипЗначения.ПривестиЗначение()));*/
				}
			}
			/*ТаблицаЗаписейРегистраБухгалтерии.Свернуть(СтрокаГруппировка,СтрокаСуммирование);*/
			/*// Если аналитика не очищалась и количество записей осталось без изменений 
*/
			/*//	- не требуется загружать свернутую таблицу в набор записей 
*/
			if(true/*НЕ ЕстьОчищенныеСубконто
	 И ТаблицаЗаписейРегистраБухгалтерии.Количество() = КоличествоЗаписейНабораЗаписей*/)
			{
			}
			/*// Поиск и удаление проводок с пустым  количеством и суммой
*/
			/*// Готовим структуру поиска - нулевые значения колонок, которые входят в список суммируемых колонок
*/
			/*СтруктураПоиска = Новый Структура(СтрокаСуммирование);*/
			/*// Удаление строк с пустыми значениями суммируемых колонок
*/
			/*МассивСтрокКУдалению = ТаблицаЗаписейРегистраБухгалтерии.НайтиСтроки(СтруктураПоиска);*/
			/*НаборЗаписейРегистраБухгалтерии.Загрузить(ТаблицаЗаписейРегистраБухгалтерии);*/
		}
		// Возвращает рабочую дату
		//
		// Возвращаемое значение:
		//   Дата - рабочая дата
		//

		public object ПолучитьРабочуюДату(/**/)
		{
			/*#Если Клиент Тогда
	Дата = РабочаяДата;*/
			/*#Иначе
	Дата = ТекущаяДата();*/
			/*#КонецЕсли

	Возврат Дата;*/
			return null;
		}
		// ПолучитьРабочуюДату()
		// Функция проверяет наличие в строке только цифр
		//
		// Параметры
		//  СтрокаПроверки - Строка для проверки только цифр
		//
		// Возвращаемое значение:
		//   Булево
		//

		public object ТолькоЦифрыВСтроке(/*Знач СтрокаПроверки, УчитыватьЛидирующиеНули = Истина, УчитыватьПробелы = Истина*/)
		{
			if(true/*ТипЗнч(СтрокаПроверки) <> Тип("Строка")*/)
			{
			}
			if(true/*НЕ ЗначениеЗаполнено(СтрокаПроверки)*/)
			{
			}
			if(true/*НЕ УчитыватьПробелы*/)
			{
				/*СтрокаПроверки = СтрЗаменить(СтрокаПроверки, " ", "");*/
			}
			if(true/*НЕ УчитыватьЛидирующиеНули*/)
			{
				/*НомерПервойЦифры = 0;*/
				/*СтрокаПроверки = Сред(СтрокаПроверки, НомерПервойЦифры);*/
			}
			return null;
		}
		// Функция возвращает структуру, содержащую виды учета (УУ, БУ, НУ) и принадлежащие им регистры
		//

		public object ПолучитьРегистрыПоВидамУчета(/**/)
		{
			/*РегистрыПоВидамУчета = Новый Структура;*/
			/*РегистрыПоВидамУчета.Вставить("ОтражатьВУправленческомУчете", "ГрафикиАмортизацииОС,
				|МестонахождениеОС,
				|НачислениеАмортизацииОС,
				|НоменклатураОсновныхСредств,
				|ПараметрыАмортизацииОС,
				|ПервоначальныеСведенияОС,
				|СобытияОС,
				|СоставОС,
				|СостоянияОС,
				|СписанныеТовары,
				|СпособыОтраженияРасходовПоАмортизацииОС,
				|БракВПроизводстве,
				|Затраты,
				|ЗатратыНаСтроительствоОбъектовОсновныхСредств,
				|НезавершенноеПроизводство,
				|ОССписанныеНаЗатраты,
				|ПартииТоваровНаСкладах,
				|СтоимостьОС,
				|СтроительствоОбъектовОсновныхСредств,
				|ТоварыНаСкладах,
				|СвободныеОстатки,
				|ТоварыОрганизаций,
				|ДопРасходыНаПриобретениеТоваров,
				|НезавершенноеПроизводство,
				|ПартииМатериаловВЭксплуатации,
				|ПартииТоваровПереданные,
				|ПродажиСебестоимость,
				|РеализованныеТовары,");*/
			/*РегистрыПоВидамУчета.Вставить("ОтражатьВБухгалтерскомУчете", "ГрафикиАмортизацииОСБухгалтерскийУчет,
				|МестонахождениеОСБухгалтерскийУчет,
				|НачислениеАмортизацииОСБухгалтерскийУчет,
				|ПараметрыАмортизацииОСБухгалтерскийУчет,
				|ПервоначальныеСведенияОСБухгалтерскийУчет,
				|МестонахождениеОСБухгалтерскийУчет,
				|МестонахождениеОСБухгалтерскийУчет,
				|СобытияОСОрганизаций,
				|СостоянияОСОрганизаций,
				|СписанныеТовары,
				|СпособыОтраженияРасходовПоАмортизацииОСБухгалтерскийУчет,
				|СчетаБухгалтерскогоУчетаОС,
				|БракВПроизводствеБухгалтерскийУчет,
				|ЗатратыБухгалтерскийУчет,
				|НДСНачисленный,
				|НДСПартииТоваров,
				|НДСпоОСиНМА,
				|НДСПредъявленный,
				|НезавершенноеПроизводствоБухгалтерскийУчет,
				|ОССписанныеНаЗатратыОрганизаций,
				|ПартииТоваровНаСкладахБухгалтерскийУчет,
				|СтоимостьОСБухгалтерскийУчет,
				|ТоварыОрганизаций,
				|Хозрасчетный,
				|НДСКосвенныеРасходы,
				|НДСНезавершенноеПроизводство,
				|НДСПродукция,
				|ПартииМатериаловВЭксплуатацииБухгалтерскийУчет,
				|ПартииТоваровПереданныеБухгалтерскийУчет,
				|УчетЗатратРегл,");*/
			/*РегистрыПоВидамУчета.Вставить("ОтражатьВНалоговомУчете", "НачислениеАмортизацииОСНалоговыйУчет,
				|НачислениеАмортизацииОССпециальныйКоэффициентНалоговыйУчет,
				|ПараметрыАмортизацииОСНалоговыйУчет,
				|ПервоначальныеСведенияОСНалоговыйУчет,
				|ПервоначальныеСведенияОСНалоговыйУчетУСН,
				|СписанныеТовары,
				|СпособыОтраженияРасходовПоАмортизацииОСНалоговыйУчет,
				|СчетаНалоговогоУчетаОС,
				|БракВПроизводствеНалоговыйУчет,
				|ЗатратыНалоговыйУчет,
				|НезавершенноеПроизводствоНалоговыйУчет,
				|ОплатыОСДляУСН,
				|ПартииТоваровНаСкладахНалоговыйУчет,
				|СтоимостьОСНалоговыйУчет,
				|Налоговый,
				|ПартииМатериаловВЭксплуатацииНалоговыйУчет,
				|ПартииТоваровПереданныеНалоговыйУчет,");*/
			/*РегистрыПоВидамУчета.Вставить("ОтражатьВМеждународномУчете", "БракВПроизводствеМеждународныйУчет,
				|НезавершенноеПроизводствоМеждународныйУчет,
				|ПартииТоваровНаСкладахМеждународныйУчет,
				|ПартииТоваровПереданныеМеждународныйУчет,");*/
			return null;
		}
		// РегистрыПоВидамУчета
		// Функция проверяет принадлежность указанного регистра всем требуемым видам учета
		//
		// Параметры:
		//  ИмяРегистра				- Строка, содержащая имя проверяемого регистра
		//  СтруктураВидовУчета		- Структура, содержащая перечень видов учета со значением Истина, для которых нужно производить проверку
		//  РегистрыПоВидамУчета	- структура, содержащая принадлежность регистров к видам учета
		//
		// Возвращаемое значение:
		//   Булево
		//

		public object РегистрПринадлежитВидамУчета(/*ИмяРегистра, СтруктураВидовУчета, РегистрыПоВидамУчета = Неопределено*/)
		{
			if(true/*РегистрыПоВидамУчета = Неопределено*/)
			{
				/*РегистрыПоВидамУчета = ПолучитьРегистрыПоВидамУчета();*/
			}
			/*//Регистр не принадлежит к проверяемым видам учета
*/
			return null;
		}
		//РегистрПринадлежитВидамУчета
		// Процедура заполняет субконто в строке набора записей
		// Параметры
		// Запись - Строка набора записей регистра бухгалтерии
		// Строка - Структура, содержащая значения субконто
		//

		public void ЗаполнитьСубконтоВНабореЗаписей(/*Запись,Строка*/)
		{
		}
		// ЗаполнитьСубконтоВНабореЗаписей
		// Добавляет записи из таблицы движений в набор записей
		// Параметры
		// НаборЗаписей - Набор записей регистра накопления или регистра бухгалтерии
		// Таблица - таблица значений содержащая движения соответствующего регистра (таблица движений)
		//

		public void ДобавитьСтрокиВНаборЗаписей(/*НаборЗаписей, Таблица*/)
		{
			/*НаборМетаданные = НаборЗаписей.Метаданные();*/
			/*ЭтоРегистрБухгалтерии = (Метаданные.РегистрыБухгалтерии.Найти(НаборМетаданные.Имя)<>Неопределено);*/
			/*Регистратор = НаборЗаписей.Отбор.Регистратор.Значение;*/
			/*Период = Неопределено;*/
		}
		// ДобавитьСтрокиВНаборЗаписей
		////////////////////////////////////////////////////////////////////////////////
		// МАТЕМАТИКА
		// возвращает "количество полных и неполных рублей"
		// Параметры:
		//	Сумма - число
		// Возвращаемое значение:
		//  число, равное ближайшему целому "сверху"

		public object ЦелМаксимальное(/*Сумма*/)
		{
			return null;
		}
		// ЦелМаксимальное()

		public object ДесятичноеВШестнадцатиричное(/*Источник*/)
		{
			/*ШеснадцатиричныеСимволы = "0123456789ABCDEF";*/
			if(true/*Источник < 0*/)
			{
			}
			if(true/*Источник > 255*/)
			{
			}
			/*ПервыйСимвол	= Цел(Источник / 16) + 1;*/
			/*ВтройСимвол		= Источник % 16 + 1;*/
			return null;
		}
		// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УЧЕТНОЙ ПОЛИТИКОЙ
		// Функция возвращает структуру с параметрами учетной политики (Упр) на заданную дату.
		//
		// Параметры:
		//	Период					- дата на которую необходимо получить учетную политику
		//	СообщатьОбОшибке		- булево, если Истина, то вывести сообщение,
		//							когда на дату нет учетной политики
		// Возвращаемое значение:
		// <Структура>				- если на дату нет учетной политики, то Неопределено
		//

		public object ПолучитьПараметрыУчетнойПолитикиУпр(/*Период, СообщатьОбОшибке = Истина*/)
		{
			if(true/*НЕ ЗначениеЗаполнено(Период)*/)
			{
			}
			/*УчетнаяПолитика = глЗначениеПеременной("УчетнаяПолитикаУпр");*/
			if(true/*СообщатьОбОшибке*/)
			{
				/*ТекстОшибки = "Не указаны параметры учетной политики (управленческий учет) на " + Формат(Период, "ДЛФ=DD");*/
				/*СообщитьОбОшибке(ТекстОшибки);*/
			}
			return null;
		}
		// ПолучитьПараметрыУчетнойПолитикиУпр
		// Функция возвращает структуру с параметрами учетной политики (регл учета)
		// на заданную дату по указанной организации.
		//
		// Параметры:
		//	Период					- дата на которую необходимо получить учетную политику
		//	Организация				- Организация по которой необходимо получить учетную политику
		//	СообщатьОбОшибке		- булево, если Истина, то вывести сообщение,
		//
		// Возвращаемое значение:
		// <Структура>				- если на дату нет учетной политики, то Неопределено
		//

		public object ПолучитьПараметрыУчетнойПолитикиРегл(/*Период, Организация, СообщатьОбОшибке = Истина*/)
		{
			if(true/*НЕ ЗначениеЗаполнено(Период) 
		ИЛИ НЕ ЗначениеЗаполнено(Организация)*/)
			{
			}
			/*Запрос = Новый Запрос;*/
			/*ТекстЗапроса = "ВЫБРАТЬ
	               |	Организации.ОтражатьВРегламентированномУчете КАК ОтражатьВРегламентированномУчете
	               |ИЗ
	               |	Справочник.Организации КАК Организации
	               |ГДЕ
	               |	Организации.Ссылка = &Ссылка";*/
			/*Запрос.Текст = ТекстЗапроса;*/
			/*Запрос.УстановитьПараметр("Ссылка", Организация);*/
			/*Выборка = Запрос.Выполнить().Выбрать();*/
			if(true/*Выборка.Следующий()*/)
			{
				if(true/*НЕ Выборка.ОтражатьВРегламентированномУчете*/)
				{
				}
			}
			/*УчетнаяПолитика = глЗначениеПеременной("УчетнаяПолитикаРегл");*/
			if(true/*СообщатьОбОшибке*/)
			{
				/*ТекстОшибки = "Не указаны параметры учетной политики (бухгалтерский и налоговый учет) на " + Формат(Период, "ДЛФ=DD") + " для организации " + Организация;*/
				/*СообщитьОбОшибке(ТекстОшибки);*/
			}
			return null;
		}
		// ПолучитьПараметрыУчетнойПолитикиРегл
		// Временная функция. Необходимо использовать функции ПолучитьПараметрыУчетнойПолитикиУпр и ПолучитьПараметрыУчетнойПолитикиРегл
		//

		public object ПолучитьПараметрыУчетнойПолитики(/*КонДата, УчетнаяПолитикаНеЗадана, Организация = Неопределено, Учет = "упр", СообщатьОбОшибке = Истина*/)
		{
			if(true/*НРег(Учет) = "упр"*/)
			{
				/*ПараметрыУчетнойПолитки = ПолучитьПараметрыУчетнойПолитикиУпр(КонДата, СообщатьОбОшибке);*/
			}
			if(true/*НЕ ЗначениеЗаполнено(ПараметрыУчетнойПолитки)*/)
			{
				/*УчетнаяПолитикаНеЗадана = Истина;*/
			}
			return null;
		}
		// ПолучитьПараметрыУчетнойПолитики
		// Процедура выводить сообщение о необходимости перезапуска программы при изменении учетной политики
		// если в ИБ работают другие пользователи.
		//

		public void СообщитьОбИзмененииУчетнойПолитики(/**/)
		{
			/*МассивСоединений = ПолучитьСоединенияИнформационнойБазы();*/
		}
		// Функция дополняет структуру шапки документа положениями учетной политики.
		//

		public void ДополнитьПоложениямиУчетнойПолитики(/*СтруктураШапкиДокумента, КонДата, Отказ, Организация, Учет = "Нал", СтруктураПолейУчетнойПолитикиНУ = неопределено*/)
		{
			if(true/*Учет = "Упр"*/)
			{
				/*СтруктураУП = ПолучитьПараметрыУчетнойПолитикиУпр(КонДата);*/
			}
			if(true/*НЕ ЗначениеЗаполнено(СтруктураУП)*/)
			{
				/*Отказ = Истина;*/
			}
		}
		// ДополнитьПоложениямиУчетнойПолитики()
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ ИНТЕРНЕТ-ПОДДЕРЖКИ ПОЛЬЗОВАТЕЛЕЙ
		// Процедура выполняет открытие HTML-страницы
		// по указанному URL

		public void Интерфейс1Действие(/**/)
		{
			/*Форма = Обработки.Обозреватель.ПолучитьФорму("Форма",,"Опрос");*/
			/*Форма.Заголовок = "Отзыв о программе";*/
			/*Форма.СтартоваяСтраница = "www.1c.ru/usability/inquirer/upp.jsp";*/
			/*Форма.Открыть();*/
		}
		////////////////////////////////////////////////////////////////////////////////
		// РАБОТА С ПЕРЕМЕННЫМИ
		// Меняет местами значения двух доступных для записи переменных
		//
		// Параметры
		//  Источник - первая переменная
		//  Приемник – вторая переменная
		//

		public void ПоменятьПеременныеМестами(/*Источник, Приемник*/)
		{
			/*тмп = Источник;*/
			/*Источник = Приемник;*/
			/*Приемник = Тмп;*/
		}
		// ПоменятьПеременныеМестами()
		// Функция "расщепляет" строку на подстроки, используя заданный
		//		разделитель. Разделитель может иметь любую длину.
		//		Если в качестве разделителя задан пробел, рядом стоящие пробелы
		//		считаются одним разделителем, а ведущие и хвостовые пробелы параметра Стр
		//		игнорируются.
		//		Например,
		//		РазложитьСтрокуВМассивПодстрок(",ку,,,му", ",") возвратит массив значений из пяти элементов,
		//		три из которых - пустые строки, а
		//		РазложитьСтрокуВМассивПодстрок(" ку   му", " ") возвратит массив значений из двух элементов
		//
		//	Параметры:
		//		Стр - 			строка, которую необходимо разложить на подстроки.
		//						Параметр передается по значению.
		//		Разделитель - 	строка-разделитель, по умолчанию - запятая.
		//
		//
		//	Возвращаемое значение:
		//		массив значений, элементы которого - подстроки
		//

		public object РазложитьСтрокуВМассивПодстрок(/*Знач Стр, Разделитель = ","*/)
		{
			return null;
		}
		// глРазложить
		// Возвращает строку, полученную из массива элементов, разделенных символом разделителя
		//
		// Параметры:
		//  Массив - Массив - массив элементов из которых необходимо получить строку
		//  Разделитель - Строка - любой набор символов, который будет использован как разделитель между элементами в строке
		//
		// Возвращаемое значение:
		//  Результат - Строка - строка, полученная из массива элементов, разделенных символом разделителя
		//

		public object ПолучитьСтрокуИзМассиваПодстрок(/*Массив, Разделитель = ","*/)
		{
			/*// возвращаемое значение функции
*/
			/*Результат = "";*/
			return null;
		}
		// Функция раскладывает Наименование в массив из трех элементов
		//
		// Параметры
		//  ФИО  - строка - наименование
		//
		// Возвращаемое значение:
		//   Массив   - массив из трех элементов, Фамилия, Имя, Отчество
		//

		public object ПолучитьМассивФИО(/*ФИО*/)
		{
			/*МассивФИО = Новый Массив;*/
			/*МассивФИО.Добавить("");*/
			/*МассивФИО.Добавить("");*/
			/*МассивФИО.Добавить("");*/
			/*МассивПодсток = ОбщегоНазначения.РазложитьСтрокуВМассивПодстрок(ФИО, " ");*/
			return null;
		}
		// ПолучитьМассивФИО()
		// Отбирает из переданной таблицы строки по заданным критериям.
		//
		// Параметры:
		//  Источник - ТаблицаЗначений, РезультатЗапроса, ОбластьЯчеекТабличногоДокумента. Таблица-источник.
		//  СтруктураКритериев - Структура. Названия отборов и значения, по которым нужно отобрать строки.
		//  СтруктураСложныхКритериев - Структура. Если свойство передано, то значение содержит вид сравнения.
		//
		// Возвращаемое значение:
		//  РезультатЗапроса - таблица с нужными строками.
		//

		public object ОтобратьСтрокиПоКритериям(/*Источник, СтруктураКритериев, СтруктураСложныхКритериев = Неопределено*/)
		{
			if(true/*СтруктураСложныхКритериев = Неопределено*/)
			{
				/*СтруктураСложныхКритериев = Новый Структура;*/
			}
			/*ПостроительЗапроса = Новый ПостроительЗапроса;*/
			/*ПостроительЗапроса.ИсточникДанных = Новый ОписаниеИсточникаДанных(Источник);*/
			return null;
		}
		// ОтобратьСтрокиПоКритериям()
		// Возвращает дату начала периода по имеющимся данным о:
		// дате окончании периода, значении перечисления Период, количестве периодов
		//

		public object ПолучитьДатуНачалаПериодаПоДатеОкончанияКоличествуПериодов(/*ДатаОкончания, ПериодСсылка, КоличествоПериодов*/)
		{
			if(true/*КоличествоПериодов = 0*/)
			{
				/*КоличествоПериодов = 1;*/
			}
			if(true/*ДатаОкончания = Неопределено*/)
			{
				if(true/*КоличествоПериодов > 0*/)
				{
					/*ДатаОкончания = КонецДня(ТекущаяДата());*/
				}
			}
			if(true/*(ПериодСсылка = Перечисления.Периодичность.День)*/)
			{
				/*ДатаНачала = НачалоДня(ДатаОкончания - 60*60*24 * КоличествоПериодов);*/
			}
			if(true/*КоличествоПериодов > 0*/)
			{
			}
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// ФОРМИРОВАНИЕ КПП НА БАЗЕ ИНН
		// Процедура заполняет КПП на базе ИНН

		public void ЗаполнитьКППпоИНН(/*Знач ИНН, КПП, БезусловноеЗаполнениеКПП = Истина*/)
		{
			/*//	Если КПП формируется стандартным образом по ИНН, то для КПП берутся 
*/
			/*//первые 4 цифры ИНН + 01001, например:
*/
			/*//ИНН 7712563009
*/
			/*//КПП 771201001
*/
			/*// если не указано ИНН или заполнено КПП то прерываем выполнение операции
*/
			if(true/*(СтрДлина(ИНН) < 4)*/)
			{
			}
			/*ПревыеСимволыИНН = Лев(ИНН, 4);*/
			/*НовоеЗначениеКПП = ПревыеСимволыИНН + "01001";*/
			/*// если новое значение КПП и старое значение КПП совпадают, то прерываем выполнение операции
*/
			if(true/*(НовоеЗначениеКПП = КПП)*/)
			{
			}
			/*// если безусловно нужно поменять - меняем
*/
			if(true/*БезусловноеЗаполнениеКПП ИЛИ НЕ ЗначениеЗаполнено(КПП)*/)
			{
				/*КПП = НовоеЗначениеКПП;*/
			}
			/*ОтветНужноМенятьКПП = (Вопрос("Изменить КПП автоматически на """ + НовоеЗначениеКПП + """?", РежимДиалогаВопрос.ДаНет) = КодВозвратаДиалога.Да);*/
			if(true/*ОтветНужноМенятьКПП*/)
			{
				/*КПП = НовоеЗначениеКПП;*/
			}
		}

		public object ПолучитьОсновнойДоговорКонтрагента(/*Контрагент*/)
		{
			/*Запрос = Новый Запрос;*/
			/*Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	|	ДоговорыКонтрагентов.Ссылка КАК ДоступныйДоговорКонтрагента
	|ИЗ
	|	Справочник.ДоговорыКонтрагентов КАК ДоговорыКонтрагентов
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.Контрагенты КАК Контрагенты
	|		ПО (Контрагенты.Ссылка = &Контрагент)
	|			И Контрагенты.ОсновнойДоговорКонтрагента = ДоговорыКонтрагентов.Ссылка
	|ГДЕ
	|	ДоговорыКонтрагентов.Владелец = &Контрагент
	|
	|УПОРЯДОЧИТЬ ПО
	|	ВЫБОР
	|		КОГДА Контрагенты.ОсновнойДоговорКонтрагента ЕСТЬ NULL 
	|			ТОГДА 1
	|		ИНАЧЕ 0
	|	КОНЕЦ";*/
			/*Запрос.УстановитьПараметр("Контрагент", Контрагент);*/
			/*Выборка = Запрос.Выполнить().Выбрать();*/
			if(true/*Выборка.Следующий()*/)
			{
			}
			return null;
		}

		public object ПолучитьОсновноеКонтактноеЛицоКонтрагента(/*Контрагент*/)
		{
			/*Запрос = Новый Запрос;*/
			/*Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	|	КонтактныеЛицаКонтрагентов.Ссылка КАК ДоступноеКонтактноеЛицоКонтрагента
	|ИЗ
	|	Справочник.КонтактныеЛицаКонтрагентов КАК КонтактныеЛицаКонтрагентов
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.Контрагенты КАК Контрагенты
	|		ПО (Контрагенты.Ссылка = &Контрагент)
	|			И Контрагенты.ОсновноеКонтактноеЛицо = КонтактныеЛицаКонтрагентов.Ссылка
	|ГДЕ
	|	КонтактныеЛицаКонтрагентов.Владелец = &Контрагент
	|
	|УПОРЯДОЧИТЬ ПО
	|	ВЫБОР
	|		КОГДА Контрагенты.ОсновноеКонтактноеЛицо ЕСТЬ NULL 
	|			ТОГДА 1
	|		ИНАЧЕ 0
	|	КОНЕЦ";*/
			/*Запрос.УстановитьПараметр("Контрагент", Контрагент);*/
			/*Выборка = Запрос.Выполнить().Выбрать();*/
			if(true/*Выборка.Следующий()*/)
			{
			}
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА РИБ

		public void ДобавитьПрефиксУзла(/*Префикс*/)
		{
			/*// Префикс узла распределенной информационной базы добавляется к префиксу-параметру процедуры
*/
			/*// если есть хоть один периферийный узел в любом из планов обмена:
*/
			/*// Полный, ОбменУППУПП, ОбменУправлениеПредприятиемУправлениеТорговлей, 
*/
			/*// ОбменУправлениеПредприятиемРозничнаяТорговля
*/
			/*//
*/
			/*// Установка значений параметров сеанса ИспользованиеРИБ, НаличиеОбменаУТУПП, 
*/
			/*// выполняется в процедуре ПолныеПрава.ОпределитьФактИспользованияРИБ()
*/
			if(true/*ПараметрыСеанса.ИспользованиеРИБ
	 ИЛИ ПараметрыСеанса.НаличиеОбменаУТУПП 
	 ИЛИ ПараметрыСеанса.НаличиеОбменаСРозничнойТорговлей*/)
			{
				/*Префикс = ПараметрыСеанса.ПрефиксУзлаРаспределеннойИнформационнойБазы + Префикс;*/
			}
		}

		public object ОпределитьТекущийРежимРаботыМонопольный(/**/)
		{
			/*МассивСоединений = ПолучитьСоединенияИнформационнойБазы();*/
			/*НомерТекущегоСоединения = НомерСоединенияИнформационнойБазы();*/
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ ОБНОВЛЕНИЯ КОНФИГУРАЦИИ

		public void ПредупреждениеОбОшибке(/*ТекстСообщения*/)
		{
			/*#Если Клиент Тогда
		
		Предупреждение(ТекстСообщения);*/
			/*#Иначе
		
		ВызватьИсключение(ТекстСообщения);*/
			/*#КонецЕсли;*/
		}
		// ПредупреждениеОбОшибке()

		public void ЗапуститьПрограмму(/*ПутьКПрограмме, РабочийКаталог = Неопределено*/)
		{
			/*#Если Клиент Тогда
		
		ЗапуститьПриложение(ПутьКПрограмме, РабочийКаталог);*/
			/*#КонецЕсли;*/
		}
		// ЗапуститьПрограмму()
		///////////////////////////////////////////////////////////////////////////////
		//// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С XML
		// Функция осуществляет построение дерева XML.
		//
		// Параметры
		//  XML             - <ЧтениеXML>
		//                  - Объект, при помощи которого осуществляется чтение
		//                    файла отчета.
		//
		//  Дерево          - <Структура>
		//                  - Дерево XML.
		//
		//  ПервыйВызов     - <Булево>
		//                  - Служебный параметр.
		//
		// Возвращаемое значение:
		//  <Булево>        - Результат выполнения.
		//

		public object ПостроитьДеревоXML(/*XML, Дерево, ПервыйВызов = Истина*/)
		{
			/*Результат = Истина;*/
			/*Имя       = "";*/
			/*Врем      = Неопределено;*/
			/*Врем2     = Неопределено;*/
			/*Врем3     = Неопределено;*/
			if(true/*ПервыйВызов*/)
			{
				/*Дерево = Новый Структура();*/
			}
			if(true/*XML.Прочитать()*/)
			{
				if(true/*XML.ТипУзла = ТипУзлаXML.НачалоЭлемента*/)
				{
					/*Имя  = XML.ЛокальноеИмя;*/
					/*Врем = Новый Структура();*/
					while(true/*ПостроитьДеревоXML(XML, Врем, Ложь)*/)
					{
					}
					while(true/*XML.Имя <> Имя*/)
					{
						if(true/*XML.ТипУзла = ТипУзлаXML.Текст*/)
						{
							/*Врем = XML.Значение;*/
						}
						if(true/*Не XML.Прочитать()*/)
						{
							/*Результат = Ложь;*/
						}
					}
					/*;
			Дерево.Свойство(Имя, Врем2);*/
					if(true/*Врем2 = Неопределено*/)
					{
						/*Врем2 = Врем;*/
					}
					/*Дерево.Вставить(Имя, Врем2);*/
				}
			}
			return null;
		}
		// ПостроитьДеревоXML()
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С ПОСЛЕДОВАТЕЛЬНОСТЯМИ

		public void УдалитьРегистрациюДокументаВПоследовательностях(/*ДокументОбъект, ПроверятьДвижения=ложь*/)
		{
			/*//Очистим коллекцию движений документа
*/
			/*ТаблицаСтаройРегистрацииВПоследовательности = Новый ТаблицаЗначений();*/
			/*ТаблицаСтаройРегистрацииВПоследовательности.Колонки.Добавить("ИмяПоследовательности");*/
			/*ТаблицаСтаройРегистрацииВПоследовательности.Колонки.Добавить("Организация");*/
			/*ТаблицаСтаройРегистрацииВПоследовательности.Колонки.Добавить("Период");*/
			/*КоллекцияПоследовательностей = ДокументОбъект.ПринадлежностьПоследовательностям;*/
			/*//Если коллекция пуста, то привилегированно очистим набор записей
*/
			/*УправлениеЗапасамиПартионныйУчет.УдалитьРегистрациюДокументаВПоследовательностяхНаСервере(ДокументОбъект.Ссылка, ПроверятьДвижения, ТаблицаСтаройРегистрацииВПоследовательности);*/
			/*ТаблицаСтаройРегистрацииВПоследовательности.Свернуть("ИмяПоследовательности,Организация,Период");*/
			/*ДокументОбъект.ДополнительныеСвойства.Вставить("ТаблицаСтаройРегистрацииВПоследовательности",ТаблицаСтаройРегистрацииВПоследовательности);*/
		}
		//УдалитьРегистрациюДокументаВПоследовательностях
		// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С ПОСЛЕДОВАТЕЛЬНОСТЯМИ
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ ФОРМИРОВАНИЯ ДВИЖЕНИЙ ДОКУМЕНТОВ
		// Функция загружает таблицы документа в таблицы соответствующие структуре регистров
		//	Параметры:
		//		- Движение - движение документа (т.е. регистр)
		//		- СтруктТаблицДокумента - структура содержашая таблицы документа. ключ - имя таблицы, значение - таблица значений с данными документа.
		//
		//	Возврат:
		//		- Структура, в которой ключ - это имя таблицы документа, соответствующий параметру СтруктТаблицДокумента,
		//		  значение - таблица значений, со структурой соответствующей структуре параметра (т.е. регистра) Движение
		//		  В таблицы значений данные загружаются по соответствию с имен полей.
		//

		public object ЗагрузитьТаблицыДокументаВСтруктуру(/*Движение, СтруктТаблицДокумента*/)
		{
			/*ПустаяТабРегистра = Движение.Выгрузить();*/
			/*ПустаяТабРегистра.Очистить();*/
			/*СтруктДанных = Новый Структура;*/
			return null;
		}
		// ЗагрузитьТаблицыДокументаВСтруктуру()
		// Процедура заполняет структуру таблиц документа, значением которое будет одинаковым для всех таблиц (например значением шапки документа)
		//	Параметры:
		//		- СтруктТаблицДокумента - структура таблиц документа, сформированная функцией ЗагрузитьТаблицыДокументаВСтруктуру()
		//		- ИмяПоля - имя колонки в таблицах локумента, в которую будет установлено новое значение
		//		- УстанавливаемоеЗначение - значение, которое надо установить в таблицы документа
		//		- СтрТабЧасти - имена таб. частей документа в которые необходимо установить новое значение. строка, в которой
		//						имена таб. частей разделены запятыми. необязательный параметр, по умолчанию - все таблицы.
		//

		public void УстановитьЗначениеВТаблицыДокумента(/*СтруктТаблицДокумента, ИмяПоля, УстанавливаемоеЗначение, СтрТабЧасти = ""*/)
		{
			/*СтруктТабЧасти = ?( ПустаяСтрока(СтрТабЧасти), СтруктТаблицДокумента, Новый Структура(СтрТабЧасти));*/
		}
		// УстановитьЗначениеВТаблицыДокумента()
		// Процедура формирует движение в регистр на основании данных в таблицах документов
		//	Параметры:
		//		- Движение - движение документа, в которое необходимо произвести добавление записей (т.е. регистр)
		//		- ВидДвижения - вид движения накопления (приход/расход)
		//		- СтруктТаблицДокумента - структура таблиц документа, сформированная функцией ЗагрузитьТаблицыДокументаВСтруктуру()
		//		- ДатаДвижения - дата на которую будут формироваться записи
		//

		public void ЗаписатьТаблицыДокументаВРегистр(/*Движение, ВидДвижения, СтруктТаблицДокумента, ДатаДвижения*/)
		{
			/*Движение.мПериод = ДатаДвижения;*/
		}
		// ЗаписатьТаблицыДокументаВРегистр()
		// Процедура удаляет строки с пустыми значениями из структуры таблиц документа
		//	Параметры:
		//		- ТаблицыДляДвиженийПоЗаказам - структура таблиц документа
		//		- ИмяПоля - имя поля, значение которого проверяет на пустое значение.
		//

		public void УдалитьСтрокиИзТаблицДокумента(/*ТаблицыДляДвиженийПоЗаказам, ИмяПоля*/)
		{
		}
		// УдалитьСтрокиИзТаблицДокумента()
		// Процедура переименовывает колонку таблицы значений, с сохранением истории переименований для возможности последующего "отката"
		//
		//	Параметры:
		//		- ТабЗначений - таблица значений в которой производится переименование колонок
		//		- ТабИмен - таблица с историей переименований. Новые сведения о переименованных колонках добавляются сюда и возвращаются в вызвавшую процедуру
		//		- ТекИмяКолонки - имя колонки которую надо переименовать
		//		- НовоеИмяКолонки - новое имя колонки. Если параметр не задан, новое имя присваивается автоматически
		//

		public void ПереименоватьКолонкуТаблицыЗначений(/*ТабЗначений, ТабИмен, Знач ТекИмяКолонки, Знач НовоеИмяКолонки = ""*/)
		{
			if(true/*ТабИмен = Неопределено*/)
			{
				/*ТабИмен = Новый ТаблицаЗначений;*/
				/*ТабИмен.Колонки.Добавить("НовИмя", Новый ОписаниеТипов("Строка"));*/
				/*ТабИмен.Колонки.Добавить("ТекИмя",   Новый ОписаниеТипов("Строка"));*/
			}
			/*ТекКолонка = ТабЗначений.Колонки.Найти(ТекИмяКолонки);*/
			if(true/*ПустаяСтрока(НовоеИмяКолонки)*/)
			{
				/*// Генерируем новое имя для старой колонки, гарантируя что оно будет уникальным
*/
				/*Индекс = 1;*/
				while(true/*Истина*/)
				{
					/*НовоеИмяКолонки = "_" + Строка(Индекс) + "_" + ТекИмяКолонки;*/
					if(true/*ТабЗначений.Колонки.Найти(НовоеИмяКолонки) = Неопределено*/)
					{
						/*Прервать;*/
					}
					/*Индекс = Индекс + 1;*/
				}
				/*// После выхода из цикла в переменной НовоеИмяКолонки должны получить новое имя колонки,
*/
			}
			/*// Переименуем колонку
*/
			/*ТабЗначений.Колонки[ТекИмяКолонки].Имя = НовоеИмяКолонки;*/
			/*// Сохраним имя колонки в таб. имен
*/
			/*НоваяСтрока = ТабИмен.Добавить();*/
			/*НоваяСтрока.НовИмя = НовоеИмяКолонки;*/
			/*НоваяСтрока.ТекИмя = ТекИмяКолонки;*/
		}
		// ПереименоватьКолонкуТаблицыЗначений()
		// Процедура восстанавливает имена колонок таблицы значений, сохраненные в процедуре ПереименоватьКолонкуТаблицыЗначений()
		//
		//	Параметры:
		//		- ТабЗначений - таблица значений в которой производится переименование колонок
		//		- ТабИмен - таблица с историей переименований, таблица создается и заполняется в процедуре ПереименоватьКолонкуТаблицыЗначений()
		//

		public void ВосстановитьИменаКолонокТаблицыЗначений(/*ТабЗначений, ТабИмен*/)
		{
			/*К = ТабИмен.Количество() - 1;*/
			while(true/*К >= 0*/)
			{
				/*ТекСтрока = ТабИмен[К];*/
				/*ТабЗначений.Колонки[ТекСтрока.НовИмя].Имя = ТекСтрока.ТекИмя;*/
				/*К = К - 1;*/
			}
			/*;
	
	ТабИмен.Очистить();*/
		}
		// ВосстановитьИменаКолонокТаблицыЗначений()
		// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ ФОРМИРОВАНИЯ ДВИЖЕНИЙ ДОКУМЕНТОВ
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УПРАВЛЯЕМЫМИ БЛОКИРОВКАМИ
		// Устанавливает управляемую блокировку таблицы
		//
		// Параметры:
		//  СтруктураПараметров 		- <Структура>. Структура параметров блокировки. Обязательный параметр.
		//								Обязательно должна содержать свойства:
		//								"ИмяТаблицы" - <Строка> - имя таблицы, на которую накладывается блокировка.
		//									Например: "АвансовыйОтчет"
		//								Необязательные свойства:
		//								"ТипТаблицы" - <Строка> - тип таблицы, на которую накладывается блокировка.
		//									Пространство блокировки состоит из типа таблицы и имени таблицы.
		//									Например: "Документ"
		//									Значение по умолчанию: "РегистрНакопления"
		//								"РежимБлокировки" - <РежимБлокировкиДанных> - режим накладываемой блокировки.
		//									Значение по умолчанию: РежимБлокировкиДанных.Исключительный
		//								"ИсточникДанных" - источник данных для блокировки.
		//									Может передаваться значение любого типа, поддерживаемого свойством ИсточникДанных элемента блокировки,
		//									а также типа "Менеджер временных таблиц".
		//									Если в структуре нет этого свойства - блокировки через ИспользоватьИзИсточникаДанных() не накладываются.
		//								"ИмяВременнойТаблицы" - <Строка> - имя временной таблицы менеджера временных таблиц, которая служит источником данных для блокировки.
		//									Обязательно должно указываться, если в качестве источника данных процедуре передан менеджер временных таблиц.
		//  СтруктураЗначенийБлокировки	- <Структура> - описывает значения блокировки, накладываемые с помощью УстановитьЗначение().
		//									Ключ - поле блокировки, значение - блокируемое значение.
		//									Если передано Неопределено или если структура не содержит ни одного элемента -
		//									блокировки через УстановитьЗначение() не накладываются.
		//  СтруктураИсточникаДанных	- <Структура> - описывает значения блокировки, накладываемые с помощью ИспользоватьИзИсточникаДанных().
		//									Ключ - поле блокировки, значение - поле источника данных.
		//									Если передано Неопределено или если структура не содержит ни одного элемента -
		//									блокировки через ИспользоватьИзИсточникаДанных() не накладываются.
		//  Отказ 						- <Булево> - при ошибке в процессе установки блокировки в этот параметр процедура возвращает значение Истина
		//  Заголовок 					- <Строка> - заголовок сообщения об ошибке при установке блокировки
		//

		public void УстановитьУправляемуюБлокировку(/*СтруктураПараметров, СтруктураЗначенийБлокировки = Неопределено, СтруктураИсточникаДанных = Неопределено, Отказ, Заголовок*/)
		{
			if(true/*НЕ ТипЗнч(СтруктураПараметров) = Тип("Структура")*/)
			{
			}
			/*ИспользоватьЗначенияБлокировки = СтруктураЗначенийБлокировки <> Неопределено 
		И ТипЗнч(СтруктураЗначенийБлокировки) = Тип("Структура") 
		И СтруктураЗначенийБлокировки.Количество() > 0;*/
			/*ИспользоватьИсточникДанных     = СтруктураИсточникаДанных <> Неопределено 
		И ТипЗнч(СтруктураИсточникаДанных) = Тип("Структура") 
		И СтруктураИсточникаДанных.Количество() > 0
		И СтруктураПараметров.Свойство("ИсточникДанных");*/
			if(true/*НЕ ИспользоватьЗначенияБлокировки И НЕ ИспользоватьИсточникДанных*/)
			{
			}
			/*Блокировка = Новый БлокировкаДанных;*/
			/*ТипТаблицы = ?(СтруктураПараметров.Свойство("ТипТаблицы"), СтруктураПараметров.ТипТаблицы, "РегистрНакопления") + ".";*/
			/*ИмяТаблицы = СтруктураПараметров.ИмяТаблицы;*/
			/*ПространствоБлокировки = ТипТаблицы + ИмяТаблицы;*/
			/*ЭлементБлокировки = Блокировка.Добавить(ПространствоБлокировки);*/
			/*РежимБлокировки = ?(СтруктураПараметров.Свойство("РежимБлокировки"), СтруктураПараметров.РежимБлокировки, РежимБлокировкиДанных.Исключительный);*/
			/*ЭлементБлокировки.Режим = РежимБлокировки;*/
			if(true/*ИспользоватьЗначенияБлокировки*/)
			{
			}
			if(true/*ИспользоватьИсточникДанных*/)
			{
				/*ИсточникДанных = СтруктураПараметров.ИсточникДанных;*/
				if(true/*ТипЗнч(ИсточникДанных) = Тип("МенеджерВременныхТаблиц")*/)
				{
					/*Запрос = Новый Запрос;*/
					/*Запрос.МенеджерВременныхТаблиц = ИсточникДанных;*/
					/*ТекстЗапроса = "";*/
					/*ТекстЗапроса = Сред(ТекстЗапроса, 2);*/
					/*ТекстЗапроса = 			
			"ВЫБРАТЬ РАЗЛИЧНЫЕ"
			+ ТекстЗапроса + "
			|ИЗ
			|	" + СтруктураПараметров.ИмяВременнойТаблицы + " КАК Таб";*/
					/*Запрос.Текст = ТекстЗапроса;*/
					/*Результат    = Запрос.Выполнить();*/
					/*ЭлементБлокировки.ИсточникДанных = Результат;*/
				}
			}
			/*Попытка
	
		Блокировка.Заблокировать();*/
			/*Исключение
		
		ОбщегоНазначения.СообщитьОбОшибке(ОписаниеОшибки(), Отказ, Заголовок);*/
			/*ВызватьИсключение "Операция не выполнена";*/
			/*КонецПопытки;*/
		}
		// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УПРАВЛЯЕМЫМИ БЛОКИРОВКАМИ
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С КРИТЕРИЯМИ ОТБОРА
		// Функция разбирает строку вида
		// ТипОбъектаМетаданных.ИмяДокумента.ТабличнаяЧасть.ИмяТабличнойЧасти.Реквизит.ИмяРеквизита.
		// ТипОбъектаМетаданных должен быть Справочник или Документ.
		//
		// Параметры:
		//  ПутьКДанным - строка.
		//  МетаданныеОбъекта - Объект метаданных
		//
		// Возвращаемое значение:
		//  Структура - путь к объекту метаданных
		//

		public object РазобратьПутьКОбъектуМетаданных(/*ПутьКДанным, МетаданныеОбъекта = Неопределено*/)
		{
			/*Структура = Новый Структура;*/
			/*СоответствиеИмен = Новый Массив();*/
			/*СоответствиеИмен.Добавить("ТипОбъекта");*/
			/*СоответствиеИмен.Добавить("ВидОбъекта");*/
			/*СоответствиеИмен.Добавить("ПутьКДанным");*/
			/*СоответствиеИмен.Добавить("ИмяТаблЧасти");*/
			/*СоответствиеИмен.Добавить("ИмяРеквизита");*/
			/*ПутьКДанным = СтрЗаменить(ПутьКДанным, "Реквизит.", "");*/
			if(true/*Структура.ПутьКДанным = "ТабличнаяЧасть"*/)
			{
			}
			if(true/*МетаданныеОбъекта <> Неопределено*/)
			{
				/*Структура.Вставить("Метаданные", МетаданныеОбъекта);*/
			}
			return null;
		}
		// РазобратьПутьКОбъектуМетаданных()
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ ПАРАМЕТРОВ СЕАНСА, ПЕРЕМЕННЫХ МОДУЛЯ ПРИЛОЖЕНИЯ
		// Функция определяет наличие клиентских подключений к базе других пользователей

		public object ЕстьДругиеПользователиВБазе(/**/)
		{
			/*МассивСоединений = ПолучитьСоединенияИнформационнойБазы();*/
			/*НомерТекущегоСоединения = НомерСоединенияИнформационнойБазы();*/
			return null;
		}
		// Функция собирает паспортные данные физ. лица на указанную дату
		//
		// Параметры:
		//  ФизЛицо.    - физ. лицо, для которго необходимо получить паспортные данные
		//  ДатаПериода - дата получения сведений
		//
		// Возвращаемое значение:
		//  Структура с паспортными данными.
		//

		public object ПаспортныеДанные(/*ФизЛицо, ДатаПериода*/)
		{
			/*Запрос = Новый Запрос;*/
			/*Запрос.УстановитьПараметр("ПарФизЛицо",     ФизЛицо);*/
			/*Запрос.УстановитьПараметр("ПарДатаПериода", ДатаПериода);*/
			/*Запрос.Текст = 
	"ВЫБРАТЬ
	|	ДокументВид        КАК Вид,
	|	ДокументСерия      КАК Серия,
	|	ДокументНомер      КАК Номер,
	|	ДокументДатаВыдачи КАК ДатаВыдачи,
	|	ДокументКемВыдан   КАК Выдан
	|ИЗ
	|	РегистрСведений.ПаспортныеДанныеФизЛиц.СрезПоследних(&ПарДатаПериода, ФизЛицо = &ПарФизЛицо)
	|";*/
			/*Шапка = Запрос.Выполнить().Выбрать();*/
			/*Шапка.Следующий();*/
			/*Результат = Новый Структура("Вид, Серия, Номер, ДатаВыдачи, Выдан");*/
			/*Результат.Вид        = Шапка.Вид;*/
			/*Результат.Серия      = Шапка.Серия;*/
			/*Результат.Номер      = Шапка.Номер;*/
			/*Результат.ДатаВыдачи = Шапка.ДатаВыдачи;*/
			/*Результат.Выдан      = Шапка.Выдан;*/
			return null;
		}
		// ПаспортныеДанные()
		// Получает параметр учетной политики (налоговый учет) для заданной организации на заданную дату
		//
		// Параметры:
		//	ИмяПараметра        - строка, имя запрашиваемого параметра учетной политики,
		//	Организация         - ссылка на элемент справочника "Организации", для которого надо получить параметры,
		//	Дата                - дата, на которую надо получить параметры, если не заполнено, то берется рабочая дата,
		//	СтруктураПараметров - структура, содержащая все параметры учетной политики.
		//
		// Возвращаемое значение:
		//	Значение учетной политики
		//

		public object ВыгрузитьСтруктуруВСтроку(/*Структура,ПоЗначениям=Ложь,СтруктураПроверки = Неопределено*/)
		{
			/*НеПроверять = (СтруктураПроверки=Неопределено);*/
			/*НоваяСтрока = "";*/
			if(true/*ЗначениеЗаполнено(НоваяСтрока)*/)
			{
				/*НоваяСтрока = Лев(НоваяСтрока,СтрДлина(НоваяСтрока)-1);*/
			}
			return null;
		}
		//Процедура для распределения записей из одной таблицы значений по базису (таблица значений или  набору записей)
		//Источник 		: ТаблицаЗначений
		//Базис 		: ТаблицаЗначений или НаборЗаписей
		//Распределение : ключ - поля базиса, значение - поля источника
		//Фильтр 		: ключ - поля базиса, значение - поля источника (если не укзан - по совпадающим колонкам)
		//Игнорировать  : ключ - поля базиса, значение - поля источника
		//Дополнить		: ключ - имя нового поля базиса, значение - значение для заполнения

		public object СформироватьКорректирующиеЗаписи(/*Источник,Базис,Распределение,Фильтр=неопределено,Игнорировать=Неопределено,Дополнить=Неопределено, НераспределенныеЗаписи_AsIs = ложь*/)
		{
			if(true/*ТипЗнч(Базис) = Тип("ТаблицаЗначений")*/)
			{
				/*Временный_Базис	   = Базис.Скопировать();*/
			}
			/*КолонкиИсточника = Новый Структура();*/
			/*КолонкиБазиса = Новый Структура();*/
			if(true/*НЕ ЗначениеЗаполнено(Игнорировать)*/)
			{
				/*Игнорировать = новый Структура();*/
			}
			/*//Зачистим колонки источника на распределяемые колонки. Они учитываются отдельно.
*/
			if(true/*ЗначениеЗаполнено(Дополнить)*/)
			{
				/*//Проверим на отсутствие дополняемых колонок!
*/
			}
			/*//Если фильтр не задан - по всем совпадающим колонкам
*/
			if(true/*Фильтр=Неопределено*/)
			{
				/*Фильтр = Новый Структура();*/
			}
			if(true/*НЕ ЗначениеЗаполнено(Фильтр)*/)
			{
				/*//Должно быть хоть одно объединяющее поле!
*/
			}
			/*//Подготовить сворачивание для источника
*/
			/*СтрокаСверткиИсточник = ВыгрузитьСтруктуруВСтроку(Фильтр,Истина,КолонкиИсточника);*/
			if(true/*СтрокаСверткиИсточник = ложь*/)
			{
				/*//попытка фильтровать по полю, отсутствующему в источнике!
*/
			}
			/*КолонкиКРаспределениюИсточник = ВыгрузитьСтруктуруВСтроку(Распределение,Истина);*/
			if(true/*КолонкиКРаспределениюИсточник = ложь*/)
			{
				/*//попытка распределить поле, отсутствующее в источнике!
*/
			}
			/*//Подготовить сворачивание для базиса
*/
			/*СтрокаСверткиБазис = ВыгрузитьСтруктуруВСтроку(КолонкиБазиса,Ложь);*/
			if(true/*СтрокаСверткиБазис = ложь*/)
			{
				/*//попытка фильтровать по полю, отсутствующему в базисе!
*/
			}
			/*КолонкиКРаспределениюБазис = ВыгрузитьСтруктуруВСтроку(Распределение,Ложь);*/
			if(true/*КолонкиКРаспределениюБазис = ложь*/)
			{
				/*//попытка распределить поле, отсутствующее в базисе!
*/
			}
			/*Временный_Источник = Источник.Скопировать();*/
			/*Временный_Базис.Свернуть(СтрокаСверткиБазис,КолонкиКРаспределениюБазис);*/
			/*Временный_Источник.Свернуть(СтрокаСверткиИсточник,КолонкиКРаспределениюИсточник);*/
			/*НоваяТаблица = новый ТаблицаЗначений();*/
			/*ТаблицаБазисовРаспределения = Новый ТаблицаЗначений();*/
			if(true/*ЗначениеЗаполнено(Дополнить)*/)
			{
			}
			/*СтрокиС0Распределением = Новый Массив();*/
			/*//Если ЗначениеЗаполнено(ИсключитьПослеРаспределения) тогда
*/
			/*//	КолонкиРезультата = Новый Структура();
*/
			/*//	Для каждого Колонка из НоваяТаблица.Колонки Цикл
*/
			/*//		Если ИсключитьПослеРаспределения.Свойство(Колонка.Имя) = Истина  или Распределение.Свойство(Колонка.Имя) = Истина Тогда
*/
			/*//			Продолжить;
*/
			/*//		Иначе
*/
			/*//			КолонкиРезультата.Вставить(Колонка.Имя);
*/
			/*//		КонецЕсли;
*/
			/*//	КонецЦикла;
*/
			/*//	КолонкиКСворачиванию = ВыгрузитьСтруктуруВСтроку(КолонкиРезультата,Ложь);
*/
			/*//	НоваяТаблица.Свернуть(КолонкиКСворачиванию,КолонкиКРаспределениюБазис);
*/
			/*//КонецЕсли;
*/
			return null;
		}

		public object ВыгрузитьСтрокиДереваВТаблицуЗначений(/*Источник,КоллекцияКолонокДереваЗначений*/)
		{
			/*Реквизиты = Новый Структура();*/
			/*НоваяТЗ= Новый ТаблицаЗначений();*/
			while(true/*НоваяТЗ.Количество()<Источник.Количество()*/)
			{
				/*Строка = НоваяТЗ.Добавить();*/
			}
			return null;
		}
		// СформироватьТаблицуОплаты()
		// Возвращает строку, описывающую период, определяемый переданными
		// датой и периодичностью.
		//
		// Параметры
		//  ДатаВПериоде:Дата - дата из периода
		//  Периодичность: Строка - строка, определяющая периодичность
		//
		// Возвращаемое значение:
		//   СтрокаПериод: строка   – представление периода для вывода в отчетах
		//

		public object ПолучитьПериодСтрокой(/*ДатаВПериоде, Периодичность*/)
		{
			if(true/*Периодичность = "Год"*/)
			{
				/*ФорматДаты = "ДФ='гггг ""г.""'";*/
			}
			/*СтрокаПериод = "" + Формат(ДатаВПериоде, ФорматДаты);*/
			if(true/*Периодичность = "Неделя" И ТипЗнч(ДатаВПериоде) = Тип("Дата")*/)
			{
				/*СтрокаПериод = "" + НеделяГода(ДатаВПериоде) + "-ая " + СтрокаПериод + Формат(КонецНедели(ДатаВПериоде), "ДФ='"" - ""дд.ММ.гггг)'");*/
			}
			return null;
		}
		// ПолучитьПериодСтрокой()
		// Процедура предназначена для получения момента определения остатков для заполнения документа.
		//
		// Параметры:
		//  ДокОбъект - (ДокументОбъект), документ, для которого надо определить лату получения остатков.
		//
		// Возвращаемое значение.
		//  Дата (момент времени) - дата остатков
		//

		public object ПолучитьДатуОстатков(/*ДокОбъект*/)
		{
			/*ДатаОстатков = '00010101';*/
			if(true/*НачалоДня(ДокОбъект.Дата) <> НачалоДня(ТекущаяДата()) 
	   И ДокОбъект.Дата <> '00010101'*/)
			{
				if(true/*НЕ ЗначениеЗаполнено(ДокОбъект.Ссылка)*/)
				{
					/*ДатаОстатков = КонецДня(ДокОбъект.Дата);*/
				}
			}
			return null;
		}
		// Стандартная для данной конфигурации функция форматирования сумм
		//
		// Параметры:
		//  Сумма  - число, которое мы хотим форматировать,
		//  Валюта - ссылка на элемент справочника валют, если задан, то к в результирующую строку
		//           будет добавлено представление валюты
		//  ЧН     - строка, представляющая нулевое значение числа,
		//  ЧРГ    - символ-разделитель групп целой части числа.
		//
		// Возвращаемое значение:
		//  Отформатированная должным образом строковое представление суммы.
		//

		public object ФорматСумм(/*Сумма, Валюта = Неопределено, ЧН = "", ЧРГ = ""*/)
		{
			/*ФорматнаяСтрока = "ЧЦ=15;ЧДЦ=2" +
					?(ПустаяСтрока(ЧН), "", ";" + "ЧН=" + ЧН) +
					?(ПустаяСтрока(ЧРГ),"", ";" + "ЧРГ=" + ЧРГ);*/
			/*РезультирующаяСтрока = СокрЛ(Формат(Сумма, ФорматнаяСтрока));*/
			if(true/*Валюта <> Неопределено*/)
			{
				/*РезультирующаяСтрока = РезультирующаяСтрока + " " + СокрП(Валюта);*/
			}
			return null;
		}
		// ФорматСумм()
		// Удаляет повторяющиеся значения из массива
		//
		// Параметры:
		//	Массив
		//

		public void УдалитьПовторяющиесяЭлементы(/*Массив*/)
		{
			if(true/*ТипЗнч(Массив) = Тип("Массив")*/)
			{
				/*// Удалим повторы
*/
				/*Инд=0;*/
				/*КолВо = Массив.Количество();*/
				while(true/*Инд<КолВо*/)
				{
					/*Инд2 = Инд+1;*/
					while(true/*Инд2<КолВо*/)
					{
						if(true/*Массив[Инд2] = Массив[Инд]*/)
						{
							/*Массив.Удалить(Инд2);*/
							/*КолВо = КолВо-1;*/
						}
					}
					/*//Установим для не заполненных значений тип "Неопределено"
*/
					if(true/*НЕ ЗначениеЗаполнено(Массив[Инд])*/)
					{
						/*Массив[Инд] = Неопределено;*/
					}
					/*Инд = Инд+1;*/
				}
				/*;;*/
			}
		}
		// Функция выполняет пропорциональное распределение суммы в соответствии
		// с заданными коэффициентами распределения
		//
		// Параметры:
		//		ИсхСумма - распределяемая сумма
		//		МассивКоэф - массив коэффициентов распределения
		//		Точность - точность округления при распределении. Необязателен.
		//
		//	Возврат:
		//		МассивСумм - массив размерностью равный массиву коэффициентов, содержит
		//			суммы в соответствии с весом коэффициента (из массива коэффициентов)
		//          В случае если распределить не удалось (сумма = 0, кол-во коэф. = 0,
		//          или суммарный вес коэф. = 0), тогда возвращается значение Неопределено
		//

		public object РаспределитьПропорционально(/*Знач ИсхСумма, МассивКоэф, Знач Точность = 2, ПроверкаНулевыхЗначений=Истина*/)
		{
			if(true/*МассивКоэф.Количество() = 0 Или (ПроверкаНулевыхЗначений И ИсхСумма = 0) Или ИсхСумма = Null*/)
			{
			}
			/*// Массив коэффициентов необходимо упорядочить, поэтому создадим таблицу для распределения
*/
			/*УпорядоченнаяТаблица = Новый ТаблицаЗначений;*/
			/*УпорядоченнаяТаблица.Колонки.Добавить("Коэф", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(17,4)));*/
			/*УпорядоченнаяТаблица.Колонки.Добавить("ИсходныйИндекс", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15,0)));*/
			/*СуммаКоэф  = 0;*/
			if(true/*СуммаКоэф = 0*/)
			{
			}
			/*УпорядоченнаяТаблица.Сортировать("Коэф Убыв");*/
			/*МассивСумм = Новый Массив(УпорядоченнаяТаблица.Количество());*/
			return null;
		}
		// РаспределитьПропорционально()
		// Процедура копирует значения одной строки таблицы значеницй в другую
		// структура колонок должна совпадать
		//
		// Параметры:
		//		СтрокаПриемник - строка в которую копируем
		//		СтрокаИсточник - строка из которой копируем
		//      ИменаКол - имена колонок, разделенные запятыми, которые надо скопировать
		//                 необязателен. По умолчанию - все колонки
		//

		public void КопироватьСтрокуТаблицыЗначений(/*СтрокаПриемник, СтрокаИсточник, ИменаКол*/)
		{
			if(true/*ТипЗнч( ИменаКол) = Тип("ТаблицаЗначений")*/)
			{
				/*СписокСвойств = "";*/
				/*ЗаполнитьЗначенияСвойств(СтрокаПриемник, СтрокаИсточник, СписокСвойств,);*/
			}
		}
		// КопироватьСтрокуТаблицыЗначений()
		// Процедура возвращает паспортные данные физлица в виде строки
		//
		// Параметры:
		//  ФизЛицо - ссылка на элемент справочника "Физические лица",по которму необходимо
		//            получить паспортные данные.
		//
		// Возвращаемое значение:
		//  Строка с данными об удостоверении личности физичского лица
		//

		public object ПолучитьПаспортныеДанныеСтрокой(/*ФизЛицо*/)
		{
			/*СтруктураПаспортныхДанных	= РегистрыСведений.ПаспортныеДанныеФизЛиц.ПолучитьПоследнее(РабочаяДата, Новый Структура("ФизЛицо",ФизЛицо));*/
			/*ВидДокумента				= СтруктураПаспортныхДанных.ДокументВид;*/
			/*Серия						= СтруктураПаспортныхДанных.ДокументСерия;*/
			/*Номер						= СтруктураПаспортныхДанных.ДокументНомер;*/
			/*ДатаВыдачи					= СтруктураПаспортныхДанных.ДокументДатаВыдачи;*/
			/*КемВыдан					= СтруктураПаспортныхДанных.ДокументКемВыдан;*/
			/*НомерПодразделения			= СтруктураПаспортныхДанных.ДокументКодПодразделения;*/
			if(true/*НЕ (НЕ ЗначениеЗаполнено(ДатаВыдачи)
		   И НЕ ЗначениеЗаполнено(ВидДокумента)
		   И НЕ ЗначениеЗаполнено(Серия + Номер + КемВыдан + НомерПодразделения))*/)
			{
			}
			return null;
		}
		// ПолучитьПаспортныеДанныеСтрокой()
		// Процедура предназначена для преобразования номера документа.
		//
		// Параметры:
		//  Документ - (ДокументСсылка), документ, чей номер надо получить для печати.
		//
		// Возвращаемое значение.
		//  Строка - номер документа для печати
		//

		public object ПолучитьНомерНаПечать(/*Документ, МассивПрефиксов = Неопределено*/)
		{
			if(true/*Документ = Неопределено*/)
			{
			}
			/*Номер   = СокрЛП(Документ.Номер);*/
			/*Префикс = "";*/
			if(true/*МассивПрефиксов = Неопределено*/)
			{
				/*Организация = Неопределено;*/
				if(true/*ТипЗнч(Документ) = Тип("ВыборкаИзРезультатаЗапроса")
			ИЛИ ТипЗнч(Документ) = Тип("Структура")*/)
				{
					/*Организация = Документ.Организация;*/
				}
				/*МассивПрефиксовДляОбхода = СформироватьМассивПрефиксовДляРИБИОрганизации(Организация);*/
			}
			return null;
		}
		// ПолучитьНомерНаПечать()
		// Заменяет одни термины, которые используются в коде, другими - уместными в интерфейсе.
		// Позволяет иметь один тот же код при разных названиях объектов.
		//
		// Параметры
		//  СтрокаИзИнтерфейса - строка - заголовок колонки, надпись и т.п.
		//
		// Возвращаемое значение:
		//  Строка - новый заголовок колонки, надпись и т.п.
		//

		public object ПреобразоватьСтрокуИнтерфейса(/*СтрокаИзИнтерфейса*/)
		{
			return null;
		}
		// ПреобразоватьСтрокуИнтерфейса()
		// Возвращает головную организацию для заданной организации
		// Если для организации реквизит ГоловнаяОрганизация не заполнен
		// это значит, что сама организация является голвной
		//
		// Параметры
		//  Организация – СправочникСсылка.Организации
		//                 <продолжение описания параметра>
		//
		// Возвращаемое значение:
		//   СправочникСсылка.Организации
		//

		public object ГоловнаяОрганизация(/*Организация*/)
		{
			/*Запрос = Новый Запрос;*/
			/*Запрос.УстановитьПараметр("Организация",Организация);*/
			/*Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Организации.ГоловнаяОрганизация
	|ИЗ
	|	Справочник.Организации КАК Организации
	|ГДЕ
	|	Организации.Ссылка = &Организация";*/
			/*Выборка = Запрос.Выполнить().Выбрать();*/
			if(true/*Не Выборка.Следующий()*/)
			{
			}
			if(true/*Организация.Пустая() или Выборка.ГоловнаяОрганизация.Пустая()*/)
			{
			}
			return null;
		}
		// ГоловнаяОрганизация()

		public object ЭтоЮрЛицо(/*Организация*/)
		{
			/*Запрос = Новый Запрос;*/
			/*Запрос.УстановитьПараметр("Организация",Организация);*/
			/*Запрос.Текст =
	"ВЫБРАТЬ
	|	Организации.ЮрФизЛицо
	|ИЗ
	|	Справочник.Организации КАК Организации
	|ГДЕ
	|	Организации.Ссылка = &Организация";*/
			/*Выборка = Запрос.Выполнить().Выбрать();*/
			return null;
		}
		// ЭтоЮрЛицо()

		public object ЭтоДоступнаяОрганизация(/*Организация*/)
		{
			/*Запрос = Новый Запрос;*/
			/*Запрос.УстановитьПараметр("Организация",Организация);*/
			/*Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Организации.ПометкаУдаления
	|ИЗ
	|	Справочник.Организации КАК Организации
	|ГДЕ
	|	Организации.Ссылка = &Организация";*/
			/*// если удалось прочитать закрытое поле - организация доступна
*/
			return null;
		}
		// ЭтоДоступнаяОрганизация()
		///////////////////////////////////////////////////////////////////////////////
		// РАБОТА С ПЕРЕЧИСЛЕНИЕМ "ПЕРИОДИЧНОСТЬ"
		// Функции не обрабатывают значения "Декада" и "Полугодие"
		// Функция возвращает ближайшую дату начала периода планирования
		//
		// Параметры
		//	Периодичность (Перечисления.Периодичность)	- периодичность планирования по сценарию.
		//	ДатаВПериоде (Дата)							- произвольная дата
		//
		// Возвращаемое значение:
		//	ДатаНачалаПериода		– ближайшая дата начала периода планирования
		//

		public object ДатаНачалаПериода(/*ДатаВПериоде,Периодичность*/)
		{
			if(true/*НЕ ТипЗнч(ДатаВПериоде)=Тип("Дата")*/)
			{
			}
			if(true/*Периодичность=Перечисления.Периодичность.День*/)
			{
			}
			return null;
		}
		// ДатаНачалаПериода()
		// Функция возвращает ближайшую дату окончания периода планирования
		//
		// Параметры
		//	Периодичность (Перечисления.Периодичность)	- периодичность планирования по сценарию.
		//	ДатаВПериоде (Дата)							- произвольная дата
		//
		// Возвращаемое значение:
		//	ДатаКонцаПериода	– ближайшая дата окончания периода планирования
		//

		public object ДатаКонцаПериода(/*ДатаВПериоде,Периодичность*/)
		{
			if(true/*Периодичность=Перечисления.Периодичность.День*/)
			{
			}
			return null;
		}
		// ДатаКонцаПериода()
		// Функция добавляет интервал к дате
		//
		// Параметры:
		//	Периодичность (Перечисления.Периодичность)	- пнриодичность планирования по сценарию.
		//	ДатаВПериоде (Дата)							- произвольная дата
		//	Смещение (число)							- определяет направление и количество периодов, в котором сдвигается дата
		//
		// Возвращаемое значение:
		//	Дата, отстоящая от исходной на заданное количество периодов
		//

		public object ДобавитьИнтервал(/*ДатаПериода,Периодичность,Смещение*/)
		{
			if(true/*Смещение = 0*/)
			{
				/*НоваяДатаПериода = ДатаПериода;*/
			}
			return null;
		}
		// ДобавитьИнтервал()
		// Возвращает число дней в переданном периоде
		//
		// Параметры
		//  Периодичность – Перечисление.Периодичность элемент перечисления,
		//		для которого вычисляется количество дней
		//
		// Возвращаемое значение:
		//   ЧислоДнейВПериоде (число)  – число дней в переданном периоде
		//

		public object ЧислоДнейВПериоде(/*Периодичность*/)
		{
			if(true/*Периодичность=Перечисления.Периодичность.День*/)
			{
				/*ЧислоДнейВПериоде=1;*/
			}
			return null;
		}
		// ЧислоДнейВПериоде()
		///////////////////////////////////////////////////////////////////////////////

		public object ВопросПерезаполнитьКУДиР(/**/)
		{
			/*Ответ = Ложь;*/
			/*#Если Клиент Тогда
		ТекстВопроса = 
		"Отражение платежа в Книге учета доходов и расходов настроено вручную.
		|Перезаполнить показатели Книги учета доходов и расходов?";*/
			/*Ответ = (Вопрос(ТекстВопроса, РежимДиалогаВопрос.ДаНет, , КодВозвратаДиалога.Да) = КодВозвратаДиалога.Да);*/
			/*#КонецЕсли
	
	Возврат Ответ;*/
			return null;
		}
		// Формирует список обособленных структурных подразделений организации

		public object ПолучитьСписокОбособленныхПодразделенийОрганизации(/*Организация*/)
		{
			/*Запрос = Новый Запрос(
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Организации.Ссылка,
	|	Организации.Наименование
	|ИЗ
	|	Справочник.Организации КАК Организации
	|ГДЕ
	|	Организации.ГоловнаяОрганизация = &Организация");*/
			/*Запрос.УстановитьПараметр("Организация", Организация);*/
			/*СписокОрганизаций = Новый СписокЗначений;*/
			/*Выборка = Запрос.Выполнить().Выбрать();*/
			while(true/*Выборка.Следующий()*/)
			{
				/*СписокОрганизаций.Добавить(Выборка.Ссылка, Выборка.Наименование);*/
			}
			return null;
		}
		// ПолучитьСписокОбособленныхПодразделенийОрганизации()
		//Удалает повторяющиеся элементы массива.

		public object УдалитьПовторяющиесяЭлементыМассива(/*Массив, НеИспользоватьНеопределено = Ложь, УдалитьПустыеЭлементыСсылочногоТипа = Ложь*/)
		{
			/*ОписаниеТиповСправочники  = Справочники.ТипВсеСсылки();*/
			/*ОписаниеТиповДокументы    = Документы.ТипВсеСсылки();*/
			/*ОписаниеТиповПВХ          = ПланыВидовХарактеристик.ТипВсеСсылки();*/
			/*ОписаниеТиповПланыСчетов  = ПланыСчетов.ТипВсеСсылки();*/
			/*ОписаниеТиповПланыРасчета = ПланыВидовРасчета.ТипВсеСсылки();*/
			if(true/*ТипЗнч(Массив) = Тип("Массив")*/)
			{
				/*УжеВМасссиве = Новый Соответствие;*/
				/*БылоНеопределено = Ложь;*/
				/*КолвоЭлементовВМассиве = Массив.Количество();*/
			}
			return null;
		}
		//Функция возвращает информацию об уполномоченных лицах организации и сведения о приказе назначения

		public object ПолучитьДанныеУполномоченногоЛица(/*Организация, Пользователь = Неопределено*/)
		{
			/*Запрос = Новый Запрос;*/
			/*МассивПользователей = Новый Массив;*/
			/*МассивПользователей.Добавить(Справочники.Пользователи.ПустаяСсылка());*/
			if(true/*Пользователь <> Неопределено*/)
			{
				/*МассивПользователей.Добавить(Пользователь);*/
			}
			/*Запрос.УстановитьПараметр("Организация",Организация);*/
			/*Запрос.УстановитьПараметр("Пользователи",МассивПользователей);*/
			/*Запрос.Текст = "
		|ВЫБРАТЬ
		|	УполномоченныеЛица.УполномоченноеЛицо,
		|	УполномоченныеЛица.ЗаКогоПодписывает,
		|	УполномоченныеЛица.НомерДатаПриказа,
		|	ВЫБОР
		|		КОГДА УполномоченныеЛица.Пользователь = ЗНАЧЕНИЕ(Справочник.ФизическиеЛица.ПустаяСсылка) ТОГДА
		|			0
		|		ИНАЧЕ 1
		|	КОНЕЦ КАК ТипПользователя
		|ИЗ
		|	РегистрСведений.УполномоченныеЛицаОрганизаций КАК УполномоченныеЛица
		|ГДЕ
		|	УполномоченныеЛица.Организация = &Организация И
		|	УполномоченныеЛица.Пользователь В (&Пользователи)
		|УПОРЯДОЧИТЬ ПО
		|	ТипПользователя";*/
			/*УстановитьПривилегированныйРежим(Истина);*/
			/*Результат = Запрос.Выполнить();*/
			/*УстановитьПривилегированныйРежим(Ложь);*/
			if(true/*Результат.Пустой()*/)
			{
			}
			return null;
		}
		// Функция собирает сведения об ответственных лицах организации
		//
		// Параметры:
		//  Организация - организация, для которой нужно определить руководящих лиц.
		//

		public object ОтветственныеЛица(/*Организация, ДатаСреза, Подразделение = Неопределено*/)
		{
			/*СобиратьПоОрганизации = Истина;*/
			/*Результат = Новый Структура("Руководитель, РуководительДолжность, РуководительФИО, РуководительПредставление, 
								|ГлавныйБухгалтер, ГлавныйБухгалтерДолжность, ГлавныйБухгалтерФИО, ГлавныйБухгалтерПредставление, 
								|Кассир, КассирДолжность, КассирФИО, КассирПредставление,  
								|ОтветственныйЗаРегистры, ОтветственныйЗаРегистрыДолжность, ОтветственныйЗаРегистрыФИО, ОтветственныйЗаРегистрыПредставление");*/
			if(true/*Организация <> Неопределено*/)
			{
				/*ЗапросПоЛицам = Новый Запрос();*/
				/*ЗапросПоЛицам.УстановитьПараметр("ДатаСреза",   ДатаСреза);*/
				/*ЗапросПоЛицам.УстановитьПараметр("Организация", Организация);*/
				/*ЗапросПоЛицам.УстановитьПараметр("ПризнакФизЛица",   Перечисления.ЮрФизЛицо.ФизЛицо);*/
				/*ЗапросПоЛицам.Текст = "ВЫБРАТЬ
		                      |	ФИОФизЛицСрезПоследних.Фамилия,
		                      |	ФИОФизЛицСрезПоследних.Имя,
		                      |	ФИОФизЛицСрезПоследних.Отчество,
		                      |	ФИОФизЛицСрезПоследних.ФизЛицо КАК ФизическоеЛицо
		                      |ИЗ
		                      |	РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ) КАК ФИОФизЛицСрезПоследних
		                      |		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.Организации КАК Организации
		                      |		ПО ФИОФизЛицСрезПоследних.ФизЛицо = Организации.ИндивидуальныйПредприниматель
		                      |			И (Организации.Ссылка = &Организация)
		                      |			И (Организации.ЮрФизЛицо = &ПризнакФизЛица)";*/
				/*Руководители = ЗапросПоЛицам.Выполнить().Выбрать();*/
				while(true/*Руководители.Следующий()*/)
				{
					/*ФИО = Новый Структура("Фамилия, Имя, Отчество, Представление");*/
					if(true/*НЕ (НЕ ЗначениеЗаполнено(Руководители.Фамилия) или Руководители.Фамилия = NULL)*/)
					{
						/*ФИО.Фамилия = Руководители.Фамилия;*/
					}
					if(true/*НЕ (НЕ ЗначениеЗаполнено(Руководители.Имя) или Руководители.Имя = NULL)*/)
					{
						/*ФИО.Имя = Руководители.Имя;*/
					}
					if(true/*НЕ (НЕ ЗначениеЗаполнено(Руководители.Отчество) или Руководители.Отчество = NULL)*/)
					{
						/*ФИО.Отчество = Руководители.Отчество;*/
					}
					/*Представление = ПолучитьФамилиюИмяОтчество(ФИО.Фамилия, ФИО.Имя, ФИО.Отчество);*/
					/*Результат.Руководитель               = Руководители.ФизическоеЛицо;*/
					/*Результат.РуководительДолжность      = "";*/
					/*Результат.РуководительФИО            = ФИО;*/
					/*Результат.РуководительПредставление  = Представление;*/
				}
				if(true/*СобиратьПоОрганизации*/)
				{
					/*ЗапросПоЛицам.Текст = 
			"ВЫБРАТЬ
			|	ОтветственныеЛицаОрганизацийСрезПоследних.ОтветственноеЛицо,
			|	ОтветственныеЛицаОрганизацийСрезПоследних.ФизическоеЛицо,
			|	ОтветственныеЛицаОрганизацийСрезПоследних.Должность,
			|	ФИОФизЛицСрезПоследних.Фамилия,
			|	ФИОФизЛицСрезПоследних.Имя,
			|	ФИОФизЛицСрезПоследних.Отчество
			|ИЗ
			|	РегистрСведений.ОтветственныеЛицаОрганизаций.СрезПоследних(&ДатаСреза, СтруктурнаяЕдиница = &Организация) КАК ОтветственныеЛицаОрганизацийСрезПоследних
			|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо ССЫЛКА Справочник.ФизическиеЛица) КАК ФИОФизЛицСрезПоследних
			|		ПО ОтветственныеЛицаОрганизацийСрезПоследних.ФизическоеЛицо = ФИОФизЛицСрезПоследних.ФизЛицо";*/
					/*Руководители = ЗапросПоЛицам.Выполнить().Выбрать();*/
				}
				while(true/*Руководители.Следующий()*/)
				{
					/*ФИО = Новый Структура("Фамилия, Имя, Отчество, Представление");*/
					if(true/*НЕ (НЕ ЗначениеЗаполнено(Руководители.Фамилия) или Руководители.Фамилия = NULL)*/)
					{
						/*ФИО.Фамилия = Руководители.Фамилия;*/
					}
					if(true/*НЕ (НЕ ЗначениеЗаполнено(Руководители.Имя) или Руководители.Имя = NULL)*/)
					{
						/*ФИО.Имя = Руководители.Имя;*/
					}
					if(true/*НЕ (НЕ ЗначениеЗаполнено(Руководители.Отчество) или Руководители.Отчество = NULL)*/)
					{
						/*ФИО.Отчество = Руководители.Отчество;*/
					}
					/*Представление = ПолучитьФамилиюИмяОтчество(ФИО.Фамилия, ФИО.Имя, ФИО.Отчество);*/
					if(true/*Руководители.ОтветственноеЛицо      = Перечисления.ОтветственныеЛицаОрганизаций.Руководитель*/)
					{
						/*Результат.Руководитель               = Руководители.ФизическоеЛицо;*/
						/*Результат.РуководительДолжность      = Руководители.Должность;*/
						/*Результат.РуководительФИО            = ФИО;*/
						/*Результат.РуководительПредставление  = Представление;*/
					}
				}
				/*;;*/
			}
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЧИЕ ПРОЦЕДУРЫ И ФУНКЦИИ
		// Получает первичную информацию об ошибке
		// Параметры:
		//	ИнформацияОбОшибке - информация об ошибке
		// Возвращает:
		//	Информацию об ошибке, которая является первопричиной возникновения переданной ИнформацияОбОшибке
		//  Если ошибка первичная, то возвращается сама ошибка, переданная в качестве параметра

		public object ПолучитьПричинуОшибки(/*ИнформацияОбОшибке*/)
		{
			/*ПричинаОшибки = ИнформацияОбОшибке.Причина;*/
			if(true/*ПричинаОшибки = НеОпределено*/)
			{
			}
			while(true/*ПричинаОшибки.Причина <> НеОпределено*/)
			{
				/*ПричинаОшибки = ПричинаОшибки.Причина;*/
			}
			return null;
		}
		// Считываем последнее состояние регистра сведений о физлице и заполняем переданный набор записей
		//
		// Параметры
		//  Физлицо -
		//  НаборЗаписей  -
		//

		public void ПолучитьСвязанныеДанныеФизлица(/*Физлицо, НаборЗаписей*/)
		{
			/*НаборЗаписей.Очистить();*/
			if(true/*Физлицо.Пустая()*/)
			{
			}
			/*ИмяТаблицы = НаборЗаписей.Метаданные().Имя;*/
			/*Запрос = Новый Запрос;*/
			/*Запрос.УстановитьПараметр("ПарамФизЛицо",Физлицо);*/
			/*Запрос.УстановитьПараметр("парамДатаСреза", ОбщегоНазначения.ПолучитьРабочуюДату());*/
			/*Запрос.Текст = 
	"ВЫБРАТЬ
	|	СвязанныеДанные.*
	|ИЗ
	|	РегистрСведений." + ИмяТаблицы + ".СрезПоследних(&парамДатаСреза, ФизЛицо = &ПарамФизЛицо) КАК СвязанныеДанные";*/
			/*Выборка = Запрос.Выполнить().Выбрать();*/
			if(true/*Выборка.Следующий()*/)
			{
				/*ЗаполнитьЗначенияСвойств(НаборЗаписей.Добавить(), Выборка);*/
			}
		}
		// ПолучитьСвязанныеДанныеФизлица()
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ ОБСЛУЖИВАНИЯ ОБЪЕКТОВ, НЕ ПОДДЕРЖИВАЕМЫХ В КОНФИГУРАЦИИ
		//
		// Выводит сообщение о том, что объект не используется в конфигурации
		//

		public void СообщитьОбъектНеИспользуется(/*МетаданныеОбъекта = Неопределено, Отказ = Истина, СтандартнаяОбработка = Ложь*/)
		{
			/*ТипОбъекта = "Объект";*/
			if(true/*МетаданныеОбъекта <> Неопределено*/)
			{
				/*ПолноеИмяОбъекта = МетаданныеОбъекта.ПолноеИмя();*/
				/*ПозицияТочки = Найти(ПолноеИмяОбъекта, ".");*/
				if(true/*ПозицияТочки <> 0*/)
				{
					/*ТипОбъекта = Лев(ПолноеИмяОбъекта, ПозицияТочки-1);*/
				}
			}
			/*ОбщегоНазначения.СообщитьОбОшибке(ТипОбъекта+" не используется в конфигурации """ + Метаданные.Синоним + """", Отказ);*/
			/*СтандартнаяОбработка = Ложь;*/
		}
		// Заполняет указанную колонку таблицы значений числами по порядку, начиная с указанного номера
		//

		public void ПронумероватьСтрокиТаблицыЗначений(/*Таблица, ИмяКолонки = "НомерСтроки", ПервыйНомер = 1*/)
		{
			/*НомерСтроки = ПервыйНомер;*/
		}
	}
}

