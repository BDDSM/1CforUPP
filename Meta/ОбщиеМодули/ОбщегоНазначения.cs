using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace V82.ОбщиеМодули
{
	public partial class ОбщегоНазначения
	{
		////////////////////////////////////////////////////////////////////////////////
		// Общие процедуры и функции для работы с прикладными типами и коллекциями значений
		// Объединяет две таблицы значений по условию "И".
		// Возвращает таблицу значений, полученную в результате объединения двух таблиц по условию "И".
		//
		// Параметры:
		//  Таблица1         - ТаблицаЗначений - первая таблица значений для объединения
		//  Таблица2         - ТаблицаЗначений - вторая таблица значений для объединения
		//  ПоляТаблицы      - Строка - поля таблицы, перечисленные через запятую, по которым будут выполнятся объединение
		//  ИмяПоляИтератора - Строка - имя служебной колонки таблицы значений.
		//                              Это имя должно быть уникально во множестве имен колонок первой и второй таблиц.
		//                              Переменная ПоляТаблицы не должна содержать этого имени.
		//                              Значение по умолчанию "ИтераторПоляТаблицы"
		//
		// Возвращаемое значение:
		//  ТаблицаЗначений -  таблица значений, полученная в результате объединения двух таблиц по условию "И"
		//

		public object ОбъединитьТаблицыПоУсловиюИ(/*Таблица1, Таблица2, Знач ПоляТаблицы, ИмяПоляИтератора = "ИтераторПоляТаблицы"*/)
		{
			//Таблица1.Свернуть(ПоляТаблицы);
			//Таблица2.Свернуть(ПоляТаблицы);
			//ДобавитьИтераторТаблице(Таблица1, +1, ИмяПоляИтератора);
			//ДобавитьИтераторТаблице(Таблица2, -1, ИмяПоляИтератора);
			//ТаблицаРезультат = Таблица1.Скопировать();
			//ОбщегоНазначенияКлиентСервер.ДополнитьТаблицу(Таблица2, ТаблицаРезультат);
			//ТаблицаРезультат.Свернуть(ПоляТаблицы, ИмяПоляИтератора);
			//ТаблицаРезультат = ТаблицаРезультат.Скопировать(Новый Структура(ИмяПоляИтератора, 0));
			//ТаблицаРезультат.Колонки.Удалить(ИмяПоляИтератора);
			return null;
		}
		// Добавляет колонку в таблицу значений. Заполняет колонку переданным значением
		//
		// Параметры:
		//  Таблица           - ТаблицаЗначений - таблица значений для добавления колонки
		//  ЗначениеИтератора - Произвольный - значение, которым будет заполнено новое поле таблицы
		//  ИмяПоляИтератора  - Строка - имя добавляемого поля
		//

		public void ДобавитьИтераторТаблице(/*Таблица, ЗначениеИтератора, ИмяПоляИтератора*/)
		{
			//Таблица.Колонки.Добавить(ИмяПоляИтератора);
			//Таблица.ЗаполнитьЗначения(ЗначениеИтератора, ИмяПоляИтератора);
		}
		// Заполняет массив-приемник уникальными значениями из массива-источника.
		// Если элемент в массиве-приемнике уже существует, то добавления нового элемента не происходит.
		//
		// Параметры:
		//  МассивПриемник – Массив – массив, который заполняется уникальными значениями
		//  МассивИсточник – Массив – массив, из которого подбираются элементы в массив-приемник.
		//

		public void ЗаполнитьМассивУникальнымиЗначениями(/*МассивПриемник, МассивИсточник*/)
		{
		}
		// Процедура удаляет из массива МассивРеквизитов элементы, соответствующие именам
		// реквизитов объекта из массива МассивНепроверяемыхРеквизитов.
		// Для использования в обработчиках события ОбработкаПроверкиЗаполнения.
		//
		// Параметры:
		//	МассивРеквизитов              - Массив - массив строк с именами реквизитов объекта.
		//	МассивНепроверяемыхРеквизитов - Массив строк с именами реквизитов объекта, не требующих проверки.
		//

		public void УдалитьНепроверяемыеРеквизитыИзМассива(/*МассивРеквизитов, МассивНепроверяемыхРеквизитов*/)
		{
		}
		//	Преобразует таблицу значений в массив.
		//	Может использоваться для передачи на клиента данных, полученных
		//	на сервере в виде таблицы значений в том случае, если таблица
		//	значений содержит только такие значения, которые могут
		//  быть переданы на клиента
		//
		//	Полученный массив содержит структуры, каждая из которых повторяет
		//	структуру колонок таблицы значений.
		//
		//	Не рекомендуется использовать для преобразования таблиц значений
		//	с большим количеством строк.
		//
		//	Параметры: ТаблицаЗначений
		//	Возвращаемое значение: Массив
		//

		public object ТаблицаЗначенийВМассив(/*ТаблицаЗначений*/)
		{
			//Массив = Новый Массив();
			//СтруктураСтрокой = "";
			//НужнаЗапятая = Ложь;
			return null;
		}
		// Функция СтрокаТаблицыЗначенийВСтруктуру создает
		// структуру со свойствами, как колонки таблицы
		// значений передаваемой строки
		// и устанавливает этим свойствам значения
		// из строки таблицы значений
		//
		// Параметры:
		//  СтрокаТаблицыЗначений - СтрокаТаблицыЗначений
		//
		// ВозвращаемоеЗначение:
		//  Структура
		//

		public object СтрокаТаблицыЗначенийВСтруктуру(/*СтрокаТаблицыЗначений*/)
		{
			//Структура = Новый Структура;
			return null;
		}
		// Получает строку, содержащую ключи структуры, разделенные символом разделителя.
		//
		// Параметры:
		//	Структура - Структура - Структура, ключи которой преобразуются в строку
		//	Разделитель - Строка - Разделитель, который вставляется в строку между ключами структуры
		//
		// Возвращаемое значение:
		//	Строка - Строка, содержащая ключи структуры разделенные резделителем
		//

		public object КлючиСтруктурыВСтроку(/*Структура, Разделитель = ","*/)
		{
			//Результат = "";
			return null;
		}
		// Преобразует текст формата XML в таблицу значений,
		// при этом колонки таблицы формируются на основе описания в XML.
		//
		// Параметры:
		//  ТекстXML     - текст в формате XML.
		//
		// Схема XML:
		//<?xml version="1.0" encoding="utf-8"?>
		//<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" xmlns:xs="http://www.w3.org/2001/XMLSchema">
		//  <xs:element name="Items">
		//	<xs:complexType>
		//	  <xs:sequence>
		//		<xs:element maxOccurs="unbounded" name="Item">
		//		  <xs:complexType>
		//			<xs:attribute name="Code" type="xs:integer" use="required" />
		//			<xs:attribute name="Name" type="xs:string" use="required" />
		//			<xs:attribute name="Socr" type="xs:string" use="required" />
		//			<xs:attribute name="Index" type="xs:string" use="required" />
		//		  </xs:complexType>
		//		</xs:element>
		//	  </xs:sequence>
		//	  <xs:attribute name="Description" type="xs:string" use="required" />
		//	  <xs:attribute name="Columns" type="xs:string" use="required" />
		//	</xs:complexType>
		//  </xs:element>
		//</xs:schema>
		//
		// Примеры XML-файлов см. в демонстрационной конфигурации.
		//
		// Пример использования:
		//   КлассификаторТаблица = ПрочитатьXMLВТаблицу(РегистрыСведений.АдресныйКлассификатор.
		//       ПолучитьМакет("КлассификаторАдресныхОбъектовРоссии").ПолучитьТекст());
		//
		// Возвращаемое значение:
		//  ТаблицаЗначений.
		//

		public object ПрочитатьXMLВТаблицу(/*ТекстXML*/)
		{
			//Чтение = Новый ЧтениеXML;
			//Чтение.УстановитьСтроку(ТекстXML);
			/*// Прочитаем первый узел и проверим его
*/
			if(true/*Не Чтение.Прочитать()*/)
			{
				//ВызватьИсключение("Пустой XML");
			}
			/*// Получим описание таблицы и создадим ее
*/
			//ИмяТаблицы = Чтение.ПолучитьАтрибут("Description");
			//ИменаКолонок = СтрЗаменить(Чтение.ПолучитьАтрибут("Columns"), ",", Символы.ПС);
			//Колонок = СтрЧислоСтрок(ИменаКолонок);
			//ТаблицаЗначений = Новый ТаблицаЗначений;
			/*// Заполним значения в таблице
*/
			while(true/*Чтение.Прочитать()*/)
			{
				if(true/*Чтение.ТипУзла <> ТипУзлаXML.НачалоЭлемента*/)
				{
				}
				//новСтр = ТаблицаЗначений.Добавить();
			}
			/*// Заполним результат
*/
			//Результат = Новый Структура;
			//Результат.Вставить("ИмяТаблицы", ИмяТаблицы);
			//Результат.Вставить("Данные", ТаблицаЗначений);
			return null;
		}
		// ПрочитатьXMLВТаблицу()
		// Возвращает признак того, что реквизит входит в подмножество стандартных реквизитов
		//
		// Параметры:
		//  СтандартныеРеквизиты – ОписанияСтандартныхРеквизитов - тип и значение описывает коллекцию настроек различных стандартных реквизитов;
		//  ИмяРеквизита – Строка – реквизит который необходимо проверить на принадлежность множеству стандартных реквизитов;
		//
		//  Возвращаемое значение:
		// Тип: Булево. Истина -  реквизит входит в подмножество стандартных реквизитов; Ложь – нет.
		//

		public object ЭтоСтандартныйРеквизит(/*СтандартныеРеквизиты, ИмяРеквизита*/)
		{
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// Общие процедуры и функции для работы с данными в базе
		// Проверяет проведенность документов
		//
		// Параметры:
		//  Документы - Массив - документы, проведенность которых необходимо проверить
		//
		// Возвращаемое значение:
		//  Массив - непроведенные документы из массива Документы
		//

		public object ПроверитьПроведенностьДокументов(/*знач Документы*/)
		{
			//Результат = Новый Массив;
			/*ШаблонЗапроса = 	
		"ВЫБРАТЬ
		|	Документ.Ссылка КАК Ссылка
		|ИЗ
		|	&ИмяДокумента КАК Документ
		|ГДЕ
		|	Документ.Ссылка В(&МассивДокументов)
		|	И (НЕ Документ.Проведен)";*/
			/*ТекстОбъединитьВсе =
		"
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|";*/
			//ИменаДокументов = Новый Массив;
			//ТекстЗапроса = "";
			//Запрос = Новый Запрос;
			//Запрос.Текст = ТекстЗапроса;
			//Запрос.УстановитьПараметр("МассивДокументов", Документы);
			if(true/*Не ПустаяСтрока(ТекстЗапроса)*/)
			{
				//Результат = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
			}
			return null;
		}
		// Процедура выполняет проведение документов перед формированием печатной формы.
		//
		// Параметры:
		//	Документы                - Массив - документы, которые необходимо провести
		//  ТипПроведенныхДокументов - Тип    - возвращает тип документов в массиве
		//
		// Возвращаемое значение:
		//	Массив - документы, которые провести не удалось, и описания ошибок.
		//

		public object ПровестиДокументы(/*Документы, ТипПроведенныхДокументов*/)
		{
			/*ИмяДокумента = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(
		Документы[0].Метаданные().ПолноеИмя(), ".")[1];*/
			//ТипПроведенныхДокументов = ТипЗнч(Документы[0]);
			//НепроведенныеДокументы = Новый Массив;
			return null;
		}
		// Возвращает структуру, содержащую значения реквизитов прочитанные из информационной базы
		// по ссылке на объект.
		//
		//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
		//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
		//  то следует использовать предварительный переход в привилегированный режим.
		//
		// Параметры:
		//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
		//  ИменаРеквизитов - Строка или Структура - если Строка, то имена реквизитов,
		//               перечисленные через запятую, в формате требований к свойствам структуры.
		//               Например, "Код, Наименование, Родитель".
		//               Если Структура, то в качестве ключа передается псевдоним поля для
		//               возвращаемой структуры с результатом, а в качестве значения (опционально)
		//               - фактическое имя поля в таблице.
		//               Если значение не определено, то имя поля берется из ключа.
		//
		// Возвращаемое значение:
		//  Структура    - содержит список свойств, как список имен в строке
		//                 ИменаРеквизитов, со значениям реквизитов, прочитанных
		//                 из информационной базы.
		//

		public object ПолучитьЗначенияРеквизитов(/*Ссылка, ИменаРеквизитов*/)
		{
			if(true/*ТипЗнч(ИменаРеквизитов) = Тип("Структура")*/)
			{
				//СтруктураРеквизитов = ИменаРеквизитов;
			}
			//ТекстПолей = "";
			/*Запрос = Новый Запрос(
		"ВЫБРАТЬ
		|" + ТекстПолей + "
		|ИЗ
		|	" + Ссылка.Метаданные().ПолноеИмя() + " КАК ПсевдонимЗаданнойТаблицы
		|ГДЕ
		|	ПсевдонимЗаданнойТаблицы.Ссылка = &Ссылка
		|");*/
			//Запрос.УстановитьПараметр("Ссылка", Ссылка);
			//Выборка = Запрос.Выполнить().Выбрать();
			//Выборка.Следующий();
			//Результат = Новый Структура;
			//ЗаполнитьЗначенияСвойств(Результат, Выборка);
			return null;
		}
		// Функция ПолучитьЗначениеРеквизита возвращает значение
		// реквизита, прочитанного из информационной базы по ссылке на объект.
		//
		//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
		//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
		//  то следует использовать предварительный переход в привилегированный режим.
		//
		// Параметры:
		//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
		//  ИмяРеквизита - Строка, например, "Код".
		//
		// Возвращаемое значение:
		//  Произвольный    - зависит от типа значения прочитанного реквизита.
		//

		public object ПолучитьЗначениеРеквизита(/*Ссылка, ИмяРеквизита*/)
		{
			//Результат = ПолучитьЗначенияРеквизитов(Ссылка, ИмяРеквизита);
			return null;
		}
		// Выполняет сравнение версий двух однотипных объектов.
		//
		//  Параметры:
		// Данные1 (обязательный). Тип:
		//  СправочникОбъект,
		//  ДокументОбъект,
		//  ПланВидовХарактеристикОбъект,
		//  ПланВидовРасчетаОбъект,
		//  ПланСчетовОбъект,
		//  ПланОбменаОбъект,
		//  БизнесПроцессОбъект,
		//  ЗадачаОбъект.
		// Первая версия данных для сравнения.
		//
		// Данные2 (обязательный). Тип: см. тип параметра Данные1
		// Вторая версия данных для сравнения.
		//
		// СписокСвойств (необязательный). Тип: Строка.
		// Список свойств объекта и табличных частей, разделенных запятыми.
		// Если параметр задан, то сравнение версий данных будет выполняться согласно
		// заданным свойствам, при этом параметр ИсключаяСвойства будет проигнорирован.
		//
		// ИсключаяСвойства (необязательный). Тип: Строка.
		// Список свойств объекта и табличных частей, разделенных запятыми.
		// Если параметр задан, то сравнение версий данных будет выполняться
		// для всех свойств и табличных частей, исключая заданные свойства.
		//
		// Возвращаемое значение:
		// Тип: Булево.
		// Возвращает Истина, если версии данных различаются; Ложь, если версии совпадают.
		//

		public object ДанныеРазличаются(/*Данные1, Данные2, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено*/)
		{
			if(true/*ТипЗнч(Данные1) <> ТипЗнч(Данные2)*/)
			{
			}
			//ОбъектМетаданных = Данные1.Метаданные();
			if(true/*ЭтоСправочник(ОбъектМетаданных)*/)
			{
				if(true/*Данные1.ЭтоГруппа*/)
				{
					//Объект1 = Справочники[ОбъектМетаданных.Имя].СоздатьГруппу();
				}
				if(true/*Данные2.ЭтоГруппа*/)
				{
					//Объект2 = Справочники[ОбъектМетаданных.Имя].СоздатьГруппу();
				}
			}
			//ЗаполнитьЗначенияСвойств(Объект1, Данные1, СписокСвойств, ИсключаяСвойства);
			//ЗаполнитьЗначенияСвойств(Объект2, Данные2, СписокСвойств, ИсключаяСвойства);
			//ТабличныеЧасти = ТабличныеЧастиОбъекта(ОбъектМетаданных);
			if(true/*СписокСвойств <> Неопределено*/)
			{
			}
			return null;
		}

		public object ДанныеИнформационнойБазыСтрокой(/*Данные*/)
		{
			//ЗаписьXML = Новый ЗаписьXML;
			//ЗаписьXML.УстановитьСтроку();
			//ЗаписатьXML(ЗаписьXML, Данные, НазначениеТипаXML.Явное);
			return null;
		}

		public object ТабличныеЧастиОбъекта(/*ОбъектМетаданных*/)
		{
			//Результат = Новый Массив;
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// Процедуры и функции для работы с внешним соединением
		// Возвращает имя COM-класса для работы с 1С:Предприятием 8 через COM-соединение.
		//

		public object ИмяCOMСоединителя(/**/)
		{
			//СистемнаяИнфо = Новый СистемнаяИнформация;
			/*ПодстрокиВерсии = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(
		СистемнаяИнфо.ВерсияПриложения, ".");*/
			return null;
		}
		// Устанавливает внешнее соединение с информационной базой по переданным параметрам подключения и возвращает указатель на это соединение
		//
		// Параметры:
		//  Параметры - Структура - содержит параметры для установки внешнего соединения с информационной базой.
		//  Структура должна содержать следующие ключи (см. функция ОбщегоНазначенияКлиентСервер.СтруктураПараметровДляУстановкиВнешнегоСоединения):
		//
		//	  ВариантРаботыИнформационнойБазы             - (Число)  Вариант работы информационной базы: 0 – файловый; 1 – клиент-серверный
		//	  КаталогИнформационнойБазы                   - (Строка) Каталог информационной базы для файлового режима работы
		//	  ИмяСервера1СПредприятия                     - (Строка) Имя сервера1С:Предприятия
		//	  ИмяИнформационнойБазыНаСервере1СПредприятия - (Строка) Имя информационной базы на сервере1С:Предприятия
		//	  АутентификацияОперационнойСистемы           - (Булево) Признак аутентификации операционной системы при создании внешнего подключения к информационной базе
		//	  ИмяПользователя                             - (Строка) Имя пользователя информационной базы
		//	  ПарольПользователя                          - (Строка) Пароль пользователя информационной базы
		//
		//  СтрокаСообщенияОбОшибке (необязательный) – Строка – если в процессе установки внешнего соединения возникает ошибка,
		//                                                     то подробное описание ошибки помещается в этот параметр
		//
		// Возвращаемое значение:
		//  Тип: COM-объект, Неопределенно.
		//  в случае успешной установки внешнего соединения возвращается указатель на COM-объект соединения;
		//  в случае ошибки возвращается Неопределенно.
		//

		public object УстановитьВнешнееСоединение(/*Параметры, СтрокаСообщенияОбОшибке = "", ОшибкаПодключенияКомпоненты = Ложь*/)
		{
			/*// возвращаемое значение функции (COM-объект)
*/
			//Connection = Неопределено;
			if(true/*Параметры.ВариантРаботыИнформационнойБазы = 0*/)
			{
				if(true/*ПустаяСтрока(Параметры.КаталогИнформационнойБазы)*/)
				{
					//СтрокаСообщенияОбОшибке = НСтр("ru = 'Не задано месторасположение каталога информационной базы.'");
				}
				if(true/*Параметры.АутентификацияОперационнойСистемы*/)
				{
					//СтрокаСоединения = "File = ""&КаталогИнформационнойБазы""";
					//СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&КаталогИнформационнойБазы", Параметры.КаталогИнформационнойБазы);
				}
			}
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// Функции для работы с журналом регистрации
		// Процедура пакетной записи сообщений в журнал регистрации
		//
		// Параметры: СобытияДляЖурналаРегистрации - массив структур, клиентская глобальная переменная
		// Каждая структура - сообщение для журнала регистрации.
		// После записи переменная очищается.

		public void ЗаписатьСобытияВЖурналРегистрации(/*СобытияДляЖурналаРегистрации*/)
		{
			if(true/*ТипЗнч(СобытияДляЖурналаРегистрации) <> Тип("СписокЗначений")*/)
			{
			}
			if(true/*СобытияДляЖурналаРегистрации.Количество() = 0*/)
			{
			}
			//СобытияДляЖурналаРегистрации.Очистить();
		}
		// Процедура ведения в журнале регистрации событий
		//
		// Параметры: СписокУровней - список значений,
		// Наименования уровней регистрации событий, которые необходимо включить

		public void ВключитьИспользованиеЖурналаРегистрации(/*СписокУровней = Неопределено*/)
		{
			//УстановитьПривилегированныйРежим(Истина);
			//УстановитьПривилегированныйРежим(Ложь);
		}
		// Проверяет, включена ли регистрация событий в журнале регистрации
		//
		// Параметры:
		// СписокПроверок - СписокЗначений, список строк-представлений режимов использования журнала регистрации, которые надо проверить на включение.
		//					Если Неопределено - тогда проверяются все режимы.
		//
		// Возвращаемое значение: Истина, когда заданные режимы включены. Иначе - ложь.

		public object ПроверитьВключениеЖурналаРегистрации(/*СписокПроверок = Неопределено*/)
		{
			//МассивРежимов = ПолучитьИспользованиеЖурналаРегистрации();
			if(true/*СписокПроверок = Неопределено*/)
			{
				//Возврат МассивРежимов.Количество() = 4;
			}
			return null;
		}

		public object УровеньСобытияПоПредставлению(/*ПредставлениеУровня*/)
		{
			if(true/*ПредставлениеУровня = "Информация"*/)
			{
			}
			return null;
		}

		public object УровниСобытияЖурналаРегистрацииПоСтроке(/*СписокУровней*/)
		{
			//МассивНазванийУровней = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СписокУровней);
			//МассивУровней = Новый Массив;
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// Процедуры и функции для работы с типами, объектами метаданных и их строковыми представлениями.
		// Получает дерево метаданных конфигурации с заданным отбором по объектам метаданных.
		//
		// Параметры:
		// Отбор – Структура – содержит значения элементов отбора.
		//						Если параметр задан, то будет получено дерево метаданных в соответствии с заданным отбором.
		//						Ключ (Строка) – имя свойства элемента метаданных;
		//						Значение (Массив) – множество значений для отбора.
		//
		// Пример инициализации переменной "Отбор":
		//
		// Массив = Новый Массив;
		// Массив.Добавить("Константа.ИспользоватьОбменДанными");
		// Массив.Добавить("Справочник.Валюты");
		// Массив.Добавить("Справочник.Организации");
		// Отбор = Новый Структура;
		// Отбор.Вставить("ПолноеИмя", Массив);
		//
		//  Возвращаемое значение:
		//  Тип: ДеревоЗначений - дерево описания метаданных конфигурации
		//

		public object ПолучитьДеревоМетаданныхКонфигурации(/*Отбор = Неопределено*/)
		{
			//ИспользоватьОтбор = (Отбор <> Неопределено);
			//КоллекцииОбъектовМетаданных = Новый ТаблицаЗначений;
			//КоллекцииОбъектовМетаданных.Колонки.Добавить("Имя");
			//КоллекцииОбъектовМетаданных.Колонки.Добавить("Синоним");
			//КоллекцииОбъектовМетаданных.Колонки.Добавить("Картинка");
			//КоллекцииОбъектовМетаданных.Колонки.Добавить("КартинкаОбъекта");
			//НоваяСтрокаКоллекцииОбъектовМетаданных("Константы",               "Константы",                 БиблиотекаКартинок.Константа,              БиблиотекаКартинок.Константа,                    КоллекцииОбъектовМетаданных);
			//НоваяСтрокаКоллекцииОбъектовМетаданных("Справочники",             "Справочники",               БиблиотекаКартинок.Справочник,             БиблиотекаКартинок.Справочник,                   КоллекцииОбъектовМетаданных);
			//НоваяСтрокаКоллекцииОбъектовМетаданных("Документы",               "Документы",                 БиблиотекаКартинок.Документ,               БиблиотекаКартинок.ДокументОбъект,               КоллекцииОбъектовМетаданных);
			//НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыВидовХарактеристик", "Планы видов характеристик", БиблиотекаКартинок.ПланВидовХарактеристик, БиблиотекаКартинок.ПланВидовХарактеристикОбъект, КоллекцииОбъектовМетаданных);
			//НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыСчетов",             "Планы счетов",              БиблиотекаКартинок.ПланСчетов,             БиблиотекаКартинок.ПланСчетовОбъект,             КоллекцииОбъектовМетаданных);
			//НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыВидовРасчета",       "Планы видов характеристик", БиблиотекаКартинок.ПланВидовХарактеристик, БиблиотекаКартинок.ПланВидовХарактеристикОбъект, КоллекцииОбъектовМетаданных);
			//НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыСведений",        "Регистры сведений",         БиблиотекаКартинок.РегистрСведений,        БиблиотекаКартинок.РегистрСведений,              КоллекцииОбъектовМетаданных);
			//НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыНакопления",      "Регистры накопления",       БиблиотекаКартинок.РегистрНакопления,      БиблиотекаКартинок.РегистрНакопления,            КоллекцииОбъектовМетаданных);
			//НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыБухгалтерии",     "Регистры бухгалтерии",      БиблиотекаКартинок.РегистрБухгалтерии,     БиблиотекаКартинок.РегистрБухгалтерии,           КоллекцииОбъектовМетаданных);
			//НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыРасчета",         "Регистры расчета",          БиблиотекаКартинок.РегистрРасчета,         БиблиотекаКартинок.РегистрРасчета,               КоллекцииОбъектовМетаданных);
			//НоваяСтрокаКоллекцииОбъектовМетаданных("БизнесПроцессы",          "Бизнес-процессы",           БиблиотекаКартинок.БизнесПроцесс,          БиблиотекаКартинок.БизнесПроцессОбъект,          КоллекцииОбъектовМетаданных);
			//НоваяСтрокаКоллекцииОбъектовМетаданных("Задачи",                  "Задачи",                    БиблиотекаКартинок.Задача,                 БиблиотекаКартинок.ЗадачаОбъект,                 КоллекцииОбъектовМетаданных);
			/*// возвращаемое значение функции
*/
			//ДеревоМетаданных = Новый ДеревоЗначений;
			//ДеревоМетаданных.Колонки.Добавить("Имя");
			//ДеревоМетаданных.Колонки.Добавить("ПолноеИмя");
			//ДеревоМетаданных.Колонки.Добавить("Синоним");
			//ДеревоМетаданных.Колонки.Добавить("Картинка");
			/*// удаляем строки без подчиненных элементов
*/
			if(true/*ИспользоватьОтбор*/)
			{
				/*// используем обратный порядок обхода дерева значений
*/
				//КолвоЭлементовКоллекции = ДеревоМетаданных.Строки.Количество();
			}
			return null;
		}

		public void НоваяСтрокаКоллекцииОбъектовМетаданных(/*Имя, Синоним, Картинка, КартинкаОбъекта, Таб*/)
		{
			//НоваяСтрока = Таб.Добавить();
			//НоваяСтрока.Имя               = Имя;
			//НоваяСтрока.Синоним           = Синоним;
			//НоваяСтрока.Картинка          = Картинка;
			//НоваяСтрока.КартинкаОбъекта   = КартинкаОбъекта;
		}
		// Возвращает строку реквизитов объекта метаданных с заданным типом
		//
		// Параметры:
		//  Ссылка – ЛюбаяСсылка – ссылка на элемент базы данных, для которого требуется получить результат функции
		//  Тип    – Тип – тип значения реквизита
		//
		//  Возвращаемое значение:
		// Тип: Строка – строка реквизитов объекта метаданных конфигурации, разделенные символом ","
		//

		public object ИменаРеквизитовПоТипу(/*Ссылка, Тип*/)
		{
			//Результат = "";
			//МетаданныеОбъекта = Ссылка.Метаданные();
			return null;
		}
		// Получает имя значения перечисления как объекта метаданных
		//
		// Параметры:
		//  Значение - значение перечисления для которого необходимо получить имя перечисления
		//
		// Возвращаемое значение:
		//  Строка - имя значения перечисления как объекта метаданных
		//

		public object ИмяЗначенияПеречисления(/*Значение*/)
		{
			//ОбъектМетаданных = Значение.Метаданные();
			//ИндексЗначения = Перечисления[ОбъектМетаданных.Имя].Индекс(Значение);
			return null;
		}
		// Возвращает имя базового типа по переданному значению объекта метаданных
		//
		// Параметры:
		//  ОбъектМетаданных - объект метаданных, по которому необходимо определить базовый тип
		//
		// Возвращаемое значение:
		//  Строка - имя базового типа по переданному значению объекта метаданных
		//

		public object ИмяБазовогоТипаПоОбъектуМетаданных(/*ОбъектМетаданных*/)
		{
			if(true/*Метаданные.Документы.Содержит(ОбъектМетаданных)*/)
			{
			}
			return null;
		}
		// Возвращает менеджер объекта по полному имени объекта метаданных
		//
		// Не обрабатываются точки маршрутов бизнес-процессов
		//
		// Параметры:
		//  ПолноеИмя    - Строка, полное имя объекта метаданных,
		//                 например, "Справочник.Организации"
		//
		// Возвращаемое значение:
		//  СправочникМенеджер, ДокументМенеджер, ...
		//

		public object МенеджерОбъектаПоПолномуИмени(/*ПолноеИмя*/)
		{
			//ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмя, ".");
			//КлассОМ = ЧастиИмени[0];
			//ИмяОМ   = ЧастиИмени[1];
			if(true/*ВРег(КлассОМ) = "ПЛАНОБМЕНА"*/)
			{
			}
			return null;
		}
		// Возвращает менеджер объекта по ссылке на объект
		//
		// Не обрабатываются точки маршрутов бизнес-процессов
		//
		// Параметры:
		//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
		//
		// Возвращаемое значение:
		//  СправочникМенеджер, ДокументМенеджер, ...
		//

		public object МенеджерОбъектаПоСсылке(/*Ссылка*/)
		{
			//ИмяОбъекта = Ссылка.Метаданные().Имя;
			//ТипСсылки = ТипЗнч(Ссылка);
			if(true/*Справочники.ТипВсеСсылки().СодержитТип(ТипСсылки)*/)
			{
			}
			return null;
		}
		// Проверяет физическое наличие записи в информационной базе данных о переданном значении ссылки
		//
		// Параметры:
		//  ЛюбаяСсылка - значение любой ссылки информационной базы данных
		//
		// Возвращаемое значение:
		//  Истина - ссылка физически существует;
		//  Ложь   - ссылка физически не существует
		//

		public object СсылкаСуществует(/*ЛюбаяСсылка*/)
		{
			/*ТекстЗапроса = "
		|ВЫБРАТЬ
		|	Ссылка
		|ИЗ
		|	[ИмяТаблицы]
		|ГДЕ
		|	Ссылка = &Ссылка
		|";*/
			//ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ИмяТаблицы]", ИмяТаблицыПоСсылке(ЛюбаяСсылка));
			//Запрос = Новый Запрос;
			//Запрос.Текст = ТекстЗапроса;
			//Запрос.УстановитьПараметр("Ссылка", ЛюбаяСсылка);
			//УстановитьПривилегированныйРежим(Истина);
			return null;
		}
		// Функция ВидОбъектаПоСсылке возвращает имя вида объектов метаданных
		// по ссылке на объект.
		//
		// Не обрабатываются точки маршрутов бизнес-процессов.
		//
		// Параметры:
		//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
		//
		// Возвращаемое значение:
		//  Строка       - имя вида объектов метаданных, например, "Справочник", "Документ" ...
		//

		public object ВидОбъектаПоСсылке(/*Ссылка*/)
		{
			return null;
		}
		// Функция возвращает имя вида объектов метаданных по типу объекта.
		//
		// Не обрабатываются точки маршрутов бизнес-процессов.
		//
		// Параметры:
		//  Тип       - Тип прикладного объекта, определенный в конфигурации
		//
		// Возвращаемое значение:
		//  Строка       - имя вида объектов метаданных, например, "Справочник", "Документ" ...
		//

		public object ВидОбъектаПоТипу(/*Тип*/)
		{
			if(true/*Справочники.ТипВсеСсылки().СодержитТип(Тип)*/)
			{
			}
			return null;
		}
		// Возвращает полное имя объекта метаданных по переданному значению ссылки
		// Например,
		//  "Справочник.Номенклатура";
		//  "Документ.ПриходнаяНакладная"
		//
		// Параметры:
		//  Ссылка - ЛюбаяСсылка - значение ссылки, для которого необходимо получить имя таблицы ИБ
		//
		// Возвращаемое значение:
		//  Строка - полное имя объекта метаданных для указанного значения ссылки
		//

		public object ИмяТаблицыПоСсылке(/*Ссылка*/)
		{
			return null;
		}
		// Возвращает строковое представление типа.
		// Для ссылочных типов возвращает в формате "СправочникСсылка.ИмяОбъекта" или "ДокументСсылка.ИмяОбъекта"
		// Для остальных типов приводит тип к строке, например "Число".
		//

		public object СтроковоеПредставлениеТипа(/*Тип*/)
		{
			//Представление = "";
			if(true/*ЭтоСсылка(Тип)*/)
			{
				//ПолноеИмя = Метаданные.НайтиПоТипу(Тип).ПолноеИмя();
				//ИмяОбъекта = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмя, ".")[1];
				if(true/*Справочники.ТипВсеСсылки().СодержитТип(Тип)*/)
				{
					//Представление = "СправочникСсылка";
				}
				//Результат = ?(Представление = "", Представление, Представление + "." + ИмяОбъекта);
			}
			return null;
		}
		// Проверить, что значение имеет ссылочный тип данных.
		//
		// Параметры:
		//  Значение       - ссылка на объект, - элемент справочника, документ, ...
		//
		// Возвращаемое значение:
		//  Булево       - Истина, если тип значения ссылочный.
		//

		public object ЗначениеСсылочногоТипа(/*Значение*/)
		{
			if(true/*Значение = Неопределено*/)
			{
			}
			if(true/*Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение))*/)
			{
			}
			if(true/*Документы.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение))*/)
			{
			}
			if(true/*Перечисления.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение))*/)
			{
			}
			if(true/*ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение))*/)
			{
			}
			if(true/*ПланыСчетов.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение))*/)
			{
			}
			if(true/*ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение))*/)
			{
			}
			if(true/*БизнесПроцессы.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение))*/)
			{
			}
			if(true/*БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(ТипЗнч(Значение))*/)
			{
			}
			if(true/*Задачи.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение))*/)
			{
			}
			if(true/*ПланыОбмена.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение))*/)
			{
			}
			return null;
		}
		// Проверка того, что тип имеет ссылочный тип данных
		//

		public object ЭтоСсылка(/*Тип*/)
		{
			return null;
		}
		// Является ли объект группой
		// В качестве параметра может принимать только справочник или ПВХ
		//

		public object ОбъектЯвляетсяГруппой(/*Объект*/)
		{
			//МетаданныеОбъекта = Объект.Метаданные();
			if(true/*ЭтоСправочник(МетаданныеОбъекта)
	И НЕ (МетаданныеОбъекта.Иерархический И МетаданныеОбъекта.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов)*/)
			{
			}
			if(true/*ЗначениеСсылочногоТипа(Объект)*/)
			{
			}
			//Ссылка = Объект.Ссылка;
			if(true/*Не ЗначениеЗаполнено(Ссылка)*/)
			{
			}
			return null;
		}
		// Проверяет наличие табличной части у справочника
		//
		//Параметры
		//  ИмяСправочника    - Строка - имя справочника, для которого осуществляется проверка.
		//  ИмяТабличнойЧасти - Строка - имя табличной части, наличие которой проверяется.
		//
		//Возвращаемое значение:
		//  Булево   - Истина, если табличная часть есть, ложь в обратном случае
		//
		//Пример:
		//  Если НЕ ОбщегоНазначения.НаличиеТабличнойЧастиУСправочника(ИмяСправочника,"КонтактнаяИнформация") Тогда
		//  	Возврат;
		//  КонецЕсли;
		//

		public object НаличиеТабличнойЧастиУСправочника(/*ИмяСправочника,ИмяТабличнойЧасти*/)
		{
			return null;
		}
		// Возвращает описание предмета в виде текстовой строки.
		//
		// Параметры
		//  СсылкаНаПредмет  – ЛюбаяСсылка – объект ссылочного типа.
		//
		// Возвращаемое значение:
		//   Строка
		//

		public object ПредметСтрокой(/*СсылкаНаПредмет*/)
		{
			//Результат = "";
			//СтандартныеПодсистемыПереопределяемый.УстановитьПредставлениеПредмета(СсылкаНаПредмет, Результат);
			//ОбщегоНазначенияПереопределяемый.УстановитьПредставлениеПредмета(СсылкаНаПредмет, Результат);
			if(true/*ПустаяСтрока(Результат)*/)
			{
				if(true/*СсылкаНаПредмет = Неопределено или СсылкаНаПредмет.Пустая()*/)
				{
					//Результат = НСтр("ru = 'не задан'");
				}
			}
			return null;
		}
		// Формирует расширенное представление объекта.
		// Расширенное представление объекта складывается из представления объекта, кода и наименования.
		// Если для объекта не удалось получить расширенное представление,
		// то возвращается стандартное представление объекта, формируемое платформой.
		//
		// Пример возвращаемого значения функции:
		// "Контрагент 0А-0001234, ООО Телекоммуникационные системы"
		//
		//  Параметры:
		// Объект. Тип: СправочникСсылка,
		//				ПланСчетовСсылка,
		//				ПланОбменаСсылка,
		//				ПланВидовХарактеристикСсылка,
		//				ПланВидовРасчетаСсылка.
		// Объект, для которого требуется получить расширенное представление.
		//
		//  Возвращаемое значение:
		// Тип. Строка.
		// Расширенное представление объекта.
		//

		public object РасширенноеПредставлениеОбъекта(/*Объект*/)
		{
			//ОбъектМетаданных = Объект.Метаданные();
			//ИмяБазовогоТипа = ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных);
			if(true/*ИмяБазовогоТипа = ИмяТипаСправочники()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыСчетов()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыОбмена()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовХарактеристик()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовРасчета()*/)
			{
				if(true/*ЭтоСтандартныйРеквизит(ОбъектМетаданных.СтандартныеРеквизиты, "Код")
			И ЭтоСтандартныйРеквизит(ОбъектМетаданных.СтандартныеРеквизиты, "Наименование")*/)
				{
					//ЗначенияРеквизитов = ПолучитьЗначенияРеквизитов(Объект, "Код, Наименование");
					/*ПредставлениеОбъекта = ?(ПустаяСтрока(ОбъектМетаданных.ПредставлениеОбъекта), 
										?(ПустаяСтрока(ОбъектМетаданных.Синоним), ОбъектМетаданных.Имя, ОбъектМетаданных.Синоним
										),
									ОбъектМетаданных.ПредставлениеОбъекта
			);*/
					//Результат = "[ПредставлениеОбъекта] [Код], [Наименование]";
					//Результат = СтрЗаменить(Результат, "[ПредставлениеОбъекта]", ПредставлениеОбъекта);
					//Результат = СтрЗаменить(Результат, "[Код]",          ?(ПустаяСтрока(ЗначенияРеквизитов.Код), "<>", ЗначенияРеквизитов.Код));
					//Результат = СтрЗаменить(Результат, "[Наименование]", ?(ПустаяСтрока(ЗначенияРеквизитов.Наименование), "<>", ЗначенияРеквизитов.Наименование));
				}
			}
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// Функции определения типов объектов метаданных
		// Ссылочные типы данных
		// Определяет принадлежность объекта метаданных к общему типу "Документ"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоДокумент(/*ОбъектМетаданных*/)
		{
			//Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаДокументы();
			return null;
		}
		// Определяет принадлежность объекта метаданных к общему типу "Справочник"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоСправочник(/*ОбъектМетаданных*/)
		{
			//Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаСправочники();
			return null;
		}
		// Определяет принадлежность объекта метаданных к общему типу "Перечисление"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоПеречисление(/*ОбъектМетаданных*/)
		{
			//Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПеречисления();
			return null;
		}
		// Определяет принадлежность объекта метаданных к общему типу "План обмена"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоПланОбмена(/*ОбъектМетаданных*/)
		{
			//Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПланыОбмена();
			return null;
		}
		// Определяет принадлежность объекта метаданных к общему типу "План видов характеристик"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоПланВидовХарактеристик(/*ОбъектМетаданных*/)
		{
			//Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПланыВидовХарактеристик();
			return null;
		}
		// Определяет принадлежность объекта метаданных к общему типу "Бизнес-процесс"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоБизнесПроцесс(/*ОбъектМетаданных*/)
		{
			//Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаБизнесПроцессы();
			return null;
		}
		// Определяет принадлежность объекта метаданных к общему типу "Задача"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоЗадача(/*ОбъектМетаданных*/)
		{
			//Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаЗадачи();
			return null;
		}
		// Определяет принадлежность объекта метаданных к общему типу "План счетов"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоПланСчетов(/*ОбъектМетаданных*/)
		{
			//Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПланыСчетов();
			return null;
		}
		// Определяет принадлежность объекта метаданных к общему типу "План видов расчета"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоПланВидовРасчета(/*ОбъектМетаданных*/)
		{
			//Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПланыВидовРасчета();
			return null;
		}
		// Регистры
		// Определяет принадлежность объекта метаданных к общему типу "Регистр сведений"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоРегистрСведений(/*ОбъектМетаданных*/)
		{
			//Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегистрыСведений();
			return null;
		}
		// Определяет принадлежность объекта метаданных к общему типу "Регистр накопления"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоРегистрНакопления(/*ОбъектМетаданных*/)
		{
			//Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегистрыНакопления();
			return null;
		}
		// Определяет принадлежность объекта метаданных к общему типу "Регистр бухгалтерии"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоРегистрБухгалтерии(/*ОбъектМетаданных*/)
		{
			//Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегистрыБухгалтерии();
			return null;
		}
		// Определяет принадлежность объекта метаданных к общему типу "Регистр расчета"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоРегистрРасчета(/*ОбъектМетаданных*/)
		{
			//Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегистрыРасчета();
			return null;
		}
		// Константы
		// Определяет принадлежность объекта метаданных к общему типу "Константа"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоКонстанта(/*ОбъектМетаданных*/)
		{
			//Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаКонстанты();
			return null;
		}
		// Журналы документов
		// Определяет принадлежность объекта метаданных к общему типу "Журнал документов"
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоЖурналДокументов(/*ОбъектМетаданных*/)
		{
			//Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаЖурналыДокументов();
			return null;
		}
		// Общие
		// Определяет принадлежность объекта метаданных к типу регистр
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоРегистр(/*ОбъектМетаданных*/)
		{
			//ИмяБазовогоТипа = ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных);
			/*Возврат ИмяБазовогоТипа = ИмяТипаРегистрыСведений()
		ИЛИ ИмяБазовогоТипа = ИмяТипаРегистрыНакопления()
		ИЛИ ИмяБазовогоТипа = ИмяТипаРегистрыБухгалтерии()
		ИЛИ ИмяБазовогоТипа = ИмяТипаРегистрыРасчета();*/
			return null;
		}
		// Определяет принадлежность объекта метаданных к ссылочному типу
		//
		// Параметры:
		//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
		//
		//  Возвращаемое значение:
		//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
		//

		public object ЭтоОбъектСсылочногоТипа(/*ОбъектМетаданных*/)
		{
			//ИмяБазовогоТипа = ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных);
			/*Возврат ИмяБазовогоТипа = ИмяТипаСправочники()
		ИЛИ ИмяБазовогоТипа = ИмяТипаДокументы()
		ИЛИ ИмяБазовогоТипа = ИмяТипаБизнесПроцессы()
		ИЛИ ИмяБазовогоТипа = ИмяТипаЗадачи()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыСчетов()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыОбмена()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовХарактеристик()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовРасчета();*/
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// Имена типов.
		// Возвращает значение для идентификации общего типа "Регистры сведений"
		//
		// Тип: Строка
		//

		public object ИмяТипаРегистрыСведений(/**/)
		{
			return null;
		}
		// Возвращает значение для идентификации общего типа "Регистры накопления"
		//
		// Тип: Строка
		//

		public object ИмяТипаРегистрыНакопления(/**/)
		{
			return null;
		}
		// Возвращает значение для идентификации общего типа "Регистры бухгалтерии"
		//
		// Тип: Строка
		//

		public object ИмяТипаРегистрыБухгалтерии(/**/)
		{
			return null;
		}
		// Возвращает значение для идентификации общего типа "Регистры расчета"
		//
		// Тип: Строка
		//

		public object ИмяТипаРегистрыРасчета(/**/)
		{
			return null;
		}
		// Возвращает значение для идентификации общего типа "Документы"
		//
		// Тип: Строка
		//

		public object ИмяТипаДокументы(/**/)
		{
			return null;
		}
		// Возвращает значение для идентификации общего типа "Справочники"
		//
		// Тип: Строка
		//

		public object ИмяТипаСправочники(/**/)
		{
			return null;
		}
		// Возвращает значение для идентификации общего типа "Перечисления"
		//
		// Тип: Строка
		//

		public object ИмяТипаПеречисления(/**/)
		{
			return null;
		}
		// Возвращает значение для идентификации общего типа "ПланыОбмена"
		//
		// Тип: Строка
		//

		public object ИмяТипаПланыОбмена(/**/)
		{
			return null;
		}
		// Возвращает значение для идентификации общего типа "Планы видов характеристик"
		//
		// Тип: Строка
		//

		public object ИмяТипаПланыВидовХарактеристик(/**/)
		{
			return null;
		}
		// Возвращает значение для идентификации общего типа "Бизнес-процессы"
		//
		// Тип: Строка
		//

		public object ИмяТипаБизнесПроцессы(/**/)
		{
			return null;
		}
		// Возвращает значение для идентификации общего типа "Задачи"
		//
		// Тип: Строка
		//

		public object ИмяТипаЗадачи(/**/)
		{
			return null;
		}
		// Возвращает значение для идентификации общего типа "Планы счетов"
		//
		// Тип: Строка
		//

		public object ИмяТипаПланыСчетов(/**/)
		{
			return null;
		}
		// Возвращает значение для идентификации общего типа "Планы видов расчета"
		//
		// Тип: Строка
		//

		public object ИмяТипаПланыВидовРасчета(/**/)
		{
			return null;
		}
		// Возвращает значение для идентификации общего типа "Константы"
		//
		// Тип: Строка
		//

		public object ИмяТипаКонстанты(/**/)
		{
			return null;
		}
		// Возвращает значение для идентификации общего типа "Журналы документов"
		//
		// Тип: Строка
		//

		public object ИмяТипаЖурналыДокументов(/**/)
		{
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		//  Сохранение и чтение настроек
		// Сохраняет массив пользовательских настроек МассивСтруктур.
		// Может применяться для случаев вызова с клиента.
		//
		// Параметры:
		//    МассивСтруктур - Массив - массив структур с полями "Объект", "Настройка", "Значение".
		//    НужноОбновитьПовторноИспользуемыеЗначения - Булево - требуется обновить повторно используемые значения
		//

		public void ХранилищеОбщихНастроекСохранитьМассив(/*МассивСтруктур, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь*/)
		{
			if(true/*Не ПравоДоступа("СохранениеДанныхПользователя", Метаданные)*/)
			{
			}
			if(true/*НужноОбновитьПовторноИспользуемыеЗначения*/)
			{
				//ОбновитьПовторноИспользуемыеЗначения();
			}
		}
		// Сохраняет массив пользовательских настроек МассивСтруктур и
		// обновляет повторно используемые значения.
		// Может применяться для случаев вызова с клиента.
		//
		// Параметры:
		//    МассивСтруктур - Массив - массив структур с полями "Объект", "Настройка", "Значение".
		//

		public void ХранилищеОбщихНастроекСохранитьМассивИОбновитьПовторноИспользуемыеЗначения(/*МассивСтруктур*/)
		{
			//ХранилищеОбщихНастроекСохранитьМассив(МассивСтруктур, Истина);
		}
		// Сохраняет пользовательскую настройку по имени.
		//
		// Параметры:
		//    соответствуют методу ХранилищеОбщихНастроек.Сохранить
		//

		public void ХранилищеОбщихНастроекСохранить(/*КлючОбъекта, КлючНастроек = Неопределено, Значение,
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь*/)
		{
			if(true/*НЕ ПравоДоступа("СохранениеДанныхПользователя", Метаданные)*/)
			{
			}
			//ХранилищеОбщихНастроек.Сохранить(КлючОбъекта, КлючНастроек, Значение, ОписаниеНастроек, ИмяПользователя);
			if(true/*НужноОбновитьПовторноИспользуемыеЗначения*/)
			{
				//ОбновитьПовторноИспользуемыеЗначения();
			}
		}
		// Сохраняет пользовательскую настройку по имени и
		// обновляет повторно используемые значения.
		//
		// Параметры:
		//    соответствуют методу ХранилищеОбщихНастроек.Сохранить
		//

		public void ХранилищеОбщихНастроекСохранитьИОбновитьПовторноИспользуемыеЗначения(/*КлючОбъекта, КлючНастроек, Значение*/)
		{
			//ХранилищеОбщихНастроекСохранить(КлючОбъекта, КлючНастроек, Значение,,,Истина);
		}
		// Возвращает значение пользовательской настройки по имени.
		//
		// Параметры:
		//    соответствуют методу ХранилищеОбщихНастроек.Загрузить
		//

		public object ХранилищеОбщихНастроекЗагрузить(/*КлючОбъекта, КлючНастроек = Неопределено, ЗначениеПоУмолчанию = Неопределено, 
		ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено*/)
		{
			//Результат = Неопределено;
			if(true/*ПравоДоступа("СохранениеДанныхПользователя", Метаданные)*/)
			{
				//Результат = ХранилищеОбщихНастроек.Загрузить(КлючОбъекта, КлючНастроек, ОписаниеНастроек, ИмяПользователя);
			}
			if(true/*(Результат = Неопределено) И (ЗначениеПоУмолчанию <> Неопределено)*/)
			{
				//Результат = ЗначениеПоУмолчанию;
			}
			return null;
		}
		// Сохраняет пользовательскую настройку по имени.
		//
		// Параметры:
		//    соответствуют методу ХранилищеНастроекДанныхФорм.Сохранить
		//

		public void ХранилищеНастроекДанныхФормСохранить(/*КлючОбъекта, КлючНастроек = Неопределено, Значение,
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь*/)
		{
			/*ХранилищеСохранить(
		ХранилищеНастроекДанныхФорм, 
		КлючОбъекта, 
		КлючНастроек, 
		Значение,
		ОписаниеНастроек, 
		ИмяПользователя, 
		НужноОбновитьПовторноИспользуемыеЗначения
	);*/
		}
		// Возвращает значение пользовательской настройки по имени.
		//
		// Параметры:
		//    соответствуют методу ХранилищеНастроекДанныхФорм.Загрузить
		//

		public object ХранилищеНастроекДанныхФормЗагрузить(/*КлючОбъекта, КлючНастроек = Неопределено, ЗначениеПоУмолчанию = Неопределено, 
		ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено*/)
		{
			/*Возврат ХранилищеЗагрузить(
		ХранилищеНастроекДанныхФорм, 
		КлючОбъекта, 
		КлючНастроек = Неопределено, 
		ЗначениеПоУмолчанию = Неопределено, 
		ОписаниеНастроек = Неопределено, 
		ИмяПользователя = Неопределено
	);*/
			return null;
		}
		// Сохраняет пользовательскую настройку по имени.
		//

		public void ХранилищеСохранить(/*МенеджерХранилища, КлючОбъекта, КлючНастроек, Значение,
	ОписаниеНастроек, ИмяПользователя, НужноОбновитьПовторноИспользуемыеЗначения*/)
		{
			if(true/*НЕ ПравоДоступа("СохранениеДанныхПользователя", Метаданные)*/)
			{
			}
			//МенеджерХранилища.Сохранить(КлючОбъекта, КлючНастроек, Значение, ОписаниеНастроек, ИмяПользователя);
			if(true/*НужноОбновитьПовторноИспользуемыеЗначения*/)
			{
				//ОбновитьПовторноИспользуемыеЗначения();
			}
		}
		// Возвращает значение пользовательской настройки по имени.
		//

		public object ХранилищеЗагрузить(/*МенеджерХранилища, КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию, 
	ОписаниеНастроек, ИмяПользователя*/)
		{
			//Результат = Неопределено;
			if(true/*ПравоДоступа("СохранениеДанныхПользователя", Метаданные)*/)
			{
				//Результат = МенеджерХранилища.Загрузить(КлючОбъекта, КлючНастроек, ОписаниеНастроек, ИмяПользователя);
			}
			if(true/*(Результат = Неопределено) И (ЗначениеПоУмолчанию <> Неопределено)*/)
			{
				//Результат = ЗначениеПоУмолчанию;
			}
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// Общие процедуры и функции
		// Функция возвращает ссылку на текущего пользователя базы данных,
		// установленного по учетной записи пользователя конфигурации.
		//
		// Возвращаемое значение:
		//  СправочникСсылка.Пользователи
		//

		public object ТекущийПользователь(/**/)
		{
			return null;
		}
		// Выполнить экспортную процедуру без параметров по имени.
		//
		// Параметры
		//  ИмяЭкспортнойПроцедуры – Строка    – имя экспортной процедуры в формате
		//                                       <имя объекта>.<имя процедуры>, где <имя объекта> - это
		//                                       общий модуль или модуль менеджера объекта.
		//
		// Пример
		//  ВыполнитьБезопасно("МойОбщийМодуль.МояПроцедура");
		//

		public void ВыполнитьБезопасно(/*Знач ИмяЭкспортнойПроцедуры*/)
		{
			if(true/*Не ПроверитьИмяЭкспортнойПроцедуры(ИмяЭкспортнойПроцедуры, ТекстСообщения)*/)
			{
				//ВызватьИсключение ТекстСообщения;
			}
			//Выполнить ИмяЭкспортнойПроцедуры + "();";
		}
		// Проверяет имя экспортной процедуры на валидность для использования
		// в инструкции Выполнить встроенного языка. При некорректном имени
		// вызывается исключение.
		//

		public object ПроверитьИмяЭкспортнойПроцедуры(/*Знач ИмяЭкспортнойПроцедуры, ТекстСообщения*/)
		{
			/*// Проверка предусловий на формат ИмяЭкспортнойПроцедуры.
*/
			//ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЭкспортнойПроцедуры, ".");
			if(true/*ЧастиИмени.Количество() <> 2 И ЧастиИмени.Количество() <> 3*/)
			{
				/*ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
			ИмяЭкспортнойПроцедуры);*/
			}
			//ИмяОбъекта = ЧастиИмени[0];
			if(true/*ЧастиИмени.Количество() = 2 И Метаданные.ОбщиеМодули.Найти(ИмяОбъекта) = Неопределено*/)
			{
				/*ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
			ИмяЭкспортнойПроцедуры);*/
			}
			if(true/*ЧастиИмени.Количество() = 3*/)
			{
				//ДопустимыеИменаТипов = Новый Массив;
				//ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаКонстанты()));
				//ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыСведений()));
				//ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыНакопления()));
				//ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыБухгалтерии()));
				//ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыРасчета()));
				//ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаСправочники()));
				//ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаДокументы()));
				//ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаБизнесПроцессы()));
				//ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаЗадачи()));
				//ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыСчетов()));
				//ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыОбмена()));
				//ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыВидовХарактеристик()));
				//ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыВидовРасчета()));
				//ИмяТипа = ВРег(ЧастиИмени[0]);
				if(true/*ДопустимыеИменаТипов.Найти(ИмяТипа) = Неопределено*/)
				{
					/*ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
				ИмяЭкспортнойПроцедуры);*/
				}
			}
			return null;
		}
		// Объединяет исключения поиска ссылок.
		//

		public object ПолучитьОбщийСписокИсключенийПоискаСсылок(/**/)
		{
			//ОбщийМассивИсключенийСсылок = Новый Массив;
			//ЗаполнитьМассивУникальнымиЗначениями(ОбщийМассивИсключенийСсылок, СтандартныеПодсистемыПереопределяемый.ИсключенияПоискаСсылок());
			//ЗаполнитьМассивУникальнымиЗначениями(ОбщийМассивИсключенийСсылок, ОбщегоНазначенияПереопределяемый.ПолучитьИсключенияПоискаСсылок());
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// Вспомогательные процедуры и функции
		// Функция ИнформационнаяБазаФайловая определяет режим эксплуатации
		// информационной базы файловый (Истина) или Серверный (Ложь).
		//  При проверке используется СтрокаСоединенияИнформационнойБазы, которую
		// можно указать явно.
		//
		// Параметры:
		//  СтрокаСоединенияИнформационнойБазы - Строка - параметр используется, если
		//                 нужно проверить строку соединения не текущей информационной базы.
		//
		// Возвращаемое значение:
		//  Булево.
		//

		public object ИнформационнаяБазаФайловая(/*Знач СтрокаСоединенияИнформационнойБазы = ""*/)
		{
			if(true/*ПустаяСтрока(СтрокаСоединенияИнформационнойБазы)*/)
			{
				//СтрокаСоединенияИнформационнойБазы =  СтрокаСоединенияИнформационнойБазы();
			}
			//Возврат Найти(Врег(СтрокаСоединенияИнформационнойБазы), "FILE=") = 1;
			return null;
		}
		// Получить представление информационной базы для отображения пользователю.
		//
		// Возвращаемое значение:
		//   Строка      - Представление информационной базы
		//
		// Пример возвращаемого результата:
		// - для ИБ в файлом режиме: \\FileServer\1c_ib\
		// - для ИБ в серверном режиме: ServerName:1111 / information_base_name
		//

		public object ПолучитьПредставлениеИнформационнойБазы(/**/)
		{
			//СтрокаСоединенияСБД = СтрокаСоединенияИнформационнойБазы();
			if(true/*ИнформационнаяБазаФайловая(СтрокаСоединенияСБД)*/)
			{
				//ПутьКБД = Сред(СтрокаСоединенияСБД, 6, СтрДлина(СтрокаСоединенияСБД) - 6);
			}
			return null;
		}
		// Проверить, что описание типа состоит из единственного типа значения и
		// совпадает с нужным типом.
		//
		// Возвращаемое значение:
		//   Булево      - Совпадает или нет
		//

		public object ОписаниеТипаСостоитИзТипа(/*ОписаниеТипа, ТипЗначения*/)
		{
			if(true/*ОписаниеТипа.Типы().Количество() = 1
	   И ОписаниеТипа.Типы().Получить(0) = ТипЗначения*/)
			{
			}
			return null;
		}
		// Получает таблицу значений с описанием требуемых свойств всех реквизитов объекта метаданного
		// Получает значения свойств стандартных реквизитов и пользовательских реквизитов (созданных в режиме конфигуратора)
		//
		// Параметры:
		//  ОбъектМетаданных  - Объект метаданных конфигурации, для которого необходимо получить значение свойств реквизитов.
		//                      Например: Метаданные.Документ.РеализацияТоваровИУслуг
		//  Свойства - Строка - свойства реквизитов, перечисленных через запятую, значение которых необходимо получить.
		//                      Например: "Имя, Тип, Синоним, Подсказка"
		//
		// Возвращаемое значение:
		//  ТаблицаЗначений - таблица значений с описанием требуемых свойств всех реквизитов объекта метаданного
		//

		public object ПолучитьТаблицуОписанияСвойствОбъекта(/*ОбъектМетаданных, Свойства*/)
		{
			//МассивСвойств = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Свойства);
			/*// возвращаемое значение функции
*/
			//ТаблицаОписанияСвойствОбъекта = Новый ТаблицаЗначений;
			/*// добавляем в таблицу поля согласно именам переданных свойств
*/
			/*// заполняем строку таблицы свойствами реквизитов объекта метаданных
*/
			/*// заполняем строку таблицы свойствами стандартных реквизитов объекта метаданных
*/
			return null;
		}
		// Процедура предназначена для заполнения реквизита формы типа «ДеревоЗначений»
		//
		// Параметры:
		// КоллекцияЭлементовДерева – реквизит формы, который имеет тип «ДеревоЗначений»;
		// 							  реквизит заполняется значениями из второго параметра процедуры.
		// ДеревоЗначений           – ДеревоЗначений – параметр содержит данные для заполнения.
		//

		public void ЗаполнитьКоллекциюЭлементовДереваДанныхФормы(/*КоллекцияЭлементовДерева, ДеревоЗначений*/)
		{
		}
		// Проверяет наличие табличной части у документа
		//
		//Параметры
		//  ИмяДокумента      - Строка - имя документа, для которого осуществляется проверка.
		//  ИмяТабличнойЧасти - Строка - имя табличной части, наличие которой проверяется.
		//
		//Возвращаемое значение:
		//  Булево   - Истина, если табличная часть есть, ложь в обратном случае
		//

		public object НаличиеТабличнойЧастиУДокумента(/*ИмяДокумента, ИмяТабличнойЧасти*/)
		{
			return null;
		}

		public object СравнитьТипСсылкиДокумента(/*Ссылка, ИмяДокумента*/)
		{
			if(true/*Метаданные.Документы.Найти(ИмяДокумента) = Неопределено*/)
			{
			}
			//Возврат ТипЗнч(Ссылка) = Тип("ДокументСсылка." + ИмяДокумента);
			return null;
		}
		// Переадресация вызова функции ПолучитьЗначениеПеременной
		//

		public object ПолучитьЗначениеПеременной(/*ИмяПараметра, Кэш = Неопределено, КэшИзменен = Ложь*/)
		{
			return null;
		}
		// Получение представления для документа, удостоверяющего личность
		//
		// Параметры
		//  ДанныеФизЛица  – Коллекция данных физ. лица (структура, строка таблицы, ...), содержащая значения:
		//                   ДокументВид, ДокументСерия, ДокументНомер, ДокументДатаВыдачи, ДокументКемВыдан
		//
		// Возвращаемое значение:
		//   Строка   – Представление документа, удостоверяющего личность
		//

		public object ПолучитьПредставлениеДокументаФизЛица(/*ДанныеФизЛица*/)
		{
			/*Возврат Строка(ДанныеФизЛица.ДокументВид) + " серия " +
			ДанныеФизЛица.ДокументСерия       + ", номер " +
			ДанныеФизЛица.ДокументНомер       + ", выданный " +
			Формат(ДанныеФизЛица.ДокументДатаВыдачи, "ДФ=dd.MM.yyyy")  + " " +
			ДанныеФизЛица.ДокументКемВыдан;*/
			return null;
		}
		// ПолучитьПредставлениеДокументаФизЛица()
		// Функция формирует фамилию и инициалы либо по наименованию элемента спр-ка ФизическиеЛица
		//  либо по переданным строкам.
		//  Если передан Объект, то извлеченная из него строка считается совокупностью
		//  Фамилия + Имя + Отчество, разделенными пробелами.
		//
		// Параметры
		//  Объект		- строка или ссылка или объект элемента спр-ка ФизическиеЛица.
		//  Фамилия		- фамилия физ. лица.
		//  Имя			- имя физ. лица.
		//  Отчество	- отчество физ. лица.
		//
		// Возвращаемое значение
		//  Фамилия и Инициалы одной строкой. Побочные эффекты - переданная целая строка
		//  Побочные эффекты - переданная целая строка разбивается на подстроки, соответствующие
		//  отдельным Фамилии,Имени и Отчеству
		//

		public object ФамилияИнициалыФизЛица(/*Объект = "", Фамилия = " ", Имя = " ", Отчество = " "*/)
		{
			if(true/*Не ЗначениеЗаполнено(Фамилия) И Не ЗначениеЗаполнено(Имя)*/)
			{
				//ФИО = ФамилияИмяОтчествоФизЛица(Объект);
				//Фамилия = ФИО.Фамилия;
				//Имя		= ФИО.Имя;
				//Отчество= ФИО.Отчество;
			}
			return null;
		}
		// Функция формирует фамилию и инициалы либо по наименованию элемента спр-ка ФизическиеЛица
		//  либо по переданным строкам.
		//  Если передан Объект, то извлеченная из него строка считается совокупностью
		//  Фамилия + Имя + Отчество, разделенными пробелами.
		//
		// Параметры
		//  Объект		- строка или ссылка или объект элемента спр-ка ФизическиеЛица.
		//  Фамилия		- фамилия физ. лица.
		//  Имя			- имя физ. лица.
		//  Отчество	- отчество физ. лица.
		//
		// Возвращаемое значение
		//  Фамилия и Инициалы одной строкой. Побочные эффекты - переданная целая строка
		//  Побочные эффекты - переданная целая строка разбивается на подстроки, соответствующие
		//  отдельным Фамилии,Имени и Отчеству
		//

		public object ИнициалыФизЛицаФамилия(/*Объект = "", Фамилия = " ", Имя = " ", Отчество = " "*/)
		{
			if(true/*НЕ ЗначениеЗаполнено("" + Фамилия + Имя + Отчество)*/)
			{
				//ФИО = ФамилияИмяОтчествоФизЛица(Объект);
				//Фамилия = ФИО.Фамилия;
				//Имя		= ФИО.Имя;
				//Отчество= ФИО.Отчество;
			}
			return null;
		}

		public object ФамилияИмяОтчествоФизЛица(/*Объект*/)
		{
			//ТипОбъекта = ТипЗнч(Объект);
			//ФИО = Новый Массив;
			if(true/*ТипОбъекта <> Тип("Неопределено")*/)
			{
				//СписокТиповСсылок	= ОбщегоНазначенияПереопределяемый.ВернутьСписокТиповСсылокДляФормированияФИО();
				//СписокТиповОбъектов	= ОбщегоНазначенияПереопределяемый.ВернутьСписокТиповОбъектовДляФормированияФИО();
				if(true/*ТипОбъекта = Тип("Строка")*/)
				{
					//ФИО = РазложитьСтрокуВМассивПодстрок(СокрЛП(Объект)," ");
				}
			}
			//КоличествоПодстрок = ФИО.Количество();
			//Результат = Новый Структура;
			//Результат.Вставить("Фамилия",	?(КоличествоПодстрок > 0,ФИО[0],""));
			//Результат.Вставить("Имя",		?(КоличествоПодстрок > 1,ФИО[1],""));
			//Результат.Вставить("Отчество",	?(КоличествоПодстрок > 2,ФИО[2],""));
			return null;
		}
		// Функция формирует фамилию и инициалы работника в заданном падеже
		// по переданным данным о работнике.
		//  либо по переданным строкам.
		//
		// Параметры
		//  Работник	- строка (Фамилия + Имя + Отчество, разделенными пробелами)
		//                или ссылка на элемент справочника ФизическиеЛица или Сотрудники.
		//  Падеж (необязательный), тип число
		//   Падеж, в который необходимо поставить ФИО.
		//   1 - Именительный
		//   2 - Родительный
		//   3 - Дательный
		//   4 - Винительный
		//   5 - Творительный
		//   6 - Предложный
		//
		//  Пол (необязательный), тип ПеречислениеСсылка.ПолФизическихЛиц
		//   Данный параметр предназначен для разрешения возможных неоднозначностей
		//   В остальных случаях рекомендуется опускать этот параметр.
		// Возвращаемое значение
		//  Фамилия и Инициалы одной строкой.
		//

		public object ПредставлениеРаботника(/*Работник, Знач Падеж = 1, Знач Пол = Неопределено*/)
		{
			//ТипДанных = ТипЗнч(Работник);
			if(true/*ТипДанных = Тип("Строка")*/)
			{
				//РаботникФИО = Работник;
				//РаботникПол = Пол;
			}
			//ФИО = ОбщегоНазначения.ФамилияИнициалыФизЛица(РаботникФИО);
			//ПозицияПервогоПробела = Найти(ФИО + " "," ");
			//Фамилия  = Лев(ФИО,ПозицияПервогоПробела-1);
			//Инициалы = Сред(ФИО,ПозицияПервогоПробела+1);
			//РезультатСклонения = "";
			if(true/*УниверсальныеМеханизмы.Просклонять(глЗначениеПеременной("глКомпонентаСклоненияФИО"), Фамилия, Падеж, РаботникПол, РезультатСклонения)*/)
			{
				//ФИО = РезультатСклонения + " " + Инициалы;
			}
			return null;
		}
		// Функция возвращает совокупность данных о физическом лице в виде структуры,
		// В совокупность данных входит ФИО, должность в заданной организации,
		// паспортные данные и др.
		//
		// Параметры:
		//  Организация  - СправочникСсылка.Организации - организация, по которой
		//                 определяется должность и подразделение работника
		//  ФизЛицо      - СправочникСсылка.ФизическиеЛица - физическое лицо,
		//                 по которому возвращается совокупность данных
		//  ДатаСреза    - Дата - дата, на которую считываются данные
		//  ФИОКратко    - Булево - если Истина (по умолчанию), Представление физ.лица включает фамилию и инициалы, если Ложь - фамилию и полностью имя и отчество
		//
		// Возвращаемое значение:
		//  Структура    - Структура с совокупностью данных о физическом лице:
		//                 - Фамилия
		//                 - Имя
		//                 - Отчетсво
		//                 - Представление (Фамилия И.О.)
		//                 - Подразделение
		//                 - ДокументВид
		//                 - ДокументСерия
		//                 - ДокументНомер
		//                 - ДокументДатаВыдачи
		//                 - ДокументКемВыдан
		//                 - ДокументКодПодразделения
		//

		public object ДанныеФизЛица(/*Организация, ФизЛицо, ДатаСреза, ФИОКратко = Истина*/)
		{
			//ЗапросПоЛицам = Новый Запрос();
			//ЗапросПоЛицам.УстановитьПараметр("ДатаСреза",   ДатаСреза);
			//ЗапросПоЛицам.УстановитьПараметр("Организация", Организация);
			//ЗапросПоЛицам.УстановитьПараметр("ФизЛицо", ФизЛицо);
			/*ЗапросПоЛицам.Текст =
	"ВЫБРАТЬ
	|	ФизическиеЛица.Ссылка КАК ФизЛицо
	|ПОМЕСТИТЬ ФизЛица
	|ИЗ
	|	Справочник.ФизическиеЛица КАК ФизическиеЛица
	|ГДЕ
	|	ФизическиеЛица.Ссылка = &ФизЛицо
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	РаботникиОрганизацийСрезПоследних.Сотрудник.Код КАК ТабельныйНомер,
	|	РаботникиОрганизацийСрезПоследних.Сотрудник.Физлицо КАК ФизЛицо,
	|	ВЫБОР
	|		КОГДА РаботникиОрганизацийСрезПоследних.ПериодЗавершения <= &ДатаСреза
	|				И РаботникиОрганизацийСрезПоследних.ПериодЗавершения <> ДАТАВРЕМЯ(1, 1, 1, 0, 0, 0)
	|			ТОГДА РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизацииЗавершения
	|		ИНАЧЕ РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизации
	|	КОНЕЦ КАК ПодразделениеОрганизации,
	|	ВЫБОР
	|		КОГДА РаботникиОрганизацийСрезПоследних.ПериодЗавершения <= &ДатаСреза
	|				И РаботникиОрганизацийСрезПоследних.ПериодЗавершения <> ДАТАВРЕМЯ(1, 1, 1, 0, 0, 0)
	|			ТОГДА РаботникиОрганизацийСрезПоследних.ДолжностьЗавершения
	|		ИНАЧЕ РаботникиОрганизацийСрезПоследних.Должность
	|	КОНЕЦ КАК Должность
	|ПОМЕСТИТЬ СведенияПоРаботникамОрганизации
	|ИЗ
	|	РегистрСведений.РаботникиОрганизаций.СрезПоследних(
	|			&ДатаСреза,
	|			Сотрудник.ФизЛицо = &ФизЛицо
	|				И Организация = &Организация) КАК РаботникиОрганизацийСрезПоследних
	|ГДЕ
	|	РаботникиОрганизацийСрезПоследних.ПричинаИзмененияСостояния <> ЗНАЧЕНИЕ(Перечисление.ПричиныИзмененияСостояния.Увольнение)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ФИОФизЛицСрезПоследних.Фамилия,
	|	ФИОФизЛицСрезПоследних.Имя,
	|	ФИОФизЛицСрезПоследних.Отчество,
	|	СведенияПоРаботникамОрганизации.ТабельныйНомер,
	|	СведенияПоРаботникамОрганизации.Должность,
	|	СведенияПоРаботникамОрганизации.ПодразделениеОрганизации,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументВид,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументСерия,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументНомер,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументДатаВыдачи,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументКемВыдан,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументКодПодразделения
	|ИЗ
	|	ФизЛица КАК ФизЛица
	|		
	|		ЛЕВОЕ СОЕДИНЕНИЕ 
	|			РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо = &ФизЛицо) КАК ФИОФизЛицСрезПоследних
	|		ПО 
	|			ФизЛица.ФизЛицо = ФИОФизЛицСрезПоследних.ФизЛицо
	|		
	|		ЛЕВОЕ СОЕДИНЕНИЕ 
	|			РегистрСведений.ПаспортныеДанныеФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо = &ФизЛицо) КАК ПаспортныеДанныеФизЛицСрезПоследних
	|		ПО 
	|			ФизЛица.ФизЛицо = ПаспортныеДанныеФизЛицСрезПоследних.ФизЛицо
	|		
	|		ЛЕВОЕ СОЕДИНЕНИЕ 
	|			СведенияПоРаботникамОрганизации КАК СведенияПоРаботникамОрганизации
	|		ПО 
	|			ФизЛица.ФизЛицо = СведенияПоРаботникамОрганизации.ФизЛицо";*/
			//Данные = ЗапросПоЛицам.Выполнить().Выбрать();
			//Данные.Следующий();
			/*Результат = Новый Структура("Фамилия, Имя, Отчество, Представление, 
								|ТабельныйНомер, Должность, ПодразделениеОрганизации, 
								|ДокументВид, ДокументСерия, ДокументНомер,  
								|ДокументДатаВыдачи, ДокументКемВыдан, ДокументКодПодразделения, 
								|ПредставлениеДокумента");*/
			//ЗаполнитьЗначенияСвойств(Результат, Данные);
			//Результат.Представление          = ПолучитьФамилиюИмяОтчество(Данные.Фамилия, Данные.Имя, Данные.Отчество, ФИОКратко);
			//Результат.ПредставлениеДокумента = ПолучитьПредставлениеДокументаФизЛица(Данные);
			return null;
		}
		// ДанныеФизЛица
		// Функция возвращает совокупность данных о физических лицах в виде таблицы
		// значений. В совокупность данных входит ФИО, должность в заданной
		// организации, паспортные данные и др.
		//
		// Параметры:
		//  Организация  - СправочникСсылка.Организации - организация, по которой
		//                 определяется должность и подразделение работника(ов)
		//  ФизЛицо      - СправочникСсылка.ФизическиеЛица или Массив - физическое лицо
		//                 или список физ. лиц, по которым возвращается совокупность
		//                 данных
		//  ДатаСреза    - Дата - дата, на которую считываются данные
		//
		// Возвращаемое значение:
		//  ТаблицаЗначений - Таблица с совокупностью данных о физическом лице.
		//                  Колонки: возвращаемой таблицы:
		//                  - Фамилия
		//                  - Имя
		//                  - Отчетсво
		//                  - Представление (Фамилия И.О.)
		//                  - Подразделение
		//                  - ДокументВид
		//                  - ДокументСерия
		//                  - ДокументНомер
		//                  - ДокументДатаВыдачи
		//                  - ДокументКемВыдан
		//                  - ДокументКодПодразделения
		//

		public object ДанныеФизЛиц(/*Организация, ФизЛицо, ДатаСреза*/)
		{
			//ЗапросПоЛицам = Новый Запрос();
			//ЗапросПоЛицам.УстановитьПараметр("ДатаСреза",   ДатаСреза);
			//ЗапросПоЛицам.УстановитьПараметр("Организация", Организация);
			//ЗапросПоЛицам.УстановитьПараметр("ФизЛицо", ФизЛицо);
			/*ЗапросПоЛицам.Текст =
	"ВЫБРАТЬ
	|	ФизическиеЛица.Ссылка КАК ФизЛицо
	|ПОМЕСТИТЬ ФизЛица
	|ИЗ
	|	Справочник.ФизическиеЛица КАК ФизическиеЛица
	|ГДЕ
	|	ФизическиеЛица.Ссылка В(&ФизЛицо)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	РаботникиОрганизацийСрезПоследних.Сотрудник.Код КАК ТабельныйНомер,
	|	РаботникиОрганизацийСрезПоследних.Сотрудник.Физлицо КАК ФизЛицо,
	|	ВЫБОР
	|		КОГДА РаботникиОрганизацийСрезПоследних.ПериодЗавершения <= &ДатаСреза
	|				И РаботникиОрганизацийСрезПоследних.ПериодЗавершения <> ДАТАВРЕМЯ(1, 1, 1, 0, 0, 0)
	|			ТОГДА РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизацииЗавершения
	|		ИНАЧЕ РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизации
	|	КОНЕЦ КАК ПодразделениеОрганизации,
	|	ВЫБОР
	|		КОГДА РаботникиОрганизацийСрезПоследних.ПериодЗавершения <= &ДатаСреза
	|				И РаботникиОрганизацийСрезПоследних.ПериодЗавершения <> ДАТАВРЕМЯ(1, 1, 1, 0, 0, 0)
	|			ТОГДА РаботникиОрганизацийСрезПоследних.ДолжностьЗавершения
	|		ИНАЧЕ РаботникиОрганизацийСрезПоследних.Должность
	|	КОНЕЦ КАК Должность
	|ПОМЕСТИТЬ СведенияПоРаботникамОрганизации
	|ИЗ
	|	РегистрСведений.РаботникиОрганизаций.СрезПоследних(
	|			&ДатаСреза,
	|			Сотрудник.ФизЛицо В (&ФизЛицо)
	|				И Организация = &Организация) КАК РаботникиОрганизацийСрезПоследних
	|ГДЕ
	|	РаботникиОрганизацийСрезПоследних.ПричинаИзмененияСостояния <> ЗНАЧЕНИЕ(Перечисление.ПричиныИзмененияСостояния.Увольнение)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ФИОФизЛицСрезПоследних.Фамилия,
	|	ФИОФизЛицСрезПоследних.Имя,
	|	ФИОФизЛицСрезПоследних.Отчество,
	|	СведенияПоРаботникамОрганизации.ТабельныйНомер,
	|	СведенияПоРаботникамОрганизации.Должность,
	|	СведенияПоРаботникамОрганизации.ПодразделениеОрганизации,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументВид,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументСерия,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументНомер,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументДатаВыдачи,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументКемВыдан,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументКодПодразделения
	|ИЗ
	|	ФизЛица КАК ФизЛица
	|		
	|		ЛЕВОЕ СОЕДИНЕНИЕ 
	|			РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо В (&ФизЛицо)) КАК ФИОФизЛицСрезПоследних
	|		ПО 
	|			ФизЛица.ФизЛицо = ФИОФизЛицСрезПоследних.ФизЛицо
	|		
	|		ЛЕВОЕ СОЕДИНЕНИЕ 
	|			РегистрСведений.ПаспортныеДанныеФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо В (&ФизЛицо)) КАК ПаспортныеДанныеФизЛицСрезПоследних
	|		ПО 
	|			ФизЛица.ФизЛицо = ПаспортныеДанныеФизЛицСрезПоследних.ФизЛицо
	|		
	|		ЛЕВОЕ СОЕДИНЕНИЕ 
	|			СведенияПоРаботникамОрганизации КАК СведенияПоРаботникамОрганизации
	|		ПО 
	|			ФизЛица.ФизЛицо = СведенияПоРаботникамОрганизации.ФизЛицо";*/
			//Данные = ЗапросПоЛицам.Выполнить().Выбрать();
			//ТабРезультат = Новый ТаблицаЗначений();
			//ТабРезультат.Колонки.Добавить("Фамилия");
			//ТабРезультат.Колонки.Добавить("Имя");
			//ТабРезультат.Колонки.Добавить("Отчество");
			//ТабРезультат.Колонки.Добавить("Представление");
			//ТабРезультат.Колонки.Добавить("ТабельныйНомер");
			//ТабРезультат.Колонки.Добавить("Должность");
			//ТабРезультат.Колонки.Добавить("ПодразделениеОрганизации");
			//ТабРезультат.Колонки.Добавить("ДокументВид");
			//ТабРезультат.Колонки.Добавить("ДокументСерия");
			//ТабРезультат.Колонки.Добавить("ДокументНомер");
			//ТабРезультат.Колонки.Добавить("ДокументДатаВыдачи");
			//ТабРезультат.Колонки.Добавить("ДокументКемВыдан");
			//ТабРезультат.Колонки.Добавить("ДокументКодПодразделения");
			//ТабРезультат.Колонки.Добавить("ПредставлениеДокумента");
			while(true/*Данные.Следующий()*/)
			{
				//Результат = ТабРезультат.Добавить();
				//ЗаполнитьЗначенияСвойств(Результат, Данные);
				//Результат.Представление          = ПолучитьФамилиюИмяОтчество(Данные.Фамилия, Данные.Имя, Данные.Отчество);
				//Результат.ПредставлениеДокумента = ПолучитьПредставлениеДокументаФизЛица(Данные);
			}
			return null;
		}
		// ДанныеФизЛиц
		// Функция формирует фамилию и инициалы
		//
		// Параметры
		//  Фамилия  - фамилия физ. лица.
		//  Имя      - имя физ. лица.
		//  Отчество - отчество физ. лица.
		//
		// Возвращаемое значение
		//  Фамилия, имя, отчество одной строкой.
		//

		public object ПолучитьФамилиюИмяОтчество(/*Фамилия = " ", Имя = " ", Отчество = " ", ФИОКратко = Истина*/)
		{
			if(true/*ФИОКратко*/)
			{
			}
			return null;
		}
		// ПолучитьФамилиюИмяОтчество()

		public object ПолучитьМассивПрефиксовРИБ(/**/)
		{
			//МассивПрефиксов = Новый Массив();
			//Запрос = Новый Запрос();
			/*Запрос.Текст = "ВЫБРАТЬ Различные
	               |	ПрефиксыИнформационныхБаз.Префикс КАК Префикс
	               |ИЗ
	               |	РегистрСведений.ПрефиксыИнформационныхБаз КАК ПрефиксыИнформационныхБаз";*/
			//ВыборкаУзлов = Запрос.Выполнить().Выбрать();
			while(true/*ВыборкаУзлов.Следующий()*/)
			{
				if(true/*Не ПустаяСтрока(ВыборкаУзлов.Префикс)*/)
				{
					//МассивПрефиксов.Добавить(ВыборкаУзлов.Префикс);
				}
			}
			return null;
		}

		public object СформироватьМассивПрефиксовДляРИБИОрганизации(/*Организация*/)
		{
			//МассивПрефиксов = ПолучитьМассивПрефиксовРИБ();
			if(true/*ЗначениеЗаполнено(Организация)*/)
			{
				//Префикс = СокрЛП(Организация.Префикс);
				if(true/*Префикс <> ""*/)
				{
					//МассивПрефиксов.Добавить(Префикс);
				}
			}
			if(true/*МассивПрефиксов.Количество() = 0*/)
			{
				//МассивПрефиксов.Добавить("");
			}
			return null;
		}
		// Заполнение отбора значениями из таблицы значений.
		// Соответствие полей устанавливается по представлению и типам значений
		//
		// Параметры
		//  Отбор  – Отбор           – Отбор, который требуется заполнить значениями
		//  ТЗ     – ТаблицаЗначений – Таблица содержит значения для отбора.
		//                             Структура колонок повторяет структуру отбора
		//

		public void ЗаполнитьОтборПоТаблицеЗначений(/*Отбор, ТЗ*/)
		{
		}
		// УстановитьОтборИзТаблицы(Отбор, ТЗ)
		// Функция выделяет первое слово в предложении

		public object ВыделитьСлово(/*ИсходнаяСтрока*/)
		{
			//Буфер = СокрЛ(ИсходнаяСтрока);
			//ПозицияПослПробела = Найти(Буфер, " ");
			if(true/*ПозицияПослПробела = 0*/)
			{
				//ИсходнаяСтрока = "";
			}
			//ВыделенноеСлово = СокрЛП(Лев(Буфер, ПозицияПослПробела));
			//ИсходнаяСтрока = Сред(ИсходнаяСтрока, ПозицияПослПробела + 1);
			return null;
		}
		// Функция преобразует строку к множественному числу
		//
		// Параметры:
		//  Слово1 - форма слова в ед числе      ("шкаф")
		//  Слово2 - форма слова для числит 2-4  ("шкафа")
		//  Слово3 - форма слова для числит 5-10 ("шкафов")
		//  ЦелоеЧисло - целое число
		//
		// Возвращаемое значение:
		//  строку - одну из строк в зависимости от параметра ЦелоеЧисло
		//
		// Описание:
		//  Предназначена для формирования "правильной" подписи к числительным
		//

		public object ФормаМножественногоЧисла(/*Слово1, Слово2, Слово3, Знач ЦелоеЧисло*/)
		{
			/*// Изменим знак целого числа, иначе отрицательные числа будут неправильно преобразовываться
*/
			if(true/*ЦелоеЧисло < 0*/)
			{
				//ЦелоеЧисло = -1 * ЦелоеЧисло;
			}
			if(true/*ЦелоеЧисло <> Цел(ЦелоеЧисло)*/)
			{
				/*// для нецелых чисел - всегда вторая форма
*/
			}
			/*// остаток
*/
			//Остаток = ЦелоеЧисло%10;
			if(true/*(ЦелоеЧисло >10) И (ЦелоеЧисло<20)*/)
			{
				/*// для второго десятка - всегда третья форма
*/
			}
			return null;
		}
		// Процедура вычисляет количество лет, месяцев и дней между двумя датами
		//
		// Параметры
		//  Дата1	– дата, первая дата (более поздняя, часто текущая, стаж определяется по состоянию на эту дату)
		//  Дата2	– дата, вторая дата (ранняя дата, с нее начинается "течение" стажа)
		//  Лет		– Число, в этот параметр будет записано кол-во лет между двумя датами (Дата1-Дата2)
		//  Месяцев	– Число, в этот параметр будет записано кол-во месяцев между двумя датами (Дата1-Дата2)
		//  Дней	– Число, в этот параметр будет записано кол-во дней между двумя датами (Дата1-Дата2)
		//

		public void РазобратьРазностьДат(/*Дата1, Дата2, Лет = 0, Месяцев = 0, Дней = 0*/)
		{
			//Лет		= 0;
			//Месяцев	= 0;
			//Дней	= 0;
			if(true/*Дата1 > Дата2*/)
			{
				//ВременнаяДата = Дата1;
				if(true/*День(ВременнаяДата) < День(Дата2)*/)
				{
					//Дней = (ВременнаяДата - ДобавитьМесяц(ВременнаяДата,-1))/86400;
					//ВременнаяДата = ДобавитьМесяц(ВременнаяДата,-1);
				}
				if(true/*Месяц(ВременнаяДата) < Месяц(Дата2)*/)
				{
					//ВременнаяДата = ДобавитьМесяц(ВременнаяДата,-12);
					//Месяцев = 12;
				}
				//Лет		= Макс(			 Год(ВременнаяДата)		- Год(Дата2),	0);
				//Месяцев	= Макс(Месяцев	+ Месяц(ВременнаяДата)	- Месяц(Дата2),	0);
				//Дней	= Макс(Дней		+ День(ВременнаяДата)	- День(Дата2),	0);
				/*// скорректируем отображаемое значение, если "вмешалось" разное количество дней в месяцах
*/
				if(true/*Дата2 <> (ДобавитьМесяц(Дата1,-Лет*12-Месяцев)-Дней*86400)*/)
				{
					//Дней = Дней + ((ДобавитьМесяц(Дата1,-Лет*12-Месяцев)-Дней*86400) - Дата2)/86400;
					/*//(День(КонецМесяца(Дата2)) - День(НачалоМесяца(Дата2))) - (День(КонецМесяца(ДобавитьМесяц(Дата1,-1))) - День(НачалоМесяца(ДобавитьМесяц(Дата1,-1))));
*/
				}
			}
		}
		// РазобратьРазностьДат
		// Функция определяет дату и время начала календарной декады для указанной даты.
		//
		// Параметры:
		//  ТекущаяДата - Исходная дата.
		//
		// Возвращаемое значение:
		//  Дата.
		//

		public object ПолучитьНачалоДекады(/*ИсходнаяДата*/)
		{
			//ДеньМесяца = День(ИсходнаяДата);
			if(true/*ДеньМесяца <= 10*/)
			{
				//Результат = НачалоМесяца(ИсходнаяДата);
			}
			return null;
		}
		// ПолучитьНачалоДекады()
		// Функция определяет дату и время конца календарной декады для указанной даты.
		//
		// Параметры:
		//  ТекущаяДата - Исходная дата.
		//
		// Возвращаемое значение:
		//  Дата.
		//

		public object ПолучитьКонецДекады(/*ИсходнаяДата*/)
		{
			//ДеньМесяца = День(ИсходнаяДата);
			if(true/*ДеньМесяца <= 10*/)
			{
				//Результат = КонецДня(НачалоМесяца(ИсходнаяДата) + 60 * 60 * 24 * 9);
			}
			return null;
		}
		// ПолучитьКонецДекады()
		// Функция определяет дату и время начала полугодия для указанной даты.
		//
		// Параметры:
		//  ТекущаяДата - Исходная дата.
		//
		// Возвращаемое значение:
		//  Дата.
		//

		public object ПолучитьНачалоПолугодия(/*ИсходнаяДата*/)
		{
			if(true/*Месяц(ИсходнаяДата) < 7*/)
			{
				//Результат = НачалоГода(ИсходнаяДата);
			}
			return null;
		}
		// ПолучитьНачалоПолугодия()
		// Функция определяет дату и время конца полугодия для указанной даты.
		//
		// Параметры:
		//  ТекущаяДата - Исходная дата.
		//
		// Возвращаемое значение:
		//  Дата.
		//

		public object ПолучитьКонецПолугодия(/*ИсходнаяДата*/)
		{
			if(true/*Месяц(ИсходнаяДата) < 7*/)
			{
				//Результат = ДобавитьМесяц(КонецГода(ИсходнаяДата), -6);
			}
			return null;
		}
		// ПолучитьКонецПолугодия()
		// функция из исходной строки формирует строку для поиска данных в запросе

		public object СформироватьСтрокуДляПоискаВЗапросе(/*Знач СтрокаПоиска*/)
		{
			//ИтоговаяСтрокаДляПоиска = СтрокаПоиска;
			//ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "~", "~~");
			//ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "%", "~%");
			//ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "_", "~_");
			//ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "[", "~[");
			//ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "-", "~-");
			return null;
		}
		// Функция формирует представление заголовка документа
		//
		// Возвращаемое значение:
		//  Строка - представление номера документа
		//

		public object СформироватьЗаголовокДокумента(/*ДокументОбъект, НазваниеДокумента = ""*/)
		{
			if(true/*ДокументОбъект = Неопределено*/)
			{
			}
			return null;
		}
		// СформироватьЗаголовокДокумента()
		// Функция формирует представление суммы прописью в указанной валюте
		//
		// Возвращаемое значение:
		//  Строка - сумма прописью
		//

		public object СформироватьСуммуПрописью(/*Сумма, Валюта*/)
		{
			if(true/*Валюта.ПараметрыПрописиНаРусском = ""*/)
			{
			}
			return null;
		}
		// СформироватьСуммуПрописью()

		public void ДобавитьПрефиксОрганизации(/*ДокументОбъект, Префикс*/)
		{
			/*// Если в документе нет реквизита "Организация" или для организации не задан префикс,
*/
			/*// то используем пустой префикс, иначе используем префикс организации.
*/
			//Префикс = "0";
			if(true/*ДокументОбъект.Метаданные().Реквизиты.Найти("Организация") <> Неопределено*/)
			{
				//ПрефиксОрганизации = ПолучитьЗначениеРеквизита(ДокументОбъект.Организация, "Префикс");
				if(true/*ЗначениеЗаполнено(ПрефиксОрганизации)*/)
				{
					//Префикс = ПрефиксОрганизации;
				}
			}
		}
		// процедура формирования номера документа

		public void ПриУстановкеНовогоНомераДляДокументов(/*Источник, СтандартнаяОбработка, Префикс*/)
		{
			//ДобавитьПрефиксОрганизации(Источник, Префикс);
			//ДобавитьПрефиксУзла(Префикс);
		}
		//Процедура выполняет удаление движений документа по регистрам при отмене проведения
		//	Является обработчиком подписки на событие "ОбработкаУдаленияПроведенияДокумента"
		//

		public void ОбработкаУдаленияПроведенияДокумента(/*Источник, Отказ*/)
		{
			//УдалитьДвиженияРегистратора(Источник, Отказ);
			if(true/*Источник.ДополнительныеСвойства.Свойство("ТаблицаСтаройРегистрацииВПоследовательности")
	  И Источник.ДополнительныеСвойства.ТаблицаСтаройРегистрацииВПоследовательности.Количество() > 0*/)
			{
				//УправлениеЗапасамиПартионныйУчет.СдвинутьГраницуПоследовательностиНазад(Источник.Дата, Источник.Ссылка, Источник.ДополнительныеСвойства.ТаблицаСтаройРегистрацииВПоследовательности);
			}
		}

		public void ПриУстановкеНовогоКодаДляСправочникаИлиПВХ(/*Источник, СтандартнаяОбработка, Префикс*/)
		{
			//ДобавитьПрефиксУзла(Префикс);
		}
		// Проверяет дату на заполненность по аналогии с системной функцией "ПустаяСтрока".
		//

		public object ПустаяДата(/*ПроверяемаяДата*/)
		{
			if(true/*ТипЗнч(ПроверяемаяДата) = Тип("Дата") 
	   И ПроверяемаяДата = Дата(1,1,1)*/)
			{
			}
			return null;
		}
		// ПустаяДата()
		// Функция возвращает массив вышестоящих групп указанного элемента.
		//
		// Переметры:
		//  Элемент      - Элемент справочника, для которого ищется родитель
		//
		// Возвращаемое значение
		//  Массив вышестояших групп
		//

		public object ПолучитьСписокВышеСтоящихГрупп(/*ЭлементСправочника*/)
		{
			//Результат = Новый Массив;
			if(true/*НЕ ЗначениеЗаполнено(ЭлементСправочника)*/)
			{
			}
			//МетаданныеСправочника = ЭлементСправочника.Метаданные();
			if(true/*НЕ МетаданныеСправочника.Иерархический*/)
			{
			}
			//ИмяСправочника = МетаданныеСправочника.Имя;
			//Запрос = Новый Запрос;
			/*Запрос.Текст = "
	|ВЫБРАТЬ
	|	Справочник1.Родитель КАК Родитель1,
	|	Справочник2.Родитель КАК Родитель2,
	|	Справочник3.Родитель КАК Родитель3,
	|	Справочник4.Родитель КАК Родитель4,
	|	Справочник5.Родитель КАК Родитель5
	|ИЗ
	|	Справочник." + ИмяСправочника + " КАК Справочник1
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник2
	|		ПО (Справочник2.Ссылка = Справочник1.Родитель)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник3
	|		ПО (Справочник3.Ссылка = Справочник2.Родитель)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник4
	|		ПО (Справочник4.Ссылка = Справочник3.Родитель)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник5
	|		ПО (Справочник5.Ссылка = Справочник4.Родитель)
	|ГДЕ
	|	Справочник1.Ссылка = &Ссылка";*/
			//ТекущийЭлемент = ЭлементСправочника;
			while(true/*ЗначениеЗаполнено(ТекущийЭлемент)*/)
			{
				//Запрос.УстановитьПараметр("Ссылка", ТекущийЭлемент);
				//Выборка = Запрос.Выполнить().Выбрать();
				if(true/*Выборка.Следующий()*/)
				{
				}
			}
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ ЗАПИСИ НАБОРОВ ЗАПИСЕЙ РЕГИСТРОВ, КОНСТАНТ
		// Проверяет значения констант из коллекции с текущим значением в ИБ,
		// не проверяется для типа данных ХранилищеЗначений
		//
		// Параметры:
		//  КоллекцияКонстантДляПроверки  - структура
		//									ключ 		- строка, имя константы
		//									значение 	- значение константы
		//
		// Возвращаемое значение:
		//  Массив констант значение которых изменилось по сравнению с переданной коллекцией
		//

		public object СоздатьМассивИзмененныхКонстант(/*КоллекцияКонстантДляПроверки*/)
		{
			//МассивИзмененныхКонстант = Новый Массив;
			return null;
		}
		// Функция выполняет запись переданного набора записей и
		// формирует сообщение об ошибке, если не удалось записать набор
		//
		// Параметры
		//  НаборЗаписей  - набор записей регистра сведений, который необходимо записать
		//
		// Возвращаемое значение:
		//   Булево   - Истина, когда набор записей записан
		//

		public object ЗаписатьНабор(/*НаборЗаписей*/)
		{
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕХАНИЗМОМ НАСТРОЙКИ ПОРЯДКА ЭЛЕМЕНТОВ СПРАВОЧНИКА
		// Вспомогательная функция для определнения условий запроса в механизме
		// изменения порядка следования элементов. Ставит условия на родителя и владельца
		//
		// Параметры
		//  Элемент - СправочникСсылка, для которого необходимо изменить порядок
		//  Запрос - Запрос, в который дописываем условия
		//
		//  Возвращаемое значение:
		//   Строка - условие запроса
		//

		public object ПолучитьДополнениеЗапроса(/*Элемент, Запрос, БезПервогоИ = Ложь*/)
		{
			//ТекстЗапроса = "";
			if(true/*Элемент.Метаданные().Иерархический = Истина*/)
			{
				//Запрос.УстановитьПараметр("ТекущийРодитель", Элемент.Родитель);
				if(true/*НЕ БезПервогоИ*/)
				{
					/*ТекстЗапроса = ТекстЗапроса + "
			|	И
			|";*/
				}
				/*ТекстЗапроса = ТекстЗапроса + "
		|	СправочникПорядка.Родитель = &ТекущийРодитель
		|";*/
			}
			if(true/*Элемент.Метаданные().Владельцы.Количество() > 0*/)
			{
				//Запрос.УстановитьПараметр("ТекущийВладелец", Элемент.Владелец);
				if(true/*НЕ (ПустаяСтрока(ТекстЗапроса) И БезПервогоИ)*/)
				{
					/*ТекстЗапроса = ТекстЗапроса + "
			|	И
			|";*/
				}
				/*ТекстЗапроса = ТекстЗапроса + "
		|	СправочникПорядка.Владелец = &ТекущийВладелец
		|";*/
			}
			return null;
		}
		// Возвращает значение порядка для нового элемента справочника.
		//
		// Параметры
		//  ЭлементОбъект - СправочникОбъект - новый объект
		//
		// Возвращаемое значение:
		//   Число - новый порядок
		//

		public object НазначитьНовыйПорядок(/*ЭлементОбъект*/)
		{
			//ИмяТаблицы = ЭлементОбъект.Метаданные().Имя;
			//Запрос = Новый Запрос;
			/*Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	|	СправочникПорядка.Порядок
	|ИЗ
	|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка";*/
			//ДополнениеЗапроса = ПолучитьДополнениеЗапроса(ЭлементОбъект, Запрос, Истина);
			if(true/*НЕ ПустаяСтрока(ДополнениеЗапроса)*/)
			{
				/*Запрос.Текст = Запрос.Текст + "
		|ГДЕ
		|" + ДополнениеЗапроса + "
		|";*/
			}
			/*Запрос.Текст = Запрос.Текст + "
	|УПОРЯДОЧИТЬ ПО
	|	СправочникПорядка.Порядок УБЫВ
	|";*/
			//РезультатЗапроса = Запрос.Выполнить();
			if(true/*РезультатЗапроса.Пустой()*/)
			{
			}
			return null;
		}
		// Процедура вызывается перед записью объекта, для которого необходимо
		// контролировать порядок элементов.
		//
		// Параметры
		//  Отказ - Булево, отказ от записи объекта
		//  ЭтотОбъект - СправочникОбъект
		//  КонтролироватьПорядок - Булево, контролировать порядок при записи объекта или нет
		//

		public void ПередЗаписьюОбъектаПорядка(/*Отказ, ЭтотОбъект, КонтролироватьПорядок*/)
		{
			if(true/*ЭтотОбъект.ЭтоНовый()*/)
			{
				//ЭтотОбъект.Порядок = НазначитьНовыйПорядок(ЭтотОбъект);
			}
			if(true/*КонтролироватьПорядок*/)
			{
				//ИмяТаблицы = ЭтотОбъект.Метаданные().Имя;
				//Запрос = Новый Запрос;
				//Запрос.УстановитьПараметр("ТекущийПорядок", ЭтотОбъект.Порядок);
				/*Запрос.Текст = "
		|ВЫБРАТЬ ПЕРВЫЕ 1
		|	СправочникПорядка.Порядок
		|ИЗ
		|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
		|ГДЕ
		|	СправочникПорядка.Порядок = &ТекущийПорядок
		|";*/
				if(true/*НЕ ЭтотОбъект.ЭтоНовый()*/)
				{
					//Запрос.УстановитьПараметр("ТекущаяСсылка", ЭтотОбъект.Ссылка);
					/*Запрос.Текст = Запрос.Текст + "
			|И
			|	СправочникПорядка.Ссылка <> &ТекущаяСсылка
			|";*/
				}
				//Запрос.Текст = Запрос.Текст + ПолучитьДополнениеЗапроса(ЭтотОбъект, Запрос);
				if(true/*НЕ Запрос.Выполнить().Пустой()*/)
				{
					//Отказ = Истина;
					//Сообщить("Не уникальный порядок элемента справочника.");
				}
			}
		}
		// Процедура изменяет порядок следования объектов с настраиваемым из ВЯ
		// порядком следования.
		//
		// Параметры:
		//  ЭлементСсылка - СправочникСсылка, элемент для которого необходимо изменить порядок
		//  НаправлениеПорядка - Строка, "Вверх" или "Вниз"
		//

		public void ИзменитьПорядок(/*ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг = Истина*/)
		{
			//ЭлементЗамены = ОпределитьНовыйПорядок(ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг);
			if(true/*ЭлементЗамены = Неопределено*/)
			{
			}
			//НовыйПорядокЗамены   = ЭлементЗамены.Порядок;
			//НовыйПорядокЭлемента = ЭлементСсылка.Порядок;
			if(true/*НаправлениеПорядка = "Вверх"*/)
			{
				if(true/*НовыйПорядокЗамены < НовыйПорядокЭлемента*/)
				{
					//ПромежуточныйПорядок = НовыйПорядокЗамены;
					//НовыйПорядокЗамены   = НовыйПорядокЭлемента;
					//НовыйПорядокЭлемента = ПромежуточныйПорядок;
				}
			}
			//НачатьТранзакцию();
			//ФиксироватьТранзакцию = Истина;
			if(true/*НовыйПорядокЗамены <> ЭлементЗамены.Порядок*/)
			{
				//ОбъектЗамены = ЭлементЗамены.ПолучитьОбъект();
				//ОбъектЗамены.Порядок = НовыйПорядокЗамены;
				//ОбъектЗамены.КонтролироватьПорядок = Ложь;
			}
			if(true/*ФиксироватьТранзакцию*/)
			{
				//ОбъектЭлемента = ЭлементСсылка.ПолучитьОбъект();
				//ОбъектЭлемента.Порядок = НовыйПорядокЭлемента;
			}
			if(true/*ФиксироватьТранзакцию*/)
			{
				//ЗафиксироватьТранзакцию();
			}
		}
		// Функция определяет элемент справочника, с которым необходимо
		// произвести "рокировку" текущего элемента
		//
		// Параметры
		//  ЭлементСсылка - СпраовочникСсылка, элемент для изменения порядка
		//  НаправлениеПорядка - Строка, "Вверх" или "Вниз"
		//
		// Возвращаемое значение:
		//   СправочникСсылка
		//

		public object ОпределитьНовыйПорядок(/*ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг*/)
		{
			//ТекущийПорядок = ЭлементСсылка.Порядок;
			//ИмяТаблицы = ЭлементСсылка.Метаданные().Имя;
			//Запрос = Новый Запрос;
			//Запрос.УстановитьПараметр("ТекущийПорядок", ТекущийПорядок);
			/*Запрос.Текст = "
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	СправочникПорядка.Ссылка
	|ИЗ
	|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
	|ГДЕ
	|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "<", ">") + " &ТекущийПорядок " + ПолучитьДополнениеЗапроса(ЭлементСсылка, Запрос) + "
	|УПОРЯДОЧИТЬ ПО
	|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "УБЫВ", "ВОЗР") + "
	|";*/
			//РезультатЗапроса = Запрос.Выполнить();
			if(true/*НЕ РезультатЗапроса.Пустой()*/)
			{
				//Выборка = РезультатЗапроса.Выбрать();
				//Выборка.Следующий();
			}
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ ПРОВЕРКИ НАЛИЧИЯ И ЗАПОЛНЕНИЯ РЕВИЗИТОВ
		// Предназначена для получения пустого значения заданного типа:
		//	примитивного, или ссылочного. Используется
		//
		// Параметры:
		//	ЗаданныйТип   - тип, пустое значение которого нужно получить
		//

		public object ПустоеЗначениеТипа(/*ЗаданныйТип*/)
		{
			if(true/*ЗаданныйТип = Тип("Число")*/)
			{
			}
			return null;
		}
		// ПустоеЗначениеТипа();
		//Предназначена для получения массива пустых значений, содержащих значение Неопределено и значения переданного типа или описания типов

		public object МассивПустыхЗначений(/*ОписаниеТипов*/)
		{
			//МассивЗначений = новый Массив;
			//МассивЗначений.Добавить(неопределено);
			if(true/*ТипЗнч(ОписаниеТипов)=Тип("ОписаниеТипов")*/)
			{
			}
			return null;
		}
		// Позволяет определить есть ли среди реквизитов табличной части документа
		// реквизит с переданным именем.
		//
		// Параметры:
		//  ИмяРеквизита - строковое имя искомого реквизита,
		//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
		//  ИмяТабЧасти  - строковое имя табличной части документа, среди реквизитов которого производится поиск
		//
		// Возвращаемое значение:
		//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
		//

		public object ЕстьРеквизитТабЧастиДокумента(/*ИмяРеквизита, МетаданныеДокумента, ИмяТабЧасти*/)
		{
			//ТабЧасть = МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабЧасти);
			/*// есть таб. часть в документе
*/
			return null;
		}
		// ЕстьРеквизитТабЧастиДокумента()
		// Функция проверяет наличие в строке только цифр
		//
		// Параметры
		//  СтрокаПроверки - Строка для проверки только цифр
		//
		// Возвращаемое значение:
		//   Булево
		//

		public object ЕстьНеЦифры(/*Знач СтрокаПроверки*/)
		{
			//СписокКодовЧисел = Новый СписокЗначений;
			//СтрокаПроверки = СокрЛП(СтрокаПроверки);
			if(true/*ТипЗнч(СтрокаПроверки) <> Тип("Строка")*/)
			{
			}
			return null;
		}
		// Если в шапке переданного документа есть реквизит с указанным именем, то возвращается его значение.
		// Если такого реквизита нет - возвращается Неопределено.
		//
		// Параметры:
		//  ИмяРеквизита - Строка. Имя искомого реквизита.
		//  ДокументОбъект - объект переданного документа.
		//  МетаданныеДокумента - Метаданные переданного документа.
		//  ПустоеЗначение - значение, которое должно вернуться, если в шапке нет такого реквизита,
		//  если не передано, то возвращается значение Неопределено.
		//
		// Возвращаемое значение:
		//  Значение реквизита - значение найденного реквизита или ПустоеЗначение.
		//

		public object ПолучитьРеквизитШапки(/*ИмяРеквизита, ДокументОбъект, МетаданныеДокумента, ПустоеЗначение = Неопределено*/)
		{
			/*ЗначениеРеквизита = ?(МетаданныеДокумента.Реквизиты.Найти(ИмяРеквизита) <> Неопределено,
	                      ДокументОбъект[ИмяРеквизита], ПустоеЗначение);*/
			return null;
		}
		// ПолучитьРеквизитШапки()
		///////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ ЗАГРУЗКИ КЛАССИФИКАТОРОВ

		public void ЗагрузитьКлассификаторИзXML(/*ПустойЭлементСправочника, ИмяФайлаПоУмолчанию*/)
		{
			//ФормаЗагрузки = ПолучитьОбщуюФорму("ФормаЗагрузкиКлассификатораИзXML");
			//ФормаЗагрузки.ПустойЭлементСправочника = ПустойЭлементСправочника;
			//ФормаЗагрузки.ИмяФайлаПоУмолчанию = ИмяФайлаПоУмолчанию;
			//ФормаЗагрузки.Открыть();
		}
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕХАНИЗМОМ ОТПРАВКИ СООБЩЕНИЙ В ОТДЕЛ ТЕХНИЧЕСКОЙ ПОДДЕРЖКИ ПОЛЬЗОВАТЕЛЕЙ
		// Функнция проверяет заполнения обязательных параметров для отправки сообщения
		//  в отдел технической поддержки.
		//
		// Параметры
		//  ТаблицаДанных - Таблица значений
		//
		// Возвращаемое значение:
		//   Булево - результат корректости проверки
		//

		public object ПроверитьСтруктуруЗаполненияПараметровДляОтправкиСообщенияВОтделТехническойПоддержки(/*ТаблицаДанных, ПубликоватьСообщения = Истина*/)
		{
			//ЗначениеПроверки = Истина;
			//СтрокаЗаголовкаОшибки = "Не заполнены настройки для отправки сообщения.";
			//СписокИменОбязательныхРеквизитов = Новый СписокЗначений;
			//СписокИменОбязательныхРеквизитов.Добавить("ПараметрыОтправкиЭлектронногоСообщения_АдресЭлектроннойПочтыОтделаТехническойПоддержки");
			//СписокИменОбязательныхРеквизитов.Добавить("ОсновныеДанные_РегистрационныйНомерПрограммы");
			//СписокИменОбязательныхРеквизитов.Добавить("Владелец_Организация");
			return null;
		}
		// ПроверитьСтруктуруЗаполненияПараметровДляОтправкиСообщенияВОтделТехническойПоддержки()
		// Процедура формирует таблицу значений со структурой для заполнения данными
		// с информацией обращения в отдел технической поддержки
		//
		// Параметры:
		//  ТаблицаДанных - таблица значений для заполнения
		//  ФормаНастройкиПараметров - общая форма настройки параметров для отправки в отдел технической поддержки
		//

		public void ЗаполнитьСтруктуруДанныхНастройкиОбращенияВОтделТехподдержкиПоУмолчанию(/*ТаблицаДанных, ФормаНастройкиПараметров = Неопределено*/)
		{
			/*// Структура данных - таблица значений:
*/
			/*//  Колонки:
*/
			/*//   ИмяРездела
*/
			/*//   ПредставлениеРаздела
*/
			/*//   ДанныеРаздела
*/
			/*// Структура данных раздела
*/
			/*//  Ключ - Имя значения настройки, как оно задано в форме настройки параметров обращения
*/
			/*//  Значение - Массив значений
*/
			/*// 
*/
			/*// Массив значений:
*/
			/*//  [0] - Представление наименования параметра для печати
*/
			/*//  [1] - Значение параметра
*/
			if(true/*ТипЗнч(ТаблицаДанных) <> Тип("ТаблицаЗначений")*/)
			{
				//ТаблицаДанных = Новый ТаблицаЗначений;
			}
			if(true/*ТаблицаДанных.Колонки.Количество() = 0*/)
			{
				//ТаблицаДанных.Колонки.Добавить("ИндексСортировки"    , Новый ОписаниеТипов("Число"));
				//ТаблицаДанных.Колонки.Добавить("ИмяРаздела"          , Новый ОписаниеТипов("Строка"));
				//ТаблицаДанных.Колонки.Добавить("ПредставлениеРаздела", Новый ОписаниеТипов("Строка"));
				//ТаблицаДанных.Колонки.Добавить("ДанныеРаздела"       , Новый ОписаниеТипов("Структура"));
			}
			//ТаблицаДанных.Индексы.Добавить("ИмяРаздела");
			if(true/*ФормаНастройкиПараметров = Неопределено*/)
			{
				//ФормаНастройкиПараметров = ПолучитьОбщуюФорму("НастройкаПараметровОбращенияВОтделТехническойПоддержки");
			}
			//ТаблицаДанных.Сортировать("ИндексСортировки ВОЗР");
		}
		// Функция формирует текст сообщения на линию техподдержки
		//
		// Параметры
		//  НЕТ
		//
		// Возвращаемое значение:
		//   Текст сообщения
		//

		public object ПолучитьТекстСообщенияВОтделТехническойПоддержки(/**/)
		{
			//ТекстВозврата = "";
			//ТекстВозврата = ТекстВозврата + Символы.ПС;
			//ТекстВозврата = ТекстВозврата + Символы.ПС;
			//ТекстВозврата = ТекстВозврата + Символы.ПС + "============ Сведения об использовании ПП 1С:Предприятие 8 ============";
			//ТаблицаДанных = Константы.ПараметрыСообщенияПриОбращенииВОтделТехническойПоддержки.Получить().Получить();
			/*// Сформируем обязательный информационный раздел
*/
			//СистемИнфо = Новый СистемнаяИнформация;
			//ТекстВозврата = ТекстВозврата + Символы.ПС;
			//ТекстВозврата = ТекстВозврата + Символы.ПС + "1. ДАННЫЕ ТЕКУЩЕГО КОМПЬЮТЕРА И КОНФИГУРАЦИИ";
			//ТекстВозврата = ТекстВозврата + Символы.ПС + "Версия 1С:Предприятия 8: "   + СистемИнфо.ВерсияПриложения;
			//ТекстВозврата = ТекстВозврата + Символы.ПС + "Конфигурация: "              + Метаданные.Синоним;
			//ТекстВозврата = ТекстВозврата + Символы.ПС + "Версия конфигурации: "       + Метаданные.Версия;
			//ТекстВозврата = ТекстВозврата + Символы.ПС + "Поставщик: "                 + Метаданные.Поставщик;
			//ТекстВозврата = ТекстВозврата + Символы.ПС + "Операционная система: "      + СистемИнфо.ВерсияОС;
			//ТекстВозврата = ТекстВозврата + Символы.ПС + "Оперативная память (МБ): "   + СистемИнфо.ОперативнаяПамять;
			//ТекстВозврата = ТекстВозврата + Символы.ПС + "Процессор: "                 + СистемИнфо.Процессор;
			//НомерСтрокиРаздела = 1;
			if(true/*ТипЗнч(ТаблицаДанных) = Тип("ТаблицаЗначений")*/)
			{
			}
			return null;
		}
		// ПолучитьТекстСообщенияВОтделТехническойПоддержки()
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ТИПАМИ
		// Служебная функция, предназначенная для получения описания типов строки, заданной длины.
		//
		// Параметры:
		//  ДлинаСтроки - число, длина строки.
		//
		// Возвращаемое значение:
		//  Объект "ОписаниеТипов" для строки указанной длины.
		//

		public object ПолучитьОписаниеТиповСтроки(/*ДлинаСтроки*/)
		{
			return null;
		}
		// ПолучитьОписаниеТиповСтроки()
		// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
		//
		// Параметры:
		//  Разрядность 			- число, разряд числа.
		//  РазрядностьДробнойЧасти - число, разряд дробной части.
		//
		// Возвращаемое значение:
		//  Объект "ОписаниеТипов" для числа указанной разрядности.
		//

		public object ПолучитьОписаниеТиповЧисла(/*Разрядность, РазрядностьДробнойЧасти = 0, ЗнакЧисла = Неопределено*/)
		{
			if(true/*ЗнакЧисла = Неопределено*/)
			{
				//КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти);
			}
			return null;
		}
		// ПолучитьОписаниеТиповЧисла()
		// Служебная функция, предназначенная для получения описания типов даты
		//
		// Параметры:
		//  ЧастиДаты - системное перечисление ЧастиДаты.
		//

		public object ПолучитьОписаниеТиповДаты(/*ЧастиДаты*/)
		{
			return null;
		}
		// ПолучитьОписаниеТиповДаты()
		//функция выполняет приведение строки к числу
		// Параметры:
		//  ЧислоСтрокой           - Строка - Строка приводимая к числу
		//  ВозвращатьНеопределено - Булево - Если Истина и строка содержит некорректное значение, то возвращать Неопределено
		//
		// Возвращаемое значение:
		//  Число
		//

		public object ПривестиСтрокуКЧислу(/*ЧислоСтрокой, ВозвращатьНеопределено = Ложь*/)
		{
			//ОписаниеТипаЧисла = Новый ОписаниеТипов("Число");
			//ЗначениеЧисла = ОписаниеТипаЧисла.ПривестиЗначение(ЧислоСтрокой);
			if(true/*ВозвращатьНеопределено И (ЗначениеЧисла = 0)*/)
			{
				//Стр = Строка(ЧислоСтрокой);
				if(true/*Стр = ""*/)
				{
				}
				//Стр = СтрЗаменить(СокрЛП(Стр), "0", "");
				if(true/*(Стр <> "") И (Стр <> ".") И (Стр <> ",")*/)
				{
				}
			}
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ СО СВОЙСТВАМИ И КАТЕГОРИЯМИ ОБЪЕКТОВ
		//Функция возвращает список доступных назначений для "Свойств и категорий объектов"
		//по переданной ссылке
		// Параметры:
		//	Ссылка - Ссылка на справочник или документ
		//
		// Возвращаемое значение:
		// Список значений: доступные назначения для свойств и категорий

		public object ПолучитьСписокНазначенийСвойствКатегорийОбъектовПоСсылке(/*Ссылка*/)
		{
			//Результат = Новый СписокЗначений;
			if(true/*Ссылка = Неопределено*/)
			{
			}
			//ТипСсылки = ТипЗнч(Ссылка);
			//ЭтоХарактеристика = (ТипСсылки = Тип("СправочникСсылка.ХарактеристикиНоменклатуры"));
			//Запрос = Новый Запрос;
			//Запрос.УстановитьПараметр("НазначениеХарактеристика", ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_ХарактеристикиНоменклатуры);
			/*ТекстЗапроса = "
	|ВЫБРАТЬ
	|	Назначения.Ссылка КАК Ссылка,
	|	Назначения.ТипЗначения КАК ТипЗначения
	|ИЗ
	|	ПланВидовХарактеристик.НазначенияСвойствКатегорийОбъектов КАК Назначения
	|ГДЕ
	|	НЕ Назначения.ЭтоГруппа
	|";*/
			if(true/*ЭтоХарактеристика*/)
			{
				/*ТекстЗапроса = ТекстЗапроса + "
		|	И Назначения.Ссылка = &НазначениеХарактеристика
		|";*/
			}
			//Запрос.Текст = ТекстЗапроса;
			//Выборка = Запрос.Выполнить().Выбрать();
			while(true/*Выборка.Следующий()*/)
			{
				if(true/*ЭтоХарактеристика Или Выборка.ТипЗначения.СодержитТип(ТипСсылки)*/)
				{
					//Результат.Добавить(Выборка.Ссылка);
				}
			}
			return null;
		}
		// ПолучитьСписокНазначенийСвойствКатегорийОбъектовПоСсылке()
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МАССИВАМИ
		// функция ищет элемент в массиве. Если находит - возвращает его индекс, иначе -1

		public object ВернутьИндексВМассиве(/*МассивДанные, Элемент*/)
		{
			if(true/*МассивДанные = Неопределено*/)
			{
			}
			/*// не нашли элемент
*/
			return null;
		}
		// Удаление из массива пустых элементов
		//
		// Параметры:
		//   МассивЭлементов - Массив
		//

		public void УдалитьНеЗаполненныеЭлементыМассива(/*МассивЭлементов*/)
		{
			//Колво = МассивЭлементов.Количество();
		}
		////////////////////////////////////////////////////////////////////////////////
		//  ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УНИВЕРСАЛЬНЫМИ КОЛЛЕКЦИЯМИ ЗНАЧЕНИЙ
		// Создает копию переданного массива, структуры или соответствия
		//
		// Параметры:
		//  КоллекцияИсходная: тип Массив, Структура, Соответствие - исходная коллекция
		// Возвращаемое значение:
		//  КоллекцияКопия:  тип Массив, Структура, Соответствие - копия исходной коллекции
		//

		public object СкопироватьУниверсальнуюКоллекцию(/*КоллекцияИсходная*/)
		{
			if(true/*ТипЗнч(КоллекцияИсходная)=Тип("Массив")*/)
			{
				//КоллекцияКопия=Новый Массив;
			}
			return null;
		}
		// СкопироватьУниверсальнуюКоллекцию()
		// Разворачивает таблицу  значений по вложенной таблице
		//
		// Параметры
		//  ТаблицаЗначений  – <ТаблицаЗначений> – базовая таблица
		//  КолонкаВложеннойТаблицы  – <Строка> – Наименование колонки влолженной таблицы
		//  СписокРаспределяемыхКолонок  – <Структура> – Структура с именами колонок базовой таблицы, значения которых будут распределяться по колонке вложенной таблицы
		//         						Ключ - Имя колонки базовой таблицы
		//         						Значение - Имя колонки вложенной таблицы. Если во вложенной таблице колонка не обнаружена - обработка прекращается.
		// Возвращаемое значение:
		//   <ТаблицаЗначений>   – таблица значений, развернутая по значениям вложенной таблицы.
		//
		// При совпадении имен базовой и вложенной таблиц - если

		public object РазвернутьПоВложеннойТаблице(/*ТаблицаЗначений, КолонкаВложеннойТаблицы,СписокРаспределяемыхКолонок, СписокИсключаемыхКолонок, СообщатьОбОшибке = Истина*/)
		{
			if(true/*ТаблицаЗначений.Количество()=0*/)
			{
				/*// Таблица не заполнена, софрмировать новую таблицу не представляется возможнным
*/
				/*// Отсуттствует вложенная таблица, структуру данных выходной таблицы сформировать невозможно
*/
				if(true/*СообщатьОбОшибке*/)
				{
					//СообщитьОбОшибке("Отсутствуют строки в базовой таблице, распределение по вложенной таблице невозможно.",,,СтатусСообщения.Внимание);
				}
			}
			//КолонкиВложеннойТаблицы = ТаблицаЗначений[0][КолонкаВложеннойТаблицы].Колонки;
			/*//Заполним значения по тем колонкам, по которым не были заполены значения ранее
*/
			//НоваяТаблицаЗначений = Новый ТаблицаЗначений();
			/*// Для каждого СтрокаБазовойТаблицы Из ТаблицаЗначений Цикл 
*/
			/*// Распределение базовых данных по распределяемым колонкам
*/
			//НоваяТаблицаЗначений = СформироватьКорректирующиеЗаписи(ТаблицаЗначений,НоваяТаблицаЗначений,СписокРаспределяемыхКолонок);
			return null;
		}
		// РазвернутьПоВложеннойТаблице()
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ ВЫВОДА СООБЩЕНИЙ

		public object ОпределитьВажностьСобытияЖурналаРегистрации(/*Статус*/)
		{
			//ВидСобытия = УровеньЖурналаРегистрации.Информация;
			if(true/*Статус = СтатусСообщения.Внимание*/)
			{
				//ВидСобытия = УровеньЖурналаРегистрации.Предупреждение;
			}
			return null;
		}
		//Процедура проверяет необходимость вывода сообщения в журнал регистрации, при необходимости выводит сообщение в журнал регистрации
		// Параметры:
		//	ТекстСообщения - Строка - Текст сообщения
		//	Статус - ПеречислениеСсылка.ВидыСообщений - Вид сообщения
		//		   - СтатусСообщения - Статус сообщения (используется для совместимости со старыми вызовами процедуры Сообщить)
		//	Заголовок - Строка - Текст заголовка
		//

		public void ДублироватьСообщениеВЖурналРегистрации(/*ТекстСообщения, Статус, Заголовок=""*/)
		{
			/*//Если сообщение выводится во внешнем соединении, оно всегда должно быть выведено в журнал регистрации (независимо от настроек)
*/
			/*//Это необходимо для того, чтобы в ЖР были видны сообщения при автоматическом обновлении
*/
			//ДублироватьСообщенияВЖурналРегистрации = глЗначениеПеременной("ДублироватьСообщенияВЖурналРегистрации");
			if(true/*НЕ ДублироватьСообщенияВЖурналРегистрации*/)
			{
			}
			//Важность = ОпределитьВажностьСобытияЖурналаРегистрации(Статус);
			if(true/*Заголовок <> ""*/)
			{
				/*//вывод заголовка как отдельной записи в журнал
*/
				//ЗаписьЖурналаРегистрации("Сообщение", УровеньЖурналаРегистрации.Примечание, , ,Заголовок);
			}
			//ЗаписьЖурналаРегистрации("Сообщение", Важность, , ,ТекстСообщения);
		}
		// Процедура выводит пользователю сообщение: в журнал регистрации, в панель комментариев, в окно сообщений (в зависимости от настроек).
		//
		// Параметры:
		//	ТекстСообщения - Строка - Текст сообщения
		//	Статус - ПеречислениеСсылка.ВидыСообщений - Вид сообщения
		//		   - СтатусСообщения - Статус сообщения (используется для совместимости со старыми вызовами процедуры Сообщить)
		//	Заголовок - Строка - Текст заголовка
		//	РасшифровкаСообщения - Массив - Массив с данными расшифровки
		//						 - Ссылка - Ссылка на объект
		//	СтрокаРодитель - Родительская строка дерева значений для вывода сообщения
		//	РаскрытьСообщение - Булево - Признак раскрытия строки дерева сообщений
		//
		// Возвращаемое значение:
		//	СтрокаДереваЗначенний - Строка дерева значений, в которую записано текущее сообщение
		//Если вывод сообщений в панель комментариев не предусмотрен, возвращается Неопределено

		public object Сообщение(/*Знач ТекстСообщения, Статус = Неопределено, Заголовок = "", РасшифровкаСообщения = Неопределено, СтрокаРодитель = Неопределено, РаскрытьСообщение = Истина, ЭтоСообщениеОбОшибке = Ложь*/)
		{
			//ДублироватьСообщениеВЖурналРегистрации(ТекстСообщения, Статус, Заголовок);
			//СтрокаДереваЗначений = ВыводСообщений.ВывестиСообщениеВПанельКомментариев(ТекстСообщения, Статус, Заголовок, РасшифровкаСообщения, СтрокаРодитель, РаскрытьСообщение);
			if(true/*СтрокаДереваЗначений = Неопределено*/)
			{
				/*//Сообщение в панель комментариев не выведено, значит необходимо вывести его в окно сообщений
*/
				//ВыводСообщений.ВывестиСообщениеВОкноСообщений(ТекстСообщения, Статус, Заголовок, РасшифровкаСообщения, ЭтоСообщениеОбОшибке);
			}
			return null;
		}
		// Сообщение()
		////////////////////////////////////////////////////////////////////////////////
		// ВЫВОД ТРАССИРОВОЧНЫХ СООБЩЕНИЙ

		public void СообщитьОСостоянииОбновления(/*Подсистема, Действие, Комментарий="", Уровень=0, флЗавершающее=ложь*/)
		{
			//СтрокаТабуляций = "";
			if(true/*флЗавершающее*/)
			{
				//ВидСообщенияе = СтатусСообщения.Информация;
			}
			//ОбщегоНазначения.Сообщение(СтрокаТабуляций + Подсистема + ": " + Действие + ?(Комментарий = "",""," (" + Комментарий + ")"),ВидСообщения);
		}

		public void СообщитьОСостоянииИзмененияНастройки(/*ИмяНастройки,Действие, Комментарий="", Уровень=0,текСтатусСообщения=неопределено*/)
		{
			if(true/*текСтатусСообщения = неопределено*/)
			{
				//СтатусСообщенияДляВывода = СтатусСообщения.Информация;
			}
			//СтрокаТабуляций = "";
			//ОбщегоНазначения.Сообщение(СтрокаТабуляций + "Настройка учета: "+ИмяНастройки+". "+Действие + ?(Комментарий = "",""," (" + Комментарий + ")"),СтатусСообщенияДляВывода);
		}
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ОШИБКАМИ
		// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина".
		// В случае работы на клиенте вывобит сообщение в обработку комментирования
		// на сервере выводит в окно сообщений,
		// в случае внешнего соединения вызывает исключение.
		//
		// Параметры:
		//  ТекстСообщения  - строка, текст сообщения.
		//					  Строка может содержать символы %%, которые при формировании
		//					  сообщения заменяются на представления элементов расшифровки
		//  Отказ           - булево, признак отказа (необязательный).
		//  Заголовок	    - Заголовок сообщения, для вывода сообщения если работа на сервере или внешнее соединение
		//	Расшифровки 	- массив расшифровок для переданного ТекстСообщения
		//					  Представляет собой массив структур с полями Представление и Расшифровка
		//					  Поле Представление - текст, дополняющий ТекстСообщения
		//					  Поле Расшифровка - действие, выполняемое по расшифровке
		//

		public void ВывестиИнформациюОбОшибке(/*Знач ТекстСообщения, Отказ = Истина, Заголовок = "", ВидСообщения = Неопределено, Расшифровки = Неопределено, РодительскаяСтрока = НеОпределено, РаскрытьСообщение = Истина*/)
		{
			//Отказ = Истина;
			if(true/*ВидСообщения = Неопределено*/)
			{
				//ВидСообщения = Перечисления.ВидыСообщений.Ошибка;
			}
			//Обработка = глЗначениеПеременной("глОбработкаСообщений");
			//Обработка.ДобавитьСообщение(ТекстСообщения, ВидСообщения, Расшифровки, РодительскаяСтрока, РаскрытьСообщение);
			//ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);
			if(true/*ЗначениеЗаполнено(Заголовок)*/)
			{
				//ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
				//Заголовок = "";
			}
			//ВызватьИсключение (ТекстСообщения);
			if(true/*ЗначениеЗаполнено(Заголовок)*/)
			{
				//Сообщить(Заголовок);
				//Заголовок = "";
			}
			//ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);
			//Сообщить(ТекстСообщения, СтатусСообщения.Важное);
		}
		// ВывестиИнформациюОбОшибке()
		// Функция убирает из текста сообщения служебную информацию.
		//
		// Параметры:
		//  ТекстСообщения, Строка, исходный текст сообщения
		//
		// Возвращаемое значение:
		//   Строка
		//

		public object СформироватьТекстСообщения(/*Знач ТекстСообщения*/)
		{
			//НачалоСлужебногоСообщения    = Найти(ТекстСообщения, "{");
			//ОкончаниеСлужебногоСообщения = Найти(ТекстСообщения, "}:");
			if(true/*ОкончаниеСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения < ОкончаниеСлужебногоСообщения*/)
			{
				/*ТекстСообщения = Лев(ТекстСообщения, (НачалоСлужебногоСообщения - 1)) +
		                 Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2));*/
			}
			return null;
		}

		public void СообщитьИнформациюПользователю(/*СтрокаСообщенияПользователю*/)
		{
			//Сообщить(СтрокаСообщенияПользователю);
		}
		// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина".
		// В случае работы на клиенте или на сервере выводит в окно сообщений,
		// в случае внешнего соединения вызывает исключение.
		//
		// Параметры:
		//  ТекстСообщения - строка, текст сообщения.
		//  Отказ          - булево, признак отказа (необязательный).
		//	Заголовок - Строка - Текст заголовка
		//          (выводится пользователю в режиме обычного приложения;
		//           в заголовке должен быть описан контекст выполняемых действий, например "Проведение документа №... от ...")
		//	Статус - СтатусСообщения - Статус сообщения
		//	РасшифровкаСообщения - Массив - Массив с данными расшифровки
		//						 - Ссылка - Ссылка на объект
		//

		public void СообщитьОбОшибке(/*
	Знач ТекстСообщения, 
	Отказ = Ложь, 
	Заголовок = "",
	Статус = Неопределено,
	РасшифровкаСообщения = Неопределено
	*/)
		{
			if(true/*Статус = Неопределено*/)
			{
				//Статус = СтатусСообщения.Важное;
			}
			//ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);
			//Отказ = Истина;
			/*//Для клиента и сервера запись в журнал регистрации попадет внутри процедуры Сообщение
*/
			//ДублироватьСообщениеВЖурналРегистрации(ТекстСообщения, Статус, Заголовок);
			if(true/*ЗначениеЗаполнено(Заголовок)*/)
			{
				//ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
				//Заголовок = "";
			}
			//ВызватьИсключение (ТекстСообщения);
			//Сообщение(ТекстСообщения, Статус, Заголовок, РасшифровкаСообщения, Неопределено, Истина, Истина);
		}
		// СообщитьОбОшибке()

		public void ПоказатьДиалогСИнформациейОбОшибке(/*ИнформацияОбОшибке*/)
		{
			//ПоказатьИнформациюОбОшибке(ИнформацияОбОшибке);
			//СообщитьОбОшибке(ПолучитьПричинуОшибки(ИнформацияОбОшибке).Описание);
		}
		// Выводит сообщение "пользовательского" вида о невозможности заблокировать объект
		//

		public void СообщитьОбъектЗаблокирован(/*ПредставлениеОбъекта, ПредставлениеТипа, Отказ = Ложь*/)
		{
			//ТекстСообщения = "Не удалось записать " + ПредставлениеТипа + " " + ПредставлениеОбъекта + "!" + Символы.ПС + "Возможно, его данные редактируются другим пользователем.";
			//ТекстЗаголовка = "Ошибка блокировки объекта";
			//Отказ = Истина;
			//РаботаСДиалогами.ВывестиПредупреждение(ТекстСообщения, ТекстЗаголовка);
			//СообщитьОбОшибке(ТекстСообщения, , ТекстЗаголовка);
		}
		// СообщитьОбъектЗаблокирован
		// Формирует строку представления документа для сообщений при проведении.
		//
		// Параметры
		//  Источник - структура шапки или ссылка на проводимый документ.
		//
		// Возвращаемое значение
		//  Строка с представлением документа
		//

		public object ПредставлениеДокументаПриПроведении(/*Источник*/)
		{
			if(true/*ТипЗнч(Источник) = Тип("Структура")*/)
			{
				//ПредставлениеДокумента = Источник.ПредставлениеДокумента;
				if(true/*Источник.Свойство("ВидОперации")*/)
				{
					//ПредставлениеДокумента = ПредставлениеДокумента + " (" + Источник.ВидОперации + ")";
				}
			}
			//ПредставлениеДокумента = "Проведение документа: " + ПредставлениеДокумента;
			return null;
		}
		// ПредставлениеДокументаПриПроведении
		// Предназначена для получения запросом представлений объектов
		// Поддерживает два синтаксиса
		// 1.
		// Параметры:
		//	СсылкиОбъектовПарам - массив ссылок
		// Возвращаемое значение
		//	Соответствие в котором ключ - одна из переданных ссылок,
		//  а значение - представление этой ссылки
		// 2.
		// Параметры:
		//	СсылкиОбъектовПарам - ссылка
		// Возвращаемое значение
		//	Строка предсатвления ссылки
		//
		// Пример использования:
		// 	МассивСсылок = Новый Массив;
		// 	МассивСсылок.Добавить(НоваяОрганизация);
		// 	МассивСсылок.Добавить(СтараяОрганизация);
		// 	Представления = ПолучитьПредставленияОбъектов(МассивСсылок);
		//	НоваяОрганизацияСтрокой = Представления[НоваяОрганизация];
		//	СтараяОрганизацияСтрокой = Представления[СтараяОрганизация];
		//

		public object ПолучитьПредставленияОбъектов(/*СсылкиОбъектовПарам*/)
		{
			/*// соответствие возвращается если передан массив ссылок
*/
			//ПереданМассив = Истина;
			/*// Если передано одиночное значение - "превратим" его в массив
*/
			if(true/*ТипЗнч(СсылкиОбъектовПарам) <> Тип("Массив")*/)
			{
				//Ссылка = СсылкиОбъектовПарам;
				//СсылкиОбъектов = Новый Массив;
				//СсылкиОбъектов.Добавить(Ссылка);
				//ПереданМассив = Ложь;
			}
			/*// Обработаем массив СсылкиОбъектов и сформируем 
*/
			/*// соответствие ссылок по их типам
*/
			//СсылкиПоТипам = Новый Соответствие;
			/*// формирование запроса
*/
			//ТекстЗапроса = "";
			//Запрос = Новый Запрос;
			//ПервоеЗначение = Истина;
			/*// обработка запроса
*/
			//Запрос.Текст = ТекстЗапроса;
			//Выборка = Запрос.Выполнить().Выбрать();
			if(true/*ПереданМассив*/)
			{
				//ВозвращаемоеСоответствие = Новый Соответствие;
				while(true/*Выборка.Следующий()*/)
				{
					//ВозвращаемоеСоответствие[Выборка.Ссылка] = Выборка.Представление;
				}
				/*// дополним пустыми представлениями неполученных запросом ссылок
*/
			}
			return null;
		}
		// Проверяет принадлежность документа к видам учета
		//
		// Параметры:
		//  СтруктураШапкиДокумента - структура, содержащая реквизиты шапки документа
		//  Отказ                   - флаг отказа в проведении.
		//  Заголовок               - строка, заголовок сообщения об ошибке проведения.
		//  МожетБытьТолькоНалоговый- строка, заголовок сообщения об ошибке проведения.
		//

		public void ПроверитьПринадлежностьКВидамУчета(/*СтруктураШапкиДокумента, Отказ, Заголовок, МожетБытьТолькоНалоговый = Ложь*/)
		{
			//ЕстьУпр = СтруктураШапкиДокумента.Свойство("ОтражатьВУправленческомУчете", Упр);
			//ЕстьБух = СтруктураШапкиДокумента.Свойство("ОтражатьВБухгалтерскомУчете", Бух);
			//ЕстьНал = СтруктураШапкиДокумента.Свойство("ОтражатьВНалоговомУчете", Нал);
			if(true/*ЕстьУпр ИЛИ ЕстьБух ИЛИ ЕстьНал*/)
			{
				if(true/*НЕ МожетБытьТолькоНалоговый*/)
				{
					if(true/*Упр <> Истина И Бух <> Истина*/)
					{
						//СообщитьОбОшибке("Документ должен принадлежать хотя бы одному из видов учета: ""Управленческий"" и (или)  ""Бухгалтерский"".", Отказ, Заголовок);
					}
				}
			}
		}
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ПЕРЕЧИСЛЕНИЯМИ
		// Функция формирует список элементов перечисления
		//
		// Параметры
		//  ИмяПеречисления - имя перечисления, как оно задано в конфигураторе
		//
		// Возвращаемое значение:
		//   СписокЗначений - список элементов перечисления
		//

		public object ПолучитьСписокЭлементовПеречисления(/*ИмяПеречисления*/)
		{
			//СписокЭлементовПеречисления = Новый СписокЗначений;
			return null;
		}
		// ПолучитьСписокЭлементовПеречисления()
		// Процедура проверяет переданный параметр, если он не соответствует значению,
		// то присваивает ему указанное значение.
		//
		// Параметры:
		//  Параметр - параметр, значение которого проверяется и заполняется.
		//  Значение - значение для заполнения пустого параметра.
		//

		public void УстановитьНовоеЗначение(/*Параметр, Значение*/)
		{
			if(true/*Параметр <> Значение*/)
			{
				//Параметр = Значение;
			}
		}
		// Предназначена для получения имени элемента перечисления по значению.
		//
		// Параметры:
		//	Элемент перечисления.
		//
		// Возвращаемое значение:
		//	Строка - имя элемента перечисления в метаданных.
		//

		public object ПолучитьИмяЭлементаПеречисленияПоЗначению(/*ЗначениеПеречисления*/)
		{
			//ИмяЭлемента = Строка(ЗначениеПеречисления);
			return null;
		}
		// ПолучитьПериодичностьДляЗапросаПоЗначениюПеречисления()
		// сравнение значений перечислений на больше/меньше
		// применяется для перечислений, для которых последовательность
		// значений имеет определяющее значение
		//
		// Параметры:
		//  Значение1, Значение2 - сравниваемые значения перечислений
		//
		// Возвращаемое значение: число
		//   1 - если Значение1 > Значение2
		//  -1 - если Значение1 < Значение2
		//   0 - если Значение1 = Значение2
		//

		public object СравнениеПеречислений(/*Значение1, Значение2*/)
		{
			//ИмяПеречисления = Метаданные.НайтиПоТипу(ТипЗнч(Значение1)).Имя;
			//Менеджер = Перечисления[ИмяПеречисления];
			if(true/*Менеджер.Индекс(Значение1) > Менеджер.Индекс(Значение2)*/)
			{
			}
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕТАДАННЫМИ
		// Функция возвращает имя табличной части, к которой принадлежит переданная строка
		//
		// Параметры
		//  СтрокаТабличнойЧасти - ссылка на строку табличной части
		//
		// Возвращаемое значение:
		//   Строка - имя табличной части, как оно задано в конфигураторе
		//

		public object ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку(/*СтрокаТабличнойЧасти*/)
		{
			//ИмяТабличнойЧасти = Метаданные.НайтиПоТипу(ТипЗнч(СтрокаТабличнойЧасти)).Имя;
			return null;
		}
		// ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку()
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ДВИЖЕНИЯМИ ДОКУМЕНТОВ
		// Функция возвращает массив, который содержит имена регистров
		// движения которых не надо удалять при очистке движений перед перепроведением
		//	Остатки, движения по таким регистрам не используются
		// 		ни в процедурах контроля остатков (товаров, задолженностей)
		// 		ни в логике формирования других движений (например, партии, авансы)
		//

		public object ПолучитьРегистрыДляОптимизацииПерезаписиДвижений(/*ТекущийРежимПроведенияДокумента*/)
		{
			//МассивРегистров = Новый Массив;
			/*//В список регистров могут быть включены только те, движения которых записываются через коллекцию движений (Движения.<...>), 
*/
			/*//а не через набор записей 
*/
			/*// Регистры вида "Обороты", которые 
*/
			/*//- не используются для формирования движений 
*/
			/*//- двигаются документами, для которых применяется выборочное удаление движений
*/
			//МассивРегистров.Добавить("ДвиженияДенежныхСредств");
			//МассивРегистров.Добавить("Закупки");
			//МассивРегистров.Добавить("Продажи");
			/*// Далее перечислены регистры, которые используются для контроля остатков, формирования движений 
*/
			/*// только при оперативном проведении. Их 
*/
			/*// - следует очищать если документ проводится оперативно
*/
			/*// - можно не очищать, если документ проводится неоперативно
*/
			if(true/*ТекущийРежимПроведенияДокумента = РежимПроведенияДокумента.Неоперативный*/)
			{
				//МассивРегистров.Добавить("ВзаиморасчетыСКонтрагентами");
				//МассивРегистров.Добавить("ДенежныеСредства");
				//МассивРегистров.Добавить("ЗаказыПоставщикам");
				//МассивРегистров.Добавить("РазмещениеЗаказовПокупателей");
				//МассивРегистров.Добавить("РасчетыСКонтрагентами");
				//МассивРегистров.Добавить("ТоварыВНТТ");
				//МассивРегистров.Добавить("ТоварыВРезервеНаСкладах");
				//МассивРегистров.Добавить("ТоварыВРознице");
				//МассивРегистров.Добавить("ТоварыКПередачеОрганизаций");
				//МассивРегистров.Добавить("ТоварыКПередачеСоСкладов");
				//МассивРегистров.Добавить("ТоварыКПеремещениюВНТТ");
				//МассивРегистров.Добавить("ТоварыКПолучениюНаСклады");
				//МассивРегистров.Добавить("ТоварыНаСкладах");
				//МассивРегистров.Добавить("ТоварыОрганизаций");
				//МассивРегистров.Добавить("ТоварыПереданные");
				//МассивРегистров.Добавить("ТоварыПолученные");
			}
			return null;
		}
		// ПолучитьРегистрыДляОптимизацииПерезаписиДвижений
		// Процедура удаления движений документа при перепроведении (отмене проведения)
		//
		// Параметры:
		//	ДокументОбъект 				- документ, движения которого удаляются
		//	Отказ 						- булево, признак отказа
		//	ВыборочноОчищатьРегистры 	- булево, признак выборочной очистки наборов записей
		//								Если Истина - часть наборов записей не будут очищены, будут очищены только коллекции движений
		//	РежимПроведенияДокумента 	- режим проведения (оперативный / неоперативный),
		//								нужен для составления списка регистров, которые не надо очищать
		//	Для документа ПринятиеКУчетуОС предусмотрена отдельная процедура УдалитьДвиженияПринятиеКУчетуОС

		public void УдалитьДвиженияРегистратора(/*ДокументОбъект, Отказ, ВыборочноОчищатьРегистры = Ложь, РежимПроведенияДокумента = Неопределено*/)
		{
			/*// Удалим те движения, которые уже записаны
*/
			//УдалитьЗаписанныеДвиженияДокумента(ДокументОбъект, Отказ, ВыборочноОчищатьРегистры, РежимПроведенияДокумента);
			/*// Очистим непустые коллекции движений документа
*/
			//ОчисткаКоллекцииДвиженийДокумента(ДокументОбъект);
			/*// Удаление записей регистрации из всех последовательностей - после удаления движений по регистрам
*/
			//УдалитьРегистрациюДокументаВПоследовательностях(ДокументОбъект, Истина);
		}
		// Процедура очистки записанных движений документа
		//
		// Параметры:
		//	ДокументОбъект 				- документ, движения которого удаляются
		//	Отказ 						- булево, признак отказа
		//	ВыборочноОчищатьРегистры 	- булево, признак выборочной очистки наборов записей
		//								Если Истина - часть наборов записей не будут очищены, будут очищены только коллекции движений
		//	РежимПроведенияДокумента 	- режим проведения (оперативный / неоперативный),
		//								нужен для составления списка регистров, которые не надо очищать

		public void УдалитьЗаписанныеДвиженияДокумента(/*ДокументОбъект, Отказ, ВыборочноОчищатьРегистры, РежимПроведенияДокумента*/)
		{
			/*// Получим перечень регистров, движения по которым нужно очистить
*/
			//МассивРегистров = ПроведениеДокументов.МассивРегистровНужноОчистить(ДокументОбъект);
			if(true/*МассивРегистров.Количество() = 0*/)
			{
			}
			/*// Если очищать регистры надо выборочно, то подготовим список таких регистров, 
*/
			/*//	которые можно не очищать при перепроведении
*/
			if(true/*ВыборочноОчищатьРегистры*/)
			{
				//РегистрыДляОптимизацииПерезаписиДвижений = ПолучитьРегистрыДляОптимизацииПерезаписиДвижений(РежимПроведенияДокумента);
			}
			/*// Переменные логики отложенного проведения
*/
			//ДокументИспользуетсяВОтложенномПроведении = Ложь;
			//ВыполняетсяДопроведение                   = Ложь;
			//ПроведениеПоВсемВидамУчета                = Ложь;
			//СтруктураПараметровПроведения = ОтложенноеПроведениеДокументов.ПолучитьПараметрыПроведенияДокумента(ДокументОбъект);
			//ДокументИспользуетсяВОтложенномПроведении = СтруктураПараметровПроведения.ДокументИспользуетсяВОтложенномПроведении;
			if(true/*ДокументИспользуетсяВОтложенномПроведении*/)
			{
				//ВыполняетсяДопроведение = СтруктураПараметровПроведения.ВыполняетсяДопроведение;
				//ПроведениеПоВсемВидамУчета = СтруктураПараметровПроведения.ПроведениеПоВсемВидамУчета;
				//РегистрыОтложенногоПроведения = ОтложенноеПроведениеДокументов.ПолучитьРегистрыОтложенногоПроведения();
			}
			/*//Обойдем список регистров, по которым существуют движения, и выполним очистку необходимых регистров
*/
		}
		// Процедура удаления существующих движений документа ПринятиеКУчетуОС при перепроведении
		//	Отличается от универсальной процедуры УдалитьДвиженияРегистратора:
		//	- содержит специфичную для данного документа логику раздельного удаления движений по видам учета
		//	- не учитывает отложенное проведение (т.к. документ в отложенном проведении не участвует)
		//
		// Параметры
		//	ДокументОбъект 			- документ ПринятиеКУчетуОС, движения которого необходимо удалить
		//	СтруктураВидовУчета 	- Структура, содержащая перечень видов учета
		//								Для видов учета, по которым необходимо удалить движения, установлено значение Истина
		//								Движения документа удаляются выборочно - по выбранным видам учета
		//								Это необходимо при проведении по партиям (раздельное проведение документа по УУ, БУ + НУ)

		public void УдалитьЗаписанныеДвиженияДокументаПринятиеКУчетуОС(/*ДокументОбъект, СтруктураВидовУчета*/)
		{
			/*// Получим перечень регистров, движения по которым нужно очистить
*/
			//МассивРегистров = ПроведениеДокументов.МассивРегистровНужноОчистить(ДокументОбъект);
			if(true/*МассивРегистров.Количество() = 0*/)
			{
			}
			/*//Признак - передана ли структура видов учета, в соответствии с которой надо выборочно удалять движения
*/
			//ПроверитьПринадлежностьРегистраКВидамУчета = (СтруктураВидовУчета <> Неопределено И ТипЗНЧ(СтруктураВидовУчета) = Тип("Структура"));
			if(true/*ПроверитьПринадлежностьРегистраКВидамУчета*/)
			{
				/*// Получим список регистров с информацией: к какому виду учета они принадлежат
*/
				/*//	Далее используется при вызове функции РегистрПринадлежитВидамУчета
*/
				//РегистрыПоВидамУчета = ПолучитьРегистрыПоВидамУчета();
			}
			/*//Обойдем список регистров, по которым существуют движения, и выполним очистку необходимых регистров
*/
		}
		//УдалитьЗаписанныеДвиженияДокументаПринятиеКУчетуОС
		// Процедура удаления движений документа ПринятиеКУчетуОС при перепроведении
		//	Отличается от универсальной процедуры УдалитьДвиженияРегистратора:
		//	- содержит специфичную для данного документа логику раздельного удаления движений по видам учета
		//	- не учитывает отложенное проведение (т.к. документ в отложенном проведении не участвует)
		//
		// Параметры
		//	ДокументОбъект 			- документ ПринятиеКУчетуОС, движения которого необходимо удалить
		//	Отказ 					- булево, признак отказа
		//	СтруктураВидовУчета 	- Структура, содержащая перечень видов учета
		//								Для видов учета, по которым необходимо удалить движения, установлено значение Истина
		//								Движения документа удаляются выборочно - по выбранным видам учета
		//								Это необходимо при проведении по партиям (раздельное проведение документа по УУ, БУ + НУ)

		public void УдалитьДвиженияПринятиеКУчетуОС(/*ДокументОбъект, Отказ, СтруктураВидовУчета*/)
		{
			/*// Удалим те движения, которые уже записаны
*/
			//УдалитьЗаписанныеДвиженияДокументаПринятиеКУчетуОС(ДокументОбъект, СтруктураВидовУчета);
			/*// Очистим непустые коллекции движений документа
*/
			//ОчисткаКоллекцииДвиженийДокумента(ДокументОбъект);
			/*// Удалим записи регистрации из всех последовательностей  - после удаления движений по регистрам
*/
			//УдалитьРегистрациюДокументаВПоследовательностях(ДокументОбъект, Истина);
		}
		//УдалитьДвиженияПринятиеКУчетуОС
		// Процедура очищает коллекцию движений документа
		//

		public void ОчисткаКоллекцииДвиженийДокумента(/*ДокументОбъект*/)
		{
			if(true/*ДокументОбъект.Движения.Количество() = 0*/)
			{
			}
		}
		// Добавляет в таблицу значений строки из другой таблицы значений и
		// в них значения колонок с совпадающими наименованиями.
		//
		// Параметры:
		//  ТаблицаИсточник - таблица значений или массив строк таблицы значений, откуда берутся значения.
		//  ТаблицаПриемник - таблица значений, куда добавляются строки.
		//  ЗаполнятьНомераСтрокПоИсточнику - Булево - определяет необходимость сохранения информации
		//		об индексах строк таблицы-источника в таблице-приемнике.
		//		Используется в тех случаях, когда необходимо выполнить сопоставление строк приемника и источника.
		//

		public void ЗагрузитьВТаблицуЗначений(/*ТаблицаИсточник, ТаблицаПриемник, ЗаполнятьНомераСтрокПоИсточнику = Ложь*/)
		{
			/*// Заполним значения в совпадающих колонках.
*/
		}
		// ЗагрузитьВТаблицуЗначений()
		// Проверяет наличие требуемых данных в источнике и Формирует таблицу значений
		//
		// Параметры
		//  Источник  – ТаблицаЗначений или ТабличнаяЧасть или КоллекцияСтрокДереваЗначений с исходными данными
		//
		//  Реквизиты – структура – Структура реквизитов.
		//							Ключ 		- Наименование колонки в источнике
		//							Значение    - Наименование колонки в получаемой ТЗ
		//							Если значение опущено - приравнивается ключу.
		//	ПолучитьНомерСтрокиДокумента - булево
		//	                        Используется только при выгрузке из табличной части документа.
		//							В формируемой таблице создает новую колонку "НомерСтрокиДокумента"
		//								и заполняет её реальными номерами строк
		//
		//  КоллекцияКолонокДереваЗначений - только для коллекции строк дерева значений.
		// Возвращаемое значение:
		//  Таблица значений или Неопределено (если не хватает реквизитов)
		//

		public object СформироватьТаблицуЗначений(/*Источник,Реквизиты=Неопределено,ПолучитьНомерСтрокиДокумента = ложь,ФормироватьОтстутствующиеКолонки=Ложь,КоллекцияКолонокДереваЗначений=Неопределено*/)
		{
			//ЭтоТаблицаЗначений=(ТипЗнч(Источник)= тип("ТаблицаЗначений"));
			//ЭтоСтрокиДереваЗначений=(ТипЗнч(Источник)= тип("КоллекцияСтрокДереваЗначений"));
			if(true/*ЭтоСтрокиДереваЗначений и КоллекцияКолонокДереваЗначений = Неопределено*/)
			{
			}
			if(true/*НЕ ЗначениеЗаполнено(Реквизиты)*/)
			{
				if(true/*ЭтоТаблицаЗначений*/)
				{
					//НоваяТЗ = Источник.Скопировать();
				}
			}
			if(true/*не ЭтоТаблицаЗначений  и не ЭтоСтрокиДереваЗначений*/)
			{
				//РеквизитыТабличнойЧасти = Метаданные.НайтиПоТипу(ТипЗнч(Источник)).Реквизиты;
			}
			//НоваяТЗ= Новый ТаблицаЗначений();
			if(true/*не ЭтоТаблицаЗначений и ПолучитьНомерСтрокиДокумента*/)
			{
				//НоваяТЗ.Колонки.Добавить("НомерСтрокиДокумента",Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(5,0)));
			}
			while(true/*НоваяТЗ.Количество()<Источник.Количество()*/)
			{
				//Строка = НоваяТЗ.Добавить();
				if(true/*не ЭтоТаблицаЗначений и ПолучитьНомерСтрокиДокумента*/)
				{
					//Строка.НомерСтрокиДокумента = НоваяТЗ.Количество();
				}
			}
			return null;
		}
		// СформироватьТаблицуОплаты()
		// Формирует структуру, содержащую значения реквизитов шапки документа.
		//
		// Параметры:
		//  ДокументОбъект - объект документа для формирования структуры шапки.
		//
		// Возвращаемое значение:
		//  Сформированная структура.
		//

		public object СформироватьСтруктуруШапкиДокумента(/*ДокументОбъект*/)
		{
			//СтруктураШапкиДокумента = Новый Структура;
			//СтруктураШапкиДокумента.Вставить("Ссылка", ДокументОбъект.Ссылка);
			//СтруктураШапкиДокумента.Вставить("Дата",   ДокументОбъект.Дата);
			//ТипДокумента = ТипЗнч(ДокументОбъект);
			//МетаданныеДокумента = Метаданные.НайтиПоТипу(ТипДокумента);
			//СтруктураШапкиДокумента.Вставить("ВидДокумента",  				МетаданныеДокумента.Имя);
			//СтруктураШапкиДокумента.Вставить("ПредставлениеДокумента", 		СокрЛП(ДокументОбъект));
			//СтруктураШапкиДокумента.Вставить("ПредставлениеВидаДокумента",  МетаданныеДокумента.Представление());
			/*// Вставим свойства в структуру и далее при необходимости установим некоторые значения в Истину.
*/
			//СтруктураШапкиДокумента.Вставить("ОрганизацияПрименяетУСН", 		 Ложь);
			//СтруктураШапкиДокумента.Вставить("ОтражатьВНалоговомУчетеУСНДоходы", Ложь);
			//СтруктураШапкиДокумента.Вставить("ОтражатьВНалоговомУчетеУСН", 		 Ложь);
			//СтруктураШапкиДокумента.Вставить("ПоддержкаПБУ18", 					 Ложь);
			if(true/*СтруктураШапкиДокумента.Свойство("Организация")
	 И ЗначениеЗаполнено(СтруктураШапкиДокумента.Организация)
	 И СтруктураШапкиДокумента.Свойство("ОтражатьВБухгалтерскомУчете") 
	 И СтруктураШапкиДокумента.ОтражатьВБухгалтерскомУчете*/)
			{
				//УчетнаяПолитика = ПолучитьПараметрыУчетнойПолитикиРегл(СтруктураШапкиДокумента.Дата, СтруктураШапкиДокумента.Организация);
				if(true/*ЗначениеЗаполнено(УчетнаяПолитика)*/)
				{
					//СтруктураШапкиДокумента.ОрганизацияПрименяетУСН = УчетнаяПолитика.УСН;
					if(true/*СтруктураШапкиДокумента.Свойство("ОтражатьВНалоговомУчете") 
			 И СтруктураШапкиДокумента.ОтражатьВНалоговомУчете*/)
					{
						if(true/*УчетнаяПолитика.УСН*/)
						{
							//СтруктураШапкиДокумента.ОтражатьВНалоговомУчете = Ложь;
							if(true/*УчетнаяПолитика.ОбъектНалогообложенияУСН = Перечисления.ОбъектыНалогообложенияПоУСН.Доходы*/)
							{
								//СтруктураШапкиДокумента.ОтражатьВНалоговомУчетеУСНДоходы = Истина;
							}
						}
					}
				}
			}
			return null;
		}
		//Формирует структуру, содержащую значения реквизитов шапки документа.
		//Проверяет признаки отражения в учете
		//При необходимости корректирует признаки отражения в учете в связи с отложенным проведением или допроведением документа
		// Параметры:
		//  ДокументОбъект - объект документа для формирования структуры шапки,
		//	Отказ - признак отказа от проведения документа
		//	Заголовок - строка, заголовок для формирования сообщений об ошибках
		//	МожетБытьТолькоНалоговый - булево, признак того что флаг отражения в НУ может быть установлен независимо от флага отражения в БУ
		// Возвращаемое значение:
		//  Сформированная структура.
		//

		public object СформироватьСтруктуруШапкиДокументаИПроверитьОтражениеВУчете(/*ДокументОбъект, Отказ, Заголовок, МожетБытьТолькоНалоговый = Ложь*/)
		{
			//СтруктураШапкиДокумента = СформироватьСтруктуруШапкиДокумента(ДокументОбъект);
			//ПроверитьПринадлежностьКВидамУчета(СтруктураШапкиДокумента, Отказ, Заголовок);
			if(true/*Отказ*/)
			{
			}
			/*//Проверяем - возможно, документ должен проводиться отложенно
*/
			if(true/*ОтложенноеПроведениеДокументов.ДокументПодерживаетОтложенноеПроведение(ДокументОбъект,СтруктураШапкиДокумента)*/)
			{
				//ОтложенноеПроведениеДокументов.ПодготовитьКПроведениюПоВидамУчета(ДокументОбъект.ДополнительныеСвойства, СтруктураШапкиДокумента);
			}
			return null;
		}
		// Выполняет движение по регистру.
		//
		// Параметры:
		//  НаборДвижений               - набор движений регистра,
		//  ПустыеКолонкиСоставногоТипа - структура, содержащая имена измерений,ресурсов и
		//  реквизитов составного типа, которые могут содержать пустые ссылки.
		//

		public void ВыполнитьДвижениеПоРегистру(/*НаборДвижений, ВидДвижения = Неопределено,
	                                  ПустыеКолонкиСоставногоТипа = Неопределено*/)
		{
			//ТаблицаДвижений = НаборДвижений.мТаблицаДвижений;
			if(true/*ТаблицаДвижений.Количество() = 0*/)
			{
			}
			if(true/*ПустыеКолонкиСоставногоТипа = Неопределено*/)
			{
				//ПустыеКолонкиСоставногоТипа = Новый Структура;
			}
			/*//
*/
			//КолонкиТаблицы = ТаблицаДвижений.Колонки;
			/*//
*/
			//МетаРег = НаборДвижений.Метаданные();
			//ИзмеренияСостТипа = Новый Структура;
			//ИзмеренияСостТипаСтр = "";
			if(true/*ИзмеренияСостТипаСтр <> ""*/)
			{
				//ИзмеренияСостТипаСтр = Сред(ИзмеренияСостТипаСтр, 3);
			}
			//ТипЧисло = Тип("Число");
			//ТипСтрока = Тип("Строка");
			//ТипДата = Тип("Дата");
			//ЕстьПериод = НЕ ТаблицаДвижений.Колонки.Найти("Период") = Неопределено;
		}
		// ВыполнитьДвижениеПоРегистру()
		// Заполняет набор записей регистра СвободныеОстатки по данным базового регистра
		//
		// Параметры:
		//  НаборСвободныеОстатки	- таблица движений регистра СвободныеОстатки, которую нужно заполнить
		//  НаборБазовыйРегистр		- таблица движений регистра (базовый регистр) на основании которого необходимо заполнить регистр СвободныеОстатки
		//  ВидРегистраОснования	- перечисление <ВидыРегистровОснованийРегистраСвободныеОстатки>
		//

		public void ЗаполнитьСвободныеОстаткиПоДаннымБазовогоРегистра(/*НаборСвободныеОстатки, НаборБазовыйРегистр, ВидРегистраОснования*/)
		{
			if(true/*НаборБазовыйРегистр.Количество() = 0*/)
			{
			}
			//ДатаНачалаИспользованияРегистраСвободныеОстатки = глЗначениеПеременной("ДатаНачалаИспользованияРегистраСвободныеОстатки");
			/*// Сначала проверим период записей, потом выполним заполнение
*/
			/*// Считаем, что период всех записей одинаковый
*/
			if(true/*НаборБазовыйРегистр[0].Период < ДатаНачалаИспользованияРегистраСвободныеОстатки*/)
			{
			}
			/*ОбратныйВидДвижения = (ВидРегистраОснования = Перечисления.ВидыРегистровОснованийРегистраСвободныеОстатки.ТоварыВРезервеНаСкладах
							ИЛИ ВидРегистраОснования = Перечисления.ВидыРегистровОснованийРегистраСвободныеОстатки.ТоварыКПередачеСоСкладов);*/
		}
		//
		// Выполняет движения по регистру СвободныеОстатки.
		//
		// Параметры:
		//  НаборДвижений			- таблица движений регистра (базовый регистр) на основании которого необходимо заполнить регистр СвободныеОстатки
		//  Регистратор				- документ, регистратор движений
		//  Замещение				- булево, замещать записи регистра
		//  ВидРегистраОснования	- перечисление <ВидыРегистровОснованийРегистраСвободныеОстатки>
		//

		public void ВыполнитьДвиженияПоРегиструСвободныеОстатки(/*НаборДвижений, Регистратор, Замещение, ВидРегистраОснования, Отказ = Ложь*/)
		{
			if(true/*НЕ глЗначениеПеременной("ИспользоватьРегистрСвободныеОстатки")*/)
			{
			}
			if(true/*ТипЗнч(Регистратор) = Тип("ДокументСсылка.КорректировкаЗаписейРегистров")*/)
			{
				/*// При изменении базовых регистров документом "Корректировка записей регистров"
*/
				/*// не выполняется автоматическое формирование движений по регистру
*/
			}
			//НаборСвободныеОстатки = РегистрыНакопления.СвободныеОстатки.СоздатьНаборЗаписей();
			//НаборСвободныеОстатки.Отбор.Регистратор.Установить(Регистратор);
			//ЗаполнитьСвободныеОстаткиПоДаннымБазовогоРегистра(НаборСвободныеОстатки, НаборДвижений, ВидРегистраОснования);
		}
		// ВыполнитьДвиженияПоРегиструСвободныеОстатки
		// Процедура сворачивает движения по регистру накопления
		//

		public void СвернутьТаблицуДвиженийРегистраНакопления(/*НаборДвижений, ТабДвижений = Неопределено, УдалятьПустыеДвижения = Ложь*/)
		{
			if(true/*ТипЗнч(НаборДвижений) = Тип("Строка")*/)
			{
				//МетаРег = Метаданные.РегистрыНакопления[НаборДвижений];
				//ТаблицаДвижений = ТабДвижений;
			}
			if(true/*ТаблицаДвижений = Неопределено ИЛИ ТаблицаДвижений.Количество() = 0*/)
			{
			}
			//Измерения = "Период,Регистратор,Активность";
			if(true/*МетаРег.ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Остатки*/)
			{
				//Измерения = Измерения + ",ВидДвижения";
			}
			//Ресурсы = "";
			//ТаблицаДвижений.Свернуть(Измерения, Ресурсы);
			if(true/*УдалятьПустыеДвижения*/)
			{
				//СтруктРесурсы   = Новый Структура(Ресурсы);
				//МассивПустСтрок = Новый Массив;
				//СтруктПоиска    = Новый Структура;
				//МассивПустСтрок = ТаблицаДвижений.НайтиСтроки(СтруктПоиска);
			}
		}
		// СвернутьТаблицуДвиженийРегистраНакопления()
		// Получить движение(набор записей) для документа-объекта
		//
		// Параметры
		//  Объект  – 	ДокументОбъект – Документ. для которого производится поиск движения
		//  ТипДвижения  – Регистр<...>Менеджер – менеджер регистра, движение по которому пытаемся сформировать
		//             или <Строка> - имя регистра, движение по которому пытаемся сформировать
		//
		// Возвращаемое значение:
		//   Регистр<...>НаборЗаписей   – набор записей для объекта
		//   или Неопределено - если такого регистра не существует или документ не является регистратором регистра
		//

		public object ПолучитьДвижение(/*Объект, ТипДвижения, Сообщать=Ложь*/)
		{
			if(true/*ТипЗнч(ТипДвижения) = Тип("Строка")*/)
			{
				//Движение = Объект.Движения.Найти(ТипДвижения);
				//ДвижениеНевозможно = Движение = Неопределено;
			}
			if(true/*Сообщать И ДвижениеНевозможно*/)
			{
				if(true/*ТипЗнч(ТипДвижения) = Тип("Строка")*/)
				{
					//ПредставлениеТипаДвижения = ТипДвижения;
				}
				//СообщитьОбОшибке("Требуется подключение """ + ТипЗнч(Объект) + """ к формированиям движения по регистру """ + ПредставлениеТипаДвижения + """!");
			}
			return null;
		}
		// ПолучитьДвижение()
		// Получить набор записей по регистру по ссылке на документ
		//
		// Параметры
		//  Ссылка  		– ДокументСсылка		– Ссылка на документ, для которого производится поиск движений по регистру (набора записей)
		//  РегистрДвижения – Регистр<...>Менеджер	– менеджер регистра, движение по которому пытаемся обнаружить
		//  ПрочитатьЗаписи - Булево 				- Прочитать существующий набор записей для документа (если документ может формировать движения по указанному регистру).
		//
		// Возвращаемое значение:
		//   Регистр<...>НаборЗаписей – Набор записей по регистру с отбором по документу,
		//	 Неопределено 				в случае если документ не может формировать движений по регистру.
		//

		public object ПолучитьНаборЗаписейПоСсылке(/*Ссылка, РегистрДвижения, ПрочитатьЗаписи = Ложь, Сообщать=Ложь*/)
		{
			//Движения = неопределено;
			if(true/*Ссылка.Метаданные().Движения.Содержит(Метаданные.НайтиПоТипу(ТипЗнч(РегистрДвижения)))*/)
			{
				//Движения = РегистрДвижения.СоздатьНаборЗаписей();
				//Движения.Отбор.Регистратор.Установить(Ссылка);
				if(true/*ПрочитатьЗаписи*/)
				{
					//Движения.Прочитать();
				}
			}
			return null;
		}
		// ПолучитьНаборЗаписейПоСсылке()
		// Процедура сворачивает переданный набор записей регистра бухгалтерии по измерениям и реквизитам
		// Параметры: НаборЗаписейРегистраБухгалтерии, тип - набор записей регистров бухгалтерии Налоговый или Хозрасчетный
		//            СтрокаГруппировка, тип - строка - список колонок таблицы значений по которым будет выполняться группировка
		//            СтрокаСуммирование, тип - строка - список колонок таблицы значений которые будут суммироваться
		//            ВестиРеглУчетРасчетовСПерсоналомСводно, тип - булево - признак ведения сводного учета расчетов с персоналом
		//            МассивСчетовРасчетовСПерсоналом, тип - массив - список счетов учета расчетов с персоналом

		public void СвернутьНаборЗаписейРегистраБухгалтерии(/*НаборЗаписейРегистраБухгалтерии,
							СтрокаГруппировка, СтрокаСуммирование,
							ВестиРеглУчетРасчетовСПерсоналомСводно = Ложь, МассивСчетовРасчетовСПерсоналом = Неопределено*/)
		{
			//КоличествоЗаписейНабораЗаписей = НаборЗаписейРегистраБухгалтерии.Количество();
			/*// Если количество записей равно 0 - не требуется выполнять сворачивание
*/
			if(true/*КоличествоЗаписейНабораЗаписей = 0*/)
			{
			}
			//ТаблицаЗаписейРегистраБухгалтерии = НаборЗаписейРегистраБухгалтерии.Выгрузить();
			/*// Данная колонка в таблице не нужна
*/
			//ТаблицаЗаписейРегистраБухгалтерии.Колонки.Удалить("НомерСтроки");
			/*// Признак наличия проводок по счетам учета расчетов с персоналом
*/
			//ЕстьСчетаУчетаРасчетовСПерсоналом = Ложь;
			/*// Признак произведенной очистки субконто
*/
			//ЕстьОчищенныеСубконто = Ложь;
			/*// Если способ ведения расчетов с персоналом - сводно,
*/
			/*// то перед сворачиванием могут потребоваться дополнительные действия по очистке аналитики в проводках
*/
			if(true/*ВестиРеглУчетРасчетовСПерсоналомСводно*/)
			{
				//ТаблицаЗаписейРегистраБухгалтерии.Индексы.Добавить("СчетДт");
				//ТаблицаЗаписейРегистраБухгалтерии.Индексы.Добавить("СчетКт");
				/*// Определим, есть ли проводки со счетами учета расчетов с персоналом
*/
				/*// Для таких проводок потребуется выполнить очистку значений субконто
*/
				/*// Обнаружены проводки, у которых указаны счета расчетов с персоналом
*/
				if(true/*ЕстьСчетаУчетаРасчетовСПерсоналом*/)
				{
					/*// Создаем массив префиксов имен колонок таблицы записей регистра
*/
					/*// С его помощью будем обращатся к именам колонок счетов и субконто Дт и Кт в цикле
*/
					/*// чтобы не дублировать код, различающийся только именами колонок таблицы записей регистра
*/
					//ПрефиксыКолонок = Новый Массив;
					//ПрефиксыКолонок.Добавить("Дт");
					//ПрефиксыКолонок.Добавить("Кт");
					/*// Готовим соответствие счета расчетов и количества субконто счета
*/
					//СоответствиеКоличествоСубконтоСчета = Новый Соответствие;
					/*// Готовим соответствие видов очищаемых субконто и пустых значений субконто
*/
					//СоответствиеПустыхЗначенийСубконто = Новый Соответствие;
					//ВидСубконто = ПланыВидовХарактеристик.ВидыСубконтоХозрасчетные.РаботникиОрганизации;
					/*СоответствиеПустыхЗначенийСубконто.Вставить(ВидСубконто,
				Новый Структура("ПустоеЗначениеСубконто", ВидСубконто.ТипЗначения.ПривестиЗначение()));*/
					//ВидСубконто = ПланыВидовХарактеристик.ВидыСубконтоХозрасчетные.ВидНачисленийОплатыТрудаПоСтатье255НК;
					/*СоответствиеПустыхЗначенийСубконто.Вставить(ВидСубконто,
				Новый Структура("ПустоеЗначениеСубконто", ВидСубконто.ТипЗначения.ПривестиЗначение()));*/
				}
			}
			//ТаблицаЗаписейРегистраБухгалтерии.Свернуть(СтрокаГруппировка,СтрокаСуммирование);
			/*// Если аналитика не очищалась и количество записей осталось без изменений 
*/
			/*//	- не требуется загружать свернутую таблицу в набор записей 
*/
			if(true/*НЕ ЕстьОчищенныеСубконто
	 И ТаблицаЗаписейРегистраБухгалтерии.Количество() = КоличествоЗаписейНабораЗаписей*/)
			{
			}
			/*// Поиск и удаление проводок с пустым  количеством и суммой
*/
			/*// Готовим структуру поиска - нулевые значения колонок, которые входят в список суммируемых колонок
*/
			//СтруктураПоиска = Новый Структура(СтрокаСуммирование);
			/*// Удаление строк с пустыми значениями суммируемых колонок
*/
			//МассивСтрокКУдалению = ТаблицаЗаписейРегистраБухгалтерии.НайтиСтроки(СтруктураПоиска);
			//НаборЗаписейРегистраБухгалтерии.Загрузить(ТаблицаЗаписейРегистраБухгалтерии);
		}
		// Возвращает рабочую дату
		//
		// Возвращаемое значение:
		//   Дата - рабочая дата
		//

		public object ПолучитьРабочуюДату(/**/)
		{
			//Дата = РабочаяДата;
			//Дата = ТекущаяДата();
			return null;
		}
		// ПолучитьРабочуюДату()
		// Функция проверяет наличие в строке только цифр
		//
		// Параметры
		//  СтрокаПроверки - Строка для проверки только цифр
		//
		// Возвращаемое значение:
		//   Булево
		//

		public object ТолькоЦифрыВСтроке(/*Знач СтрокаПроверки, УчитыватьЛидирующиеНули = Истина, УчитыватьПробелы = Истина*/)
		{
			if(true/*ТипЗнч(СтрокаПроверки) <> Тип("Строка")*/)
			{
			}
			if(true/*НЕ ЗначениеЗаполнено(СтрокаПроверки)*/)
			{
			}
			if(true/*НЕ УчитыватьПробелы*/)
			{
				//СтрокаПроверки = СтрЗаменить(СтрокаПроверки, " ", "");
			}
			if(true/*НЕ УчитыватьЛидирующиеНули*/)
			{
				//НомерПервойЦифры = 0;
				//СтрокаПроверки = Сред(СтрокаПроверки, НомерПервойЦифры);
			}
			return null;
		}
		// Функция возвращает структуру, содержащую виды учета (УУ, БУ, НУ) и принадлежащие им регистры
		//

		public object ПолучитьРегистрыПоВидамУчета(/**/)
		{
			//РегистрыПоВидамУчета = Новый Структура;
			/*РегистрыПоВидамУчета.Вставить("ОтражатьВУправленческомУчете", "ГрафикиАмортизацииОС,
				|МестонахождениеОС,
				|НачислениеАмортизацииОС,
				|НоменклатураОсновныхСредств,
				|ПараметрыАмортизацииОС,
				|ПервоначальныеСведенияОС,
				|СобытияОС,
				|СоставОС,
				|СостоянияОС,
				|СписанныеТовары,
				|СпособыОтраженияРасходовПоАмортизацииОС,
				|БракВПроизводстве,
				|Затраты,
				|ЗатратыНаСтроительствоОбъектовОсновныхСредств,
				|НезавершенноеПроизводство,
				|ОССписанныеНаЗатраты,
				|ПартииТоваровНаСкладах,
				|СтоимостьОС,
				|СтроительствоОбъектовОсновныхСредств,
				|ТоварыНаСкладах,
				|СвободныеОстатки,
				|ТоварыОрганизаций,
				|ДопРасходыНаПриобретениеТоваров,
				|НезавершенноеПроизводство,
				|ПартииМатериаловВЭксплуатации,
				|ПартииТоваровПереданные,
				|ПродажиСебестоимость,
				|РеализованныеТовары,");*/
			/*РегистрыПоВидамУчета.Вставить("ОтражатьВБухгалтерскомУчете", "ГрафикиАмортизацииОСБухгалтерскийУчет,
				|МестонахождениеОСБухгалтерскийУчет,
				|НачислениеАмортизацииОСБухгалтерскийУчет,
				|ПараметрыАмортизацииОСБухгалтерскийУчет,
				|ПервоначальныеСведенияОСБухгалтерскийУчет,
				|МестонахождениеОСБухгалтерскийУчет,
				|МестонахождениеОСБухгалтерскийУчет,
				|СобытияОСОрганизаций,
				|СостоянияОСОрганизаций,
				|СписанныеТовары,
				|СпособыОтраженияРасходовПоАмортизацииОСБухгалтерскийУчет,
				|СчетаБухгалтерскогоУчетаОС,
				|БракВПроизводствеБухгалтерскийУчет,
				|ЗатратыБухгалтерскийУчет,
				|НДСНачисленный,
				|НДСПартииТоваров,
				|НДСпоОСиНМА,
				|НДСПредъявленный,
				|НезавершенноеПроизводствоБухгалтерскийУчет,
				|ОССписанныеНаЗатратыОрганизаций,
				|ПартииТоваровНаСкладахБухгалтерскийУчет,
				|СтоимостьОСБухгалтерскийУчет,
				|ТоварыОрганизаций,
				|Хозрасчетный,
				|НДСКосвенныеРасходы,
				|НДСНезавершенноеПроизводство,
				|НДСПродукция,
				|ПартииМатериаловВЭксплуатацииБухгалтерскийУчет,
				|ПартииТоваровПереданныеБухгалтерскийУчет,
				|УчетЗатратРегл,");*/
			/*РегистрыПоВидамУчета.Вставить("ОтражатьВНалоговомУчете", "НачислениеАмортизацииОСНалоговыйУчет,
				|НачислениеАмортизацииОССпециальныйКоэффициентНалоговыйУчет,
				|ПараметрыАмортизацииОСНалоговыйУчет,
				|ПервоначальныеСведенияОСНалоговыйУчет,
				|ПервоначальныеСведенияОСНалоговыйУчетУСН,
				|СписанныеТовары,
				|СпособыОтраженияРасходовПоАмортизацииОСНалоговыйУчет,
				|СчетаНалоговогоУчетаОС,
				|БракВПроизводствеНалоговыйУчет,
				|ЗатратыНалоговыйУчет,
				|НезавершенноеПроизводствоНалоговыйУчет,
				|ОплатыОСДляУСН,
				|ПартииТоваровНаСкладахНалоговыйУчет,
				|СтоимостьОСНалоговыйУчет,
				|Налоговый,
				|ПартииМатериаловВЭксплуатацииНалоговыйУчет,
				|ПартииТоваровПереданныеНалоговыйУчет,");*/
			/*РегистрыПоВидамУчета.Вставить("ОтражатьВМеждународномУчете", "БракВПроизводствеМеждународныйУчет,
				|НезавершенноеПроизводствоМеждународныйУчет,
				|ПартииТоваровНаСкладахМеждународныйУчет,
				|ПартииТоваровПереданныеМеждународныйУчет,");*/
			return null;
		}
		// РегистрыПоВидамУчета
		// Функция проверяет принадлежность указанного регистра всем требуемым видам учета
		//
		// Параметры:
		//  ИмяРегистра				- Строка, содержащая имя проверяемого регистра
		//  СтруктураВидовУчета		- Структура, содержащая перечень видов учета со значением Истина, для которых нужно производить проверку
		//  РегистрыПоВидамУчета	- структура, содержащая принадлежность регистров к видам учета
		//
		// Возвращаемое значение:
		//   Булево
		//

		public object РегистрПринадлежитВидамУчета(/*ИмяРегистра, СтруктураВидовУчета, РегистрыПоВидамУчета = Неопределено*/)
		{
			if(true/*РегистрыПоВидамУчета = Неопределено*/)
			{
				//РегистрыПоВидамУчета = ПолучитьРегистрыПоВидамУчета();
			}
			/*//Регистр не принадлежит к проверяемым видам учета
*/
			return null;
		}
		//РегистрПринадлежитВидамУчета
		// Процедура заполняет субконто в строке набора записей
		// Параметры
		// Запись - Строка набора записей регистра бухгалтерии
		// Строка - Структура, содержащая значения субконто
		//

		public void ЗаполнитьСубконтоВНабореЗаписей(/*Запись,Строка*/)
		{
		}
		// ЗаполнитьСубконтоВНабореЗаписей
		// Добавляет записи из таблицы движений в набор записей
		// Параметры
		// НаборЗаписей - Набор записей регистра накопления или регистра бухгалтерии
		// Таблица - таблица значений содержащая движения соответствующего регистра (таблица движений)
		//

		public void ДобавитьСтрокиВНаборЗаписей(/*НаборЗаписей, Таблица*/)
		{
			//НаборМетаданные = НаборЗаписей.Метаданные();
			//ЭтоРегистрБухгалтерии = (Метаданные.РегистрыБухгалтерии.Найти(НаборМетаданные.Имя)<>Неопределено);
			//Регистратор = НаборЗаписей.Отбор.Регистратор.Значение;
			//Период = Неопределено;
		}
		// ДобавитьСтрокиВНаборЗаписей
		////////////////////////////////////////////////////////////////////////////////
		// МАТЕМАТИКА
		// возвращает "количество полных и неполных рублей"
		// Параметры:
		//	Сумма - число
		// Возвращаемое значение:
		//  число, равное ближайшему целому "сверху"

		public object ЦелМаксимальное(/*Сумма*/)
		{
			//Возврат ?(Цел(Сумма) = Сумма, Сумма, Цел(Сумма) + 1);
			return null;
		}
		// ЦелМаксимальное()

		public object ДесятичноеВШестнадцатиричное(/*Источник*/)
		{
			//ШеснадцатиричныеСимволы = "0123456789ABCDEF";
			if(true/*Источник < 0*/)
			{
			}
			if(true/*Источник > 255*/)
			{
			}
			//ПервыйСимвол	= Цел(Источник / 16) + 1;
			//ВтройСимвол		= Источник % 16 + 1;
			return null;
		}
		// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УЧЕТНОЙ ПОЛИТИКОЙ
		// Функция возвращает структуру с параметрами учетной политики (Упр) на заданную дату.
		//
		// Параметры:
		//	Период					- дата на которую необходимо получить учетную политику
		//	СообщатьОбОшибке		- булево, если Истина, то вывести сообщение,
		//							когда на дату нет учетной политики
		// Возвращаемое значение:
		// <Структура>				- если на дату нет учетной политики, то Неопределено
		//

		public object ПолучитьПараметрыУчетнойПолитикиУпр(/*Период, СообщатьОбОшибке = Истина*/)
		{
			if(true/*НЕ ЗначениеЗаполнено(Период)*/)
			{
			}
			//УчетнаяПолитика = глЗначениеПеременной("УчетнаяПолитикаУпр");
			if(true/*СообщатьОбОшибке*/)
			{
				//ТекстОшибки = "Не указаны параметры учетной политики (управленческий учет) на " + Формат(Период, "ДЛФ=DD");
				//СообщитьОбОшибке(ТекстОшибки);
			}
			return null;
		}
		// ПолучитьПараметрыУчетнойПолитикиУпр
		// Функция возвращает структуру с параметрами учетной политики (регл учета)
		// на заданную дату по указанной организации.
		//
		// Параметры:
		//	Период					- дата на которую необходимо получить учетную политику
		//	Организация				- Организация по которой необходимо получить учетную политику
		//	СообщатьОбОшибке		- булево, если Истина, то вывести сообщение,
		//
		// Возвращаемое значение:
		// <Структура>				- если на дату нет учетной политики, то Неопределено
		//

		public object ПолучитьПараметрыУчетнойПолитикиРегл(/*Период, Организация, СообщатьОбОшибке = Истина*/)
		{
			if(true/*НЕ ЗначениеЗаполнено(Период) 
		ИЛИ НЕ ЗначениеЗаполнено(Организация)*/)
			{
			}
			//Запрос = Новый Запрос;
			/*ТекстЗапроса = "ВЫБРАТЬ
	               |	Организации.ОтражатьВРегламентированномУчете КАК ОтражатьВРегламентированномУчете
	               |ИЗ
	               |	Справочник.Организации КАК Организации
	               |ГДЕ
	               |	Организации.Ссылка = &Ссылка";*/
			//Запрос.Текст = ТекстЗапроса;
			//Запрос.УстановитьПараметр("Ссылка", Организация);
			//Выборка = Запрос.Выполнить().Выбрать();
			if(true/*Выборка.Следующий()*/)
			{
				if(true/*НЕ Выборка.ОтражатьВРегламентированномУчете*/)
				{
				}
			}
			//УчетнаяПолитика = глЗначениеПеременной("УчетнаяПолитикаРегл");
			if(true/*СообщатьОбОшибке*/)
			{
				//ТекстОшибки = "Не указаны параметры учетной политики (бухгалтерский и налоговый учет) на " + Формат(Период, "ДЛФ=DD") + " для организации " + Организация;
				//СообщитьОбОшибке(ТекстОшибки);
			}
			return null;
		}
		// ПолучитьПараметрыУчетнойПолитикиРегл
		// Временная функция. Необходимо использовать функции ПолучитьПараметрыУчетнойПолитикиУпр и ПолучитьПараметрыУчетнойПолитикиРегл
		//

		public object ПолучитьПараметрыУчетнойПолитики(/*КонДата, УчетнаяПолитикаНеЗадана, Организация = Неопределено, Учет = "упр", СообщатьОбОшибке = Истина*/)
		{
			if(true/*НРег(Учет) = "упр"*/)
			{
				//ПараметрыУчетнойПолитки = ПолучитьПараметрыУчетнойПолитикиУпр(КонДата, СообщатьОбОшибке);
			}
			if(true/*НЕ ЗначениеЗаполнено(ПараметрыУчетнойПолитки)*/)
			{
				//УчетнаяПолитикаНеЗадана = Истина;
			}
			return null;
		}
		// ПолучитьПараметрыУчетнойПолитики
		// Процедура выводить сообщение о необходимости перезапуска программы при изменении учетной политики
		// если в ИБ работают другие пользователи.
		//

		public void СообщитьОбИзмененииУчетнойПолитики(/**/)
		{
			//МассивСоединений = ПолучитьСоединенияИнформационнойБазы();
		}
		// Функция дополняет структуру шапки документа положениями учетной политики.
		//

		public void ДополнитьПоложениямиУчетнойПолитики(/*СтруктураШапкиДокумента, КонДата, Отказ, Организация, Учет = "Нал", СтруктураПолейУчетнойПолитикиНУ = неопределено*/)
		{
			if(true/*Учет = "Упр"*/)
			{
				//СтруктураУП = ПолучитьПараметрыУчетнойПолитикиУпр(КонДата);
			}
			if(true/*НЕ ЗначениеЗаполнено(СтруктураУП)*/)
			{
				//Отказ = Истина;
			}
		}
		// ДополнитьПоложениямиУчетнойПолитики()
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ ИНТЕРНЕТ-ПОДДЕРЖКИ ПОЛЬЗОВАТЕЛЕЙ
		// Процедура выполняет открытие HTML-страницы
		// по указанному URL

		public void Интерфейс1Действие(/**/)
		{
			//Форма = Обработки.Обозреватель.ПолучитьФорму("Форма",,"Опрос");
			//Форма.Заголовок = "Отзыв о программе";
			//Форма.СтартоваяСтраница = "www.1c.ru/usability/inquirer/upp.jsp";
			//Форма.Открыть();
		}
		////////////////////////////////////////////////////////////////////////////////
		// РАБОТА С ПЕРЕМЕННЫМИ
		// Меняет местами значения двух доступных для записи переменных
		//
		// Параметры
		//  Источник - первая переменная
		//  Приемник – вторая переменная
		//

		public void ПоменятьПеременныеМестами(/*Источник, Приемник*/)
		{
			//тмп = Источник;
			//Источник = Приемник;
			//Приемник = Тмп;
		}
		// ПоменятьПеременныеМестами()
		// Функция "расщепляет" строку на подстроки, используя заданный
		//		разделитель. Разделитель может иметь любую длину.
		//		Если в качестве разделителя задан пробел, рядом стоящие пробелы
		//		считаются одним разделителем, а ведущие и хвостовые пробелы параметра Стр
		//		игнорируются.
		//		Например,
		//		РазложитьСтрокуВМассивПодстрок(",ку,,,му", ",") возвратит массив значений из пяти элементов,
		//		три из которых - пустые строки, а
		//		РазложитьСтрокуВМассивПодстрок(" ку   му", " ") возвратит массив значений из двух элементов
		//
		//	Параметры:
		//		Стр - 			строка, которую необходимо разложить на подстроки.
		//						Параметр передается по значению.
		//		Разделитель - 	строка-разделитель, по умолчанию - запятая.
		//
		//
		//	Возвращаемое значение:
		//		массив значений, элементы которого - подстроки
		//

		public object РазложитьСтрокуВМассивПодстрок(/*Знач Стр, Разделитель = ","*/)
		{
			return null;
		}
		// глРазложить
		// Возвращает строку, полученную из массива элементов, разделенных символом разделителя
		//
		// Параметры:
		//  Массив - Массив - массив элементов из которых необходимо получить строку
		//  Разделитель - Строка - любой набор символов, который будет использован как разделитель между элементами в строке
		//
		// Возвращаемое значение:
		//  Результат - Строка - строка, полученная из массива элементов, разделенных символом разделителя
		//

		public object ПолучитьСтрокуИзМассиваПодстрок(/*Массив, Разделитель = ","*/)
		{
			/*// возвращаемое значение функции
*/
			//Результат = "";
			return null;
		}
		// Функция раскладывает Наименование в массив из трех элементов
		//
		// Параметры
		//  ФИО  - строка - наименование
		//
		// Возвращаемое значение:
		//   Массив   - массив из трех элементов, Фамилия, Имя, Отчество
		//

		public object ПолучитьМассивФИО(/*ФИО*/)
		{
			//МассивФИО = Новый Массив;
			//МассивФИО.Добавить("");
			//МассивФИО.Добавить("");
			//МассивФИО.Добавить("");
			//МассивПодсток = ОбщегоНазначения.РазложитьСтрокуВМассивПодстрок(ФИО, " ");
			return null;
		}
		// ПолучитьМассивФИО()
		// Отбирает из переданной таблицы строки по заданным критериям.
		//
		// Параметры:
		//  Источник - ТаблицаЗначений, РезультатЗапроса, ОбластьЯчеекТабличногоДокумента. Таблица-источник.
		//  СтруктураКритериев - Структура. Названия отборов и значения, по которым нужно отобрать строки.
		//  СтруктураСложныхКритериев - Структура. Если свойство передано, то значение содержит вид сравнения.
		//
		// Возвращаемое значение:
		//  РезультатЗапроса - таблица с нужными строками.
		//

		public object ОтобратьСтрокиПоКритериям(/*Источник, СтруктураКритериев, СтруктураСложныхКритериев = Неопределено*/)
		{
			if(true/*СтруктураСложныхКритериев = Неопределено*/)
			{
				//СтруктураСложныхКритериев = Новый Структура;
			}
			//ПостроительЗапроса = Новый ПостроительЗапроса;
			//ПостроительЗапроса.ИсточникДанных = Новый ОписаниеИсточникаДанных(Источник);
			return null;
		}
		// ОтобратьСтрокиПоКритериям()
		// Возвращает дату начала периода по имеющимся данным о:
		// дате окончании периода, значении перечисления Период, количестве периодов
		//

		public object ПолучитьДатуНачалаПериодаПоДатеОкончанияКоличествуПериодов(/*ДатаОкончания, ПериодСсылка, КоличествоПериодов*/)
		{
			if(true/*КоличествоПериодов = 0*/)
			{
				//КоличествоПериодов = 1;
			}
			if(true/*ДатаОкончания = Неопределено*/)
			{
				if(true/*КоличествоПериодов > 0*/)
				{
					//ДатаОкончания = КонецДня(ТекущаяДата());
				}
			}
			if(true/*(ПериодСсылка = Перечисления.Периодичность.День)*/)
			{
				//ДатаНачала = НачалоДня(ДатаОкончания - 60*60*24 * КоличествоПериодов);
			}
			if(true/*КоличествоПериодов > 0*/)
			{
			}
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// ФОРМИРОВАНИЕ КПП НА БАЗЕ ИНН
		// Процедура заполняет КПП на базе ИНН

		public void ЗаполнитьКППпоИНН(/*Знач ИНН, КПП, БезусловноеЗаполнениеКПП = Истина*/)
		{
			/*//	Если КПП формируется стандартным образом по ИНН, то для КПП берутся 
*/
			/*//первые 4 цифры ИНН + 01001, например:
*/
			/*//ИНН 7712563009
*/
			/*//КПП 771201001
*/
			/*// если не указано ИНН или заполнено КПП то прерываем выполнение операции
*/
			if(true/*(СтрДлина(ИНН) < 4)*/)
			{
			}
			//ПревыеСимволыИНН = Лев(ИНН, 4);
			//НовоеЗначениеКПП = ПревыеСимволыИНН + "01001";
			/*// если новое значение КПП и старое значение КПП совпадают, то прерываем выполнение операции
*/
			if(true/*(НовоеЗначениеКПП = КПП)*/)
			{
			}
			/*// если безусловно нужно поменять - меняем
*/
			if(true/*БезусловноеЗаполнениеКПП ИЛИ НЕ ЗначениеЗаполнено(КПП)*/)
			{
				//КПП = НовоеЗначениеКПП;
			}
			//ОтветНужноМенятьКПП = (Вопрос("Изменить КПП автоматически на """ + НовоеЗначениеКПП + """?", РежимДиалогаВопрос.ДаНет) = КодВозвратаДиалога.Да);
			if(true/*ОтветНужноМенятьКПП*/)
			{
				//КПП = НовоеЗначениеКПП;
			}
		}

		public object ПолучитьОсновнойДоговорКонтрагента(/*Контрагент*/)
		{
			//Запрос = Новый Запрос;
			/*Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	|	ДоговорыКонтрагентов.Ссылка КАК ДоступныйДоговорКонтрагента
	|ИЗ
	|	Справочник.ДоговорыКонтрагентов КАК ДоговорыКонтрагентов
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.Контрагенты КАК Контрагенты
	|		ПО (Контрагенты.Ссылка = &Контрагент)
	|			И Контрагенты.ОсновнойДоговорКонтрагента = ДоговорыКонтрагентов.Ссылка
	|ГДЕ
	|	ДоговорыКонтрагентов.Владелец = &Контрагент
	|
	|УПОРЯДОЧИТЬ ПО
	|	ВЫБОР
	|		КОГДА Контрагенты.ОсновнойДоговорКонтрагента ЕСТЬ NULL 
	|			ТОГДА 1
	|		ИНАЧЕ 0
	|	КОНЕЦ";*/
			//Запрос.УстановитьПараметр("Контрагент", Контрагент);
			//Выборка = Запрос.Выполнить().Выбрать();
			if(true/*Выборка.Следующий()*/)
			{
			}
			return null;
		}

		public object ПолучитьОсновноеКонтактноеЛицоКонтрагента(/*Контрагент*/)
		{
			//Запрос = Новый Запрос;
			/*Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	|	КонтактныеЛицаКонтрагентов.Ссылка КАК ДоступноеКонтактноеЛицоКонтрагента
	|ИЗ
	|	Справочник.КонтактныеЛицаКонтрагентов КАК КонтактныеЛицаКонтрагентов
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.Контрагенты КАК Контрагенты
	|		ПО (Контрагенты.Ссылка = &Контрагент)
	|			И Контрагенты.ОсновноеКонтактноеЛицо = КонтактныеЛицаКонтрагентов.Ссылка
	|ГДЕ
	|	КонтактныеЛицаКонтрагентов.Владелец = &Контрагент
	|
	|УПОРЯДОЧИТЬ ПО
	|	ВЫБОР
	|		КОГДА Контрагенты.ОсновноеКонтактноеЛицо ЕСТЬ NULL 
	|			ТОГДА 1
	|		ИНАЧЕ 0
	|	КОНЕЦ";*/
			//Запрос.УстановитьПараметр("Контрагент", Контрагент);
			//Выборка = Запрос.Выполнить().Выбрать();
			if(true/*Выборка.Следующий()*/)
			{
			}
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА РИБ

		public void ДобавитьПрефиксУзла(/*Префикс*/)
		{
			/*// Префикс узла распределенной информационной базы добавляется к префиксу-параметру процедуры
*/
			/*// если есть хоть один периферийный узел в любом из планов обмена:
*/
			/*// Полный, ОбменУППУПП, ОбменУправлениеПредприятиемУправлениеТорговлей, 
*/
			/*// ОбменУправлениеПредприятиемРозничнаяТорговля
*/
			/*//
*/
			/*// Установка значений параметров сеанса ИспользованиеРИБ, НаличиеОбменаУТУПП, 
*/
			/*// выполняется в процедуре ПолныеПрава.ОпределитьФактИспользованияРИБ()
*/
			if(true/*ПараметрыСеанса.ИспользованиеРИБ
	 ИЛИ ПараметрыСеанса.НаличиеОбменаУТУПП 
	 ИЛИ ПараметрыСеанса.НаличиеОбменаСРозничнойТорговлей*/)
			{
				//Префикс = ПараметрыСеанса.ПрефиксУзлаРаспределеннойИнформационнойБазы + Префикс;
			}
		}

		public object ОпределитьТекущийРежимРаботыМонопольный(/**/)
		{
			//МассивСоединений = ПолучитьСоединенияИнформационнойБазы();
			//НомерТекущегоСоединения = НомерСоединенияИнформационнойБазы();
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ ОБНОВЛЕНИЯ КОНФИГУРАЦИИ

		public void ПредупреждениеОбОшибке(/*ТекстСообщения*/)
		{
			//Предупреждение(ТекстСообщения);
			//ВызватьИсключение(ТекстСообщения);
		}
		// ПредупреждениеОбОшибке()

		public void ЗапуститьПрограмму(/*ПутьКПрограмме, РабочийКаталог = Неопределено*/)
		{
			//ЗапуститьПриложение(ПутьКПрограмме, РабочийКаталог);
		}
		// ЗапуститьПрограмму()
		///////////////////////////////////////////////////////////////////////////////
		//// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С XML
		// Функция осуществляет построение дерева XML.
		//
		// Параметры
		//  XML             - <ЧтениеXML>
		//                  - Объект, при помощи которого осуществляется чтение
		//                    файла отчета.
		//
		//  Дерево          - <Структура>
		//                  - Дерево XML.
		//
		//  ПервыйВызов     - <Булево>
		//                  - Служебный параметр.
		//
		// Возвращаемое значение:
		//  <Булево>        - Результат выполнения.
		//

		public object ПостроитьДеревоXML(/*XML, Дерево, ПервыйВызов = Истина*/)
		{
			//Результат = Истина;
			//Имя       = "";
			//Врем      = Неопределено;
			//Врем2     = Неопределено;
			//Врем3     = Неопределено;
			if(true/*ПервыйВызов*/)
			{
				//Дерево = Новый Структура();
			}
			if(true/*XML.Прочитать()*/)
			{
				if(true/*XML.ТипУзла = ТипУзлаXML.НачалоЭлемента*/)
				{
					//Имя  = XML.ЛокальноеИмя;
					//Врем = Новый Структура();
					while(true/*ПостроитьДеревоXML(XML, Врем, Ложь)*/)
					{
					}
					while(true/*XML.Имя <> Имя*/)
					{
						if(true/*XML.ТипУзла = ТипУзлаXML.Текст*/)
						{
							//Врем = XML.Значение;
						}
						if(true/*Не XML.Прочитать()*/)
						{
							//Результат = Ложь;
						}
					}
					/*;
			Дерево.Свойство(Имя, Врем2);*/
					if(true/*Врем2 = Неопределено*/)
					{
						//Врем2 = Врем;
					}
					//Дерево.Вставить(Имя, Врем2);
				}
			}
			return null;
		}
		// ПостроитьДеревоXML()
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С ПОСЛЕДОВАТЕЛЬНОСТЯМИ

		public void УдалитьРегистрациюДокументаВПоследовательностях(/*ДокументОбъект, ПроверятьДвижения=ложь*/)
		{
			/*//Очистим коллекцию движений документа
*/
			//ТаблицаСтаройРегистрацииВПоследовательности = Новый ТаблицаЗначений();
			//ТаблицаСтаройРегистрацииВПоследовательности.Колонки.Добавить("ИмяПоследовательности");
			//ТаблицаСтаройРегистрацииВПоследовательности.Колонки.Добавить("Организация");
			//ТаблицаСтаройРегистрацииВПоследовательности.Колонки.Добавить("Период");
			//КоллекцияПоследовательностей = ДокументОбъект.ПринадлежностьПоследовательностям;
			/*//Если коллекция пуста, то привилегированно очистим набор записей
*/
			//УправлениеЗапасамиПартионныйУчет.УдалитьРегистрациюДокументаВПоследовательностяхНаСервере(ДокументОбъект.Ссылка, ПроверятьДвижения, ТаблицаСтаройРегистрацииВПоследовательности);
			//ТаблицаСтаройРегистрацииВПоследовательности.Свернуть("ИмяПоследовательности,Организация,Период");
			//ДокументОбъект.ДополнительныеСвойства.Вставить("ТаблицаСтаройРегистрацииВПоследовательности",ТаблицаСтаройРегистрацииВПоследовательности);
		}
		//УдалитьРегистрациюДокументаВПоследовательностях
		// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С ПОСЛЕДОВАТЕЛЬНОСТЯМИ
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ ФОРМИРОВАНИЯ ДВИЖЕНИЙ ДОКУМЕНТОВ
		// Функция загружает таблицы документа в таблицы соответствующие структуре регистров
		//	Параметры:
		//		- Движение - движение документа (т.е. регистр)
		//		- СтруктТаблицДокумента - структура содержашая таблицы документа. ключ - имя таблицы, значение - таблица значений с данными документа.
		//
		//	Возврат:
		//		- Структура, в которой ключ - это имя таблицы документа, соответствующий параметру СтруктТаблицДокумента,
		//		  значение - таблица значений, со структурой соответствующей структуре параметра (т.е. регистра) Движение
		//		  В таблицы значений данные загружаются по соответствию с имен полей.
		//

		public object ЗагрузитьТаблицыДокументаВСтруктуру(/*Движение, СтруктТаблицДокумента*/)
		{
			//ПустаяТабРегистра = Движение.Выгрузить();
			//ПустаяТабРегистра.Очистить();
			//СтруктДанных = Новый Структура;
			return null;
		}
		// ЗагрузитьТаблицыДокументаВСтруктуру()
		// Процедура заполняет структуру таблиц документа, значением которое будет одинаковым для всех таблиц (например значением шапки документа)
		//	Параметры:
		//		- СтруктТаблицДокумента - структура таблиц документа, сформированная функцией ЗагрузитьТаблицыДокументаВСтруктуру()
		//		- ИмяПоля - имя колонки в таблицах локумента, в которую будет установлено новое значение
		//		- УстанавливаемоеЗначение - значение, которое надо установить в таблицы документа
		//		- СтрТабЧасти - имена таб. частей документа в которые необходимо установить новое значение. строка, в которой
		//						имена таб. частей разделены запятыми. необязательный параметр, по умолчанию - все таблицы.
		//

		public void УстановитьЗначениеВТаблицыДокумента(/*СтруктТаблицДокумента, ИмяПоля, УстанавливаемоеЗначение, СтрТабЧасти = ""*/)
		{
			//СтруктТабЧасти = ?( ПустаяСтрока(СтрТабЧасти), СтруктТаблицДокумента, Новый Структура(СтрТабЧасти));
		}
		// УстановитьЗначениеВТаблицыДокумента()
		// Процедура формирует движение в регистр на основании данных в таблицах документов
		//	Параметры:
		//		- Движение - движение документа, в которое необходимо произвести добавление записей (т.е. регистр)
		//		- ВидДвижения - вид движения накопления (приход/расход)
		//		- СтруктТаблицДокумента - структура таблиц документа, сформированная функцией ЗагрузитьТаблицыДокументаВСтруктуру()
		//		- ДатаДвижения - дата на которую будут формироваться записи
		//

		public void ЗаписатьТаблицыДокументаВРегистр(/*Движение, ВидДвижения, СтруктТаблицДокумента, ДатаДвижения*/)
		{
			//Движение.мПериод = ДатаДвижения;
		}
		// ЗаписатьТаблицыДокументаВРегистр()
		// Процедура удаляет строки с пустыми значениями из структуры таблиц документа
		//	Параметры:
		//		- ТаблицыДляДвиженийПоЗаказам - структура таблиц документа
		//		- ИмяПоля - имя поля, значение которого проверяет на пустое значение.
		//

		public void УдалитьСтрокиИзТаблицДокумента(/*ТаблицыДляДвиженийПоЗаказам, ИмяПоля*/)
		{
		}
		// УдалитьСтрокиИзТаблицДокумента()
		// Процедура переименовывает колонку таблицы значений, с сохранением истории переименований для возможности последующего "отката"
		//
		//	Параметры:
		//		- ТабЗначений - таблица значений в которой производится переименование колонок
		//		- ТабИмен - таблица с историей переименований. Новые сведения о переименованных колонках добавляются сюда и возвращаются в вызвавшую процедуру
		//		- ТекИмяКолонки - имя колонки которую надо переименовать
		//		- НовоеИмяКолонки - новое имя колонки. Если параметр не задан, новое имя присваивается автоматически
		//

		public void ПереименоватьКолонкуТаблицыЗначений(/*ТабЗначений, ТабИмен, Знач ТекИмяКолонки, Знач НовоеИмяКолонки = ""*/)
		{
			if(true/*ТабИмен = Неопределено*/)
			{
				//ТабИмен = Новый ТаблицаЗначений;
				//ТабИмен.Колонки.Добавить("НовИмя", Новый ОписаниеТипов("Строка"));
				//ТабИмен.Колонки.Добавить("ТекИмя",   Новый ОписаниеТипов("Строка"));
			}
			//ТекКолонка = ТабЗначений.Колонки.Найти(ТекИмяКолонки);
			if(true/*ПустаяСтрока(НовоеИмяКолонки)*/)
			{
				/*// Генерируем новое имя для старой колонки, гарантируя что оно будет уникальным
*/
				//Индекс = 1;
				while(true/*Истина*/)
				{
					//НовоеИмяКолонки = "_" + Строка(Индекс) + "_" + ТекИмяКолонки;
					if(true/*ТабЗначений.Колонки.Найти(НовоеИмяКолонки) = Неопределено*/)
					{
					}
					//Индекс = Индекс + 1;
				}
				/*// После выхода из цикла в переменной НовоеИмяКолонки должны получить новое имя колонки,
*/
			}
			/*// Переименуем колонку
*/
			//ТабЗначений.Колонки[ТекИмяКолонки].Имя = НовоеИмяКолонки;
			/*// Сохраним имя колонки в таб. имен
*/
			//НоваяСтрока = ТабИмен.Добавить();
			//НоваяСтрока.НовИмя = НовоеИмяКолонки;
			//НоваяСтрока.ТекИмя = ТекИмяКолонки;
		}
		// ПереименоватьКолонкуТаблицыЗначений()
		// Процедура восстанавливает имена колонок таблицы значений, сохраненные в процедуре ПереименоватьКолонкуТаблицыЗначений()
		//
		//	Параметры:
		//		- ТабЗначений - таблица значений в которой производится переименование колонок
		//		- ТабИмен - таблица с историей переименований, таблица создается и заполняется в процедуре ПереименоватьКолонкуТаблицыЗначений()
		//

		public void ВосстановитьИменаКолонокТаблицыЗначений(/*ТабЗначений, ТабИмен*/)
		{
			//К = ТабИмен.Количество() - 1;
			while(true/*К >= 0*/)
			{
				//ТекСтрока = ТабИмен[К];
				//ТабЗначений.Колонки[ТекСтрока.НовИмя].Имя = ТекСтрока.ТекИмя;
				//К = К - 1;
			}
			/*;
	
	ТабИмен.Очистить();*/
		}
		// ВосстановитьИменаКолонокТаблицыЗначений()
		// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ ФОРМИРОВАНИЯ ДВИЖЕНИЙ ДОКУМЕНТОВ
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УПРАВЛЯЕМЫМИ БЛОКИРОВКАМИ
		// Устанавливает управляемую блокировку таблицы
		//
		// Параметры:
		//  СтруктураПараметров 		- <Структура>. Структура параметров блокировки. Обязательный параметр.
		//								Обязательно должна содержать свойства:
		//								"ИмяТаблицы" - <Строка> - имя таблицы, на которую накладывается блокировка.
		//									Например: "АвансовыйОтчет"
		//								Необязательные свойства:
		//								"ТипТаблицы" - <Строка> - тип таблицы, на которую накладывается блокировка.
		//									Пространство блокировки состоит из типа таблицы и имени таблицы.
		//									Например: "Документ"
		//									Значение по умолчанию: "РегистрНакопления"
		//								"РежимБлокировки" - <РежимБлокировкиДанных> - режим накладываемой блокировки.
		//									Значение по умолчанию: РежимБлокировкиДанных.Исключительный
		//								"ИсточникДанных" - источник данных для блокировки.
		//									Может передаваться значение любого типа, поддерживаемого свойством ИсточникДанных элемента блокировки,
		//									а также типа "Менеджер временных таблиц".
		//									Если в структуре нет этого свойства - блокировки через ИспользоватьИзИсточникаДанных() не накладываются.
		//								"ИмяВременнойТаблицы" - <Строка> - имя временной таблицы менеджера временных таблиц, которая служит источником данных для блокировки.
		//									Обязательно должно указываться, если в качестве источника данных процедуре передан менеджер временных таблиц.
		//  СтруктураЗначенийБлокировки	- <Структура> - описывает значения блокировки, накладываемые с помощью УстановитьЗначение().
		//									Ключ - поле блокировки, значение - блокируемое значение.
		//									Если передано Неопределено или если структура не содержит ни одного элемента -
		//									блокировки через УстановитьЗначение() не накладываются.
		//  СтруктураИсточникаДанных	- <Структура> - описывает значения блокировки, накладываемые с помощью ИспользоватьИзИсточникаДанных().
		//									Ключ - поле блокировки, значение - поле источника данных.
		//									Если передано Неопределено или если структура не содержит ни одного элемента -
		//									блокировки через ИспользоватьИзИсточникаДанных() не накладываются.
		//  Отказ 						- <Булево> - при ошибке в процессе установки блокировки в этот параметр процедура возвращает значение Истина
		//  Заголовок 					- <Строка> - заголовок сообщения об ошибке при установке блокировки
		//

		public void УстановитьУправляемуюБлокировку(/*СтруктураПараметров, СтруктураЗначенийБлокировки = Неопределено, СтруктураИсточникаДанных = Неопределено, Отказ, Заголовок*/)
		{
			if(true/*НЕ ТипЗнч(СтруктураПараметров) = Тип("Структура")*/)
			{
			}
			/*ИспользоватьЗначенияБлокировки = СтруктураЗначенийБлокировки <> Неопределено 
		И ТипЗнч(СтруктураЗначенийБлокировки) = Тип("Структура") 
		И СтруктураЗначенийБлокировки.Количество() > 0;*/
			/*ИспользоватьИсточникДанных     = СтруктураИсточникаДанных <> Неопределено 
		И ТипЗнч(СтруктураИсточникаДанных) = Тип("Структура") 
		И СтруктураИсточникаДанных.Количество() > 0
		И СтруктураПараметров.Свойство("ИсточникДанных");*/
			if(true/*НЕ ИспользоватьЗначенияБлокировки И НЕ ИспользоватьИсточникДанных*/)
			{
			}
			//Блокировка = Новый БлокировкаДанных;
			//ТипТаблицы = ?(СтруктураПараметров.Свойство("ТипТаблицы"), СтруктураПараметров.ТипТаблицы, "РегистрНакопления") + ".";
			//ИмяТаблицы = СтруктураПараметров.ИмяТаблицы;
			//ПространствоБлокировки = ТипТаблицы + ИмяТаблицы;
			//ЭлементБлокировки = Блокировка.Добавить(ПространствоБлокировки);
			//РежимБлокировки = ?(СтруктураПараметров.Свойство("РежимБлокировки"), СтруктураПараметров.РежимБлокировки, РежимБлокировкиДанных.Исключительный);
			//ЭлементБлокировки.Режим = РежимБлокировки;
			if(true/*ИспользоватьЗначенияБлокировки*/)
			{
			}
			if(true/*ИспользоватьИсточникДанных*/)
			{
				//ИсточникДанных = СтруктураПараметров.ИсточникДанных;
				if(true/*ТипЗнч(ИсточникДанных) = Тип("МенеджерВременныхТаблиц")*/)
				{
					//Запрос = Новый Запрос;
					//Запрос.МенеджерВременныхТаблиц = ИсточникДанных;
					//ТекстЗапроса = "";
					//ТекстЗапроса = Сред(ТекстЗапроса, 2);
					/*ТекстЗапроса = 			
			"ВЫБРАТЬ РАЗЛИЧНЫЕ"
			+ ТекстЗапроса + "
			|ИЗ
			|	" + СтруктураПараметров.ИмяВременнойТаблицы + " КАК Таб";*/
					//Запрос.Текст = ТекстЗапроса;
					//Результат    = Запрос.Выполнить();
					//ЭлементБлокировки.ИсточникДанных = Результат;
				}
			}
		}
		// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УПРАВЛЯЕМЫМИ БЛОКИРОВКАМИ
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С КРИТЕРИЯМИ ОТБОРА
		// Функция разбирает строку вида
		// ТипОбъектаМетаданных.ИмяДокумента.ТабличнаяЧасть.ИмяТабличнойЧасти.Реквизит.ИмяРеквизита.
		// ТипОбъектаМетаданных должен быть Справочник или Документ.
		//
		// Параметры:
		//  ПутьКДанным - строка.
		//  МетаданныеОбъекта - Объект метаданных
		//
		// Возвращаемое значение:
		//  Структура - путь к объекту метаданных
		//

		public object РазобратьПутьКОбъектуМетаданных(/*ПутьКДанным, МетаданныеОбъекта = Неопределено*/)
		{
			//Структура = Новый Структура;
			//СоответствиеИмен = Новый Массив();
			//СоответствиеИмен.Добавить("ТипОбъекта");
			//СоответствиеИмен.Добавить("ВидОбъекта");
			//СоответствиеИмен.Добавить("ПутьКДанным");
			//СоответствиеИмен.Добавить("ИмяТаблЧасти");
			//СоответствиеИмен.Добавить("ИмяРеквизита");
			//ПутьКДанным = СтрЗаменить(ПутьКДанным, "Реквизит.", "");
			if(true/*Структура.ПутьКДанным = "ТабличнаяЧасть"*/)
			{
			}
			if(true/*МетаданныеОбъекта <> Неопределено*/)
			{
				//Структура.Вставить("Метаданные", МетаданныеОбъекта);
			}
			return null;
		}
		// РазобратьПутьКОбъектуМетаданных()
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ И ФУНКЦИИ ПАРАМЕТРОВ СЕАНСА, ПЕРЕМЕННЫХ МОДУЛЯ ПРИЛОЖЕНИЯ
		// Функция определяет наличие клиентских подключений к базе других пользователей

		public object ЕстьДругиеПользователиВБазе(/**/)
		{
			//МассивСоединений = ПолучитьСоединенияИнформационнойБазы();
			//НомерТекущегоСоединения = НомерСоединенияИнформационнойБазы();
			return null;
		}
		// Функция собирает паспортные данные физ. лица на указанную дату
		//
		// Параметры:
		//  ФизЛицо.    - физ. лицо, для которго необходимо получить паспортные данные
		//  ДатаПериода - дата получения сведений
		//
		// Возвращаемое значение:
		//  Структура с паспортными данными.
		//

		public object ПаспортныеДанные(/*ФизЛицо, ДатаПериода*/)
		{
			//Запрос = Новый Запрос;
			//Запрос.УстановитьПараметр("ПарФизЛицо",     ФизЛицо);
			//Запрос.УстановитьПараметр("ПарДатаПериода", ДатаПериода);
			/*Запрос.Текст = 
	"ВЫБРАТЬ
	|	ДокументВид        КАК Вид,
	|	ДокументСерия      КАК Серия,
	|	ДокументНомер      КАК Номер,
	|	ДокументДатаВыдачи КАК ДатаВыдачи,
	|	ДокументКемВыдан   КАК Выдан
	|ИЗ
	|	РегистрСведений.ПаспортныеДанныеФизЛиц.СрезПоследних(&ПарДатаПериода, ФизЛицо = &ПарФизЛицо)
	|";*/
			//Шапка = Запрос.Выполнить().Выбрать();
			//Шапка.Следующий();
			//Результат = Новый Структура("Вид, Серия, Номер, ДатаВыдачи, Выдан");
			//Результат.Вид        = Шапка.Вид;
			//Результат.Серия      = Шапка.Серия;
			//Результат.Номер      = Шапка.Номер;
			//Результат.ДатаВыдачи = Шапка.ДатаВыдачи;
			//Результат.Выдан      = Шапка.Выдан;
			return null;
		}
		// ПаспортныеДанные()
		// Получает параметр учетной политики (налоговый учет) для заданной организации на заданную дату
		//
		// Параметры:
		//	ИмяПараметра        - строка, имя запрашиваемого параметра учетной политики,
		//	Организация         - ссылка на элемент справочника "Организации", для которого надо получить параметры,
		//	Дата                - дата, на которую надо получить параметры, если не заполнено, то берется рабочая дата,
		//	СтруктураПараметров - структура, содержащая все параметры учетной политики.
		//
		// Возвращаемое значение:
		//	Значение учетной политики
		//

		public object ВыгрузитьСтруктуруВСтроку(/*Структура,ПоЗначениям=Ложь,СтруктураПроверки = Неопределено*/)
		{
			//НеПроверять = (СтруктураПроверки=Неопределено);
			//НоваяСтрока = "";
			if(true/*ЗначениеЗаполнено(НоваяСтрока)*/)
			{
				//НоваяСтрока = Лев(НоваяСтрока,СтрДлина(НоваяСтрока)-1);
			}
			return null;
		}
		//Процедура для распределения записей из одной таблицы значений по базису (таблица значений или  набору записей)
		//Источник 		: ТаблицаЗначений
		//Базис 		: ТаблицаЗначений или НаборЗаписей
		//Распределение : ключ - поля базиса, значение - поля источника
		//Фильтр 		: ключ - поля базиса, значение - поля источника (если не укзан - по совпадающим колонкам)
		//Игнорировать  : ключ - поля базиса, значение - поля источника
		//Дополнить		: ключ - имя нового поля базиса, значение - значение для заполнения

		public object СформироватьКорректирующиеЗаписи(/*Источник,Базис,Распределение,Фильтр=неопределено,Игнорировать=Неопределено,Дополнить=Неопределено, НераспределенныеЗаписи_AsIs = ложь*/)
		{
			if(true/*ТипЗнч(Базис) = Тип("ТаблицаЗначений")*/)
			{
				//Временный_Базис	   = Базис.Скопировать();
			}
			//КолонкиИсточника = Новый Структура();
			//КолонкиБазиса = Новый Структура();
			if(true/*НЕ ЗначениеЗаполнено(Игнорировать)*/)
			{
				//Игнорировать = новый Структура();
			}
			/*//Зачистим колонки источника на распределяемые колонки. Они учитываются отдельно.
*/
			if(true/*ЗначениеЗаполнено(Дополнить)*/)
			{
				/*//Проверим на отсутствие дополняемых колонок!
*/
			}
			/*//Если фильтр не задан - по всем совпадающим колонкам
*/
			if(true/*Фильтр=Неопределено*/)
			{
				//Фильтр = Новый Структура();
			}
			if(true/*НЕ ЗначениеЗаполнено(Фильтр)*/)
			{
				/*//Должно быть хоть одно объединяющее поле!
*/
			}
			/*//Подготовить сворачивание для источника
*/
			//СтрокаСверткиИсточник = ВыгрузитьСтруктуруВСтроку(Фильтр,Истина,КолонкиИсточника);
			if(true/*СтрокаСверткиИсточник = ложь*/)
			{
				/*//попытка фильтровать по полю, отсутствующему в источнике!
*/
			}
			//КолонкиКРаспределениюИсточник = ВыгрузитьСтруктуруВСтроку(Распределение,Истина);
			if(true/*КолонкиКРаспределениюИсточник = ложь*/)
			{
				/*//попытка распределить поле, отсутствующее в источнике!
*/
			}
			/*//Подготовить сворачивание для базиса
*/
			//СтрокаСверткиБазис = ВыгрузитьСтруктуруВСтроку(КолонкиБазиса,Ложь);
			if(true/*СтрокаСверткиБазис = ложь*/)
			{
				/*//попытка фильтровать по полю, отсутствующему в базисе!
*/
			}
			//КолонкиКРаспределениюБазис = ВыгрузитьСтруктуруВСтроку(Распределение,Ложь);
			if(true/*КолонкиКРаспределениюБазис = ложь*/)
			{
				/*//попытка распределить поле, отсутствующее в базисе!
*/
			}
			//Временный_Источник = Источник.Скопировать();
			//Временный_Базис.Свернуть(СтрокаСверткиБазис,КолонкиКРаспределениюБазис);
			//Временный_Источник.Свернуть(СтрокаСверткиИсточник,КолонкиКРаспределениюИсточник);
			//НоваяТаблица = новый ТаблицаЗначений();
			//ТаблицаБазисовРаспределения = Новый ТаблицаЗначений();
			if(true/*ЗначениеЗаполнено(Дополнить)*/)
			{
			}
			//СтрокиС0Распределением = Новый Массив();
			/*//Если ЗначениеЗаполнено(ИсключитьПослеРаспределения) тогда
*/
			/*//	КолонкиРезультата = Новый Структура();
*/
			/*//	Для каждого Колонка из НоваяТаблица.Колонки Цикл
*/
			/*//		Если ИсключитьПослеРаспределения.Свойство(Колонка.Имя) = Истина  или Распределение.Свойство(Колонка.Имя) = Истина Тогда
*/
			/*//			Продолжить;
*/
			/*//		Иначе
*/
			/*//			КолонкиРезультата.Вставить(Колонка.Имя);
*/
			/*//		КонецЕсли;
*/
			/*//	КонецЦикла;
*/
			/*//	КолонкиКСворачиванию = ВыгрузитьСтруктуруВСтроку(КолонкиРезультата,Ложь);
*/
			/*//	НоваяТаблица.Свернуть(КолонкиКСворачиванию,КолонкиКРаспределениюБазис);
*/
			/*//КонецЕсли;
*/
			return null;
		}

		public object ВыгрузитьСтрокиДереваВТаблицуЗначений(/*Источник,КоллекцияКолонокДереваЗначений*/)
		{
			//Реквизиты = Новый Структура();
			//НоваяТЗ= Новый ТаблицаЗначений();
			while(true/*НоваяТЗ.Количество()<Источник.Количество()*/)
			{
				//Строка = НоваяТЗ.Добавить();
			}
			return null;
		}
		// СформироватьТаблицуОплаты()
		// Возвращает строку, описывающую период, определяемый переданными
		// датой и периодичностью.
		//
		// Параметры
		//  ДатаВПериоде:Дата - дата из периода
		//  Периодичность: Строка - строка, определяющая периодичность
		//
		// Возвращаемое значение:
		//   СтрокаПериод: строка   – представление периода для вывода в отчетах
		//

		public object ПолучитьПериодСтрокой(/*ДатаВПериоде, Периодичность*/)
		{
			if(true/*Периодичность = "Год"*/)
			{
				//ФорматДаты = "ДФ='гггг ""г.""'";
			}
			//СтрокаПериод = "" + Формат(ДатаВПериоде, ФорматДаты);
			if(true/*Периодичность = "Неделя" И ТипЗнч(ДатаВПериоде) = Тип("Дата")*/)
			{
				//СтрокаПериод = "" + НеделяГода(ДатаВПериоде) + "-ая " + СтрокаПериод + Формат(КонецНедели(ДатаВПериоде), "ДФ='"" - ""дд.ММ.гггг)'");
			}
			return null;
		}
		// ПолучитьПериодСтрокой()
		// Процедура предназначена для получения момента определения остатков для заполнения документа.
		//
		// Параметры:
		//  ДокОбъект - (ДокументОбъект), документ, для которого надо определить лату получения остатков.
		//
		// Возвращаемое значение.
		//  Дата (момент времени) - дата остатков
		//

		public object ПолучитьДатуОстатков(/*ДокОбъект*/)
		{
			//ДатаОстатков = '00010101';
			if(true/*НачалоДня(ДокОбъект.Дата) <> НачалоДня(ТекущаяДата()) 
	   И ДокОбъект.Дата <> '00010101'*/)
			{
				if(true/*НЕ ЗначениеЗаполнено(ДокОбъект.Ссылка)*/)
				{
					//ДатаОстатков = КонецДня(ДокОбъект.Дата);
				}
			}
			return null;
		}
		// Стандартная для данной конфигурации функция форматирования сумм
		//
		// Параметры:
		//  Сумма  - число, которое мы хотим форматировать,
		//  Валюта - ссылка на элемент справочника валют, если задан, то к в результирующую строку
		//           будет добавлено представление валюты
		//  ЧН     - строка, представляющая нулевое значение числа,
		//  ЧРГ    - символ-разделитель групп целой части числа.
		//
		// Возвращаемое значение:
		//  Отформатированная должным образом строковое представление суммы.
		//

		public object ФорматСумм(/*Сумма, Валюта = Неопределено, ЧН = "", ЧРГ = ""*/)
		{
			/*ФорматнаяСтрока = "ЧЦ=15;ЧДЦ=2" +
					?(ПустаяСтрока(ЧН), "", ";" + "ЧН=" + ЧН) +
					?(ПустаяСтрока(ЧРГ),"", ";" + "ЧРГ=" + ЧРГ);*/
			//РезультирующаяСтрока = СокрЛ(Формат(Сумма, ФорматнаяСтрока));
			if(true/*Валюта <> Неопределено*/)
			{
				//РезультирующаяСтрока = РезультирующаяСтрока + " " + СокрП(Валюта);
			}
			return null;
		}
		// ФорматСумм()
		// Удаляет повторяющиеся значения из массива
		//
		// Параметры:
		//	Массив
		//

		public void УдалитьПовторяющиесяЭлементы(/*Массив*/)
		{
			if(true/*ТипЗнч(Массив) = Тип("Массив")*/)
			{
				/*// Удалим повторы
*/
				//Инд=0;
				//КолВо = Массив.Количество();
				while(true/*Инд<КолВо*/)
				{
					//Инд2 = Инд+1;
					while(true/*Инд2<КолВо*/)
					{
						if(true/*Массив[Инд2] = Массив[Инд]*/)
						{
							//Массив.Удалить(Инд2);
							//КолВо = КолВо-1;
						}
					}
					/*//Установим для не заполненных значений тип "Неопределено"
*/
					if(true/*НЕ ЗначениеЗаполнено(Массив[Инд])*/)
					{
						//Массив[Инд] = Неопределено;
					}
					//Инд = Инд+1;
				}
				//;;
			}
		}
		// Функция выполняет пропорциональное распределение суммы в соответствии
		// с заданными коэффициентами распределения
		//
		// Параметры:
		//		ИсхСумма - распределяемая сумма
		//		МассивКоэф - массив коэффициентов распределения
		//		Точность - точность округления при распределении. Необязателен.
		//
		//	Возврат:
		//		МассивСумм - массив размерностью равный массиву коэффициентов, содержит
		//			суммы в соответствии с весом коэффициента (из массива коэффициентов)
		//          В случае если распределить не удалось (сумма = 0, кол-во коэф. = 0,
		//          или суммарный вес коэф. = 0), тогда возвращается значение Неопределено
		//

		public object РаспределитьПропорционально(/*Знач ИсхСумма, МассивКоэф, Знач Точность = 2, ПроверкаНулевыхЗначений=Истина*/)
		{
			if(true/*МассивКоэф.Количество() = 0 Или (ПроверкаНулевыхЗначений И ИсхСумма = 0) Или ИсхСумма = Null*/)
			{
			}
			/*// Массив коэффициентов необходимо упорядочить, поэтому создадим таблицу для распределения
*/
			//УпорядоченнаяТаблица = Новый ТаблицаЗначений;
			//УпорядоченнаяТаблица.Колонки.Добавить("Коэф", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(17,4)));
			//УпорядоченнаяТаблица.Колонки.Добавить("ИсходныйИндекс", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15,0)));
			//СуммаКоэф  = 0;
			if(true/*СуммаКоэф = 0*/)
			{
			}
			//УпорядоченнаяТаблица.Сортировать("Коэф Убыв");
			//МассивСумм = Новый Массив(УпорядоченнаяТаблица.Количество());
			return null;
		}
		// РаспределитьПропорционально()
		// Процедура копирует значения одной строки таблицы значеницй в другую
		// структура колонок должна совпадать
		//
		// Параметры:
		//		СтрокаПриемник - строка в которую копируем
		//		СтрокаИсточник - строка из которой копируем
		//      ИменаКол - имена колонок, разделенные запятыми, которые надо скопировать
		//                 необязателен. По умолчанию - все колонки
		//

		public void КопироватьСтрокуТаблицыЗначений(/*СтрокаПриемник, СтрокаИсточник, ИменаКол*/)
		{
			if(true/*ТипЗнч( ИменаКол) = Тип("ТаблицаЗначений")*/)
			{
				//СписокСвойств = "";
				//ЗаполнитьЗначенияСвойств(СтрокаПриемник, СтрокаИсточник, СписокСвойств,);
			}
		}
		// КопироватьСтрокуТаблицыЗначений()
		// Процедура возвращает паспортные данные физлица в виде строки
		//
		// Параметры:
		//  ФизЛицо - ссылка на элемент справочника "Физические лица",по которму необходимо
		//            получить паспортные данные.
		//
		// Возвращаемое значение:
		//  Строка с данными об удостоверении личности физичского лица
		//

		public object ПолучитьПаспортныеДанныеСтрокой(/*ФизЛицо*/)
		{
			//СтруктураПаспортныхДанных	= РегистрыСведений.ПаспортныеДанныеФизЛиц.ПолучитьПоследнее(РабочаяДата, Новый Структура("ФизЛицо",ФизЛицо));
			//ВидДокумента				= СтруктураПаспортныхДанных.ДокументВид;
			//Серия						= СтруктураПаспортныхДанных.ДокументСерия;
			//Номер						= СтруктураПаспортныхДанных.ДокументНомер;
			//ДатаВыдачи					= СтруктураПаспортныхДанных.ДокументДатаВыдачи;
			//КемВыдан					= СтруктураПаспортныхДанных.ДокументКемВыдан;
			//НомерПодразделения			= СтруктураПаспортныхДанных.ДокументКодПодразделения;
			if(true/*НЕ (НЕ ЗначениеЗаполнено(ДатаВыдачи)
		   И НЕ ЗначениеЗаполнено(ВидДокумента)
		   И НЕ ЗначениеЗаполнено(Серия + Номер + КемВыдан + НомерПодразделения))*/)
			{
				/*Возврат ?(ВидДокумента.Пустая(),"","" + ВидДокумента + ", ") 
				+ "Серия: " + Серия + ", № " + Номер 
				+ ", Выдан: " + Формат(ДатаВыдачи,"ДФ='дд ММММ гггг'") + " года, " 
				+ КемВыдан + "; № подр. " + НомерПодразделения;*/
			}
			return null;
		}
		// ПолучитьПаспортныеДанныеСтрокой()
		// Процедура предназначена для преобразования номера документа.
		//
		// Параметры:
		//  Документ - (ДокументСсылка), документ, чей номер надо получить для печати.
		//
		// Возвращаемое значение.
		//  Строка - номер документа для печати
		//

		public object ПолучитьНомерНаПечать(/*Документ, МассивПрефиксов = Неопределено*/)
		{
			if(true/*Документ = Неопределено*/)
			{
			}
			//Номер   = СокрЛП(Документ.Номер);
			//Префикс = "";
			if(true/*МассивПрефиксов = Неопределено*/)
			{
				//Организация = Неопределено;
				if(true/*ТипЗнч(Документ) = Тип("ВыборкаИзРезультатаЗапроса")
			ИЛИ ТипЗнч(Документ) = Тип("Структура")*/)
				{
					//Организация = Документ.Организация;
				}
				//МассивПрефиксовДляОбхода = СформироватьМассивПрефиксовДляРИБИОрганизации(Организация);
			}
			return null;
		}
		// ПолучитьНомерНаПечать()
		// Заменяет одни термины, которые используются в коде, другими - уместными в интерфейсе.
		// Позволяет иметь один тот же код при разных названиях объектов.
		//
		// Параметры
		//  СтрокаИзИнтерфейса - строка - заголовок колонки, надпись и т.п.
		//
		// Возвращаемое значение:
		//  Строка - новый заголовок колонки, надпись и т.п.
		//

		public object ПреобразоватьСтрокуИнтерфейса(/*СтрокаИзИнтерфейса*/)
		{
			return null;
		}
		// ПреобразоватьСтрокуИнтерфейса()
		// Возвращает головную организацию для заданной организации
		// Если для организации реквизит ГоловнаяОрганизация не заполнен
		// это значит, что сама организация является голвной
		//
		// Параметры
		//  Организация – СправочникСсылка.Организации
		//                 <продолжение описания параметра>
		//
		// Возвращаемое значение:
		//   СправочникСсылка.Организации
		//

		public object ГоловнаяОрганизация(/*Организация*/)
		{
			//Запрос = Новый Запрос;
			//Запрос.УстановитьПараметр("Организация",Организация);
			/*Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Организации.ГоловнаяОрганизация
	|ИЗ
	|	Справочник.Организации КАК Организации
	|ГДЕ
	|	Организации.Ссылка = &Организация";*/
			//Выборка = Запрос.Выполнить().Выбрать();
			if(true/*Не Выборка.Следующий()*/)
			{
			}
			if(true/*Организация.Пустая() или Выборка.ГоловнаяОрганизация.Пустая()*/)
			{
			}
			return null;
		}
		// ГоловнаяОрганизация()

		public object ЭтоЮрЛицо(/*Организация*/)
		{
			//Запрос = Новый Запрос;
			//Запрос.УстановитьПараметр("Организация",Организация);
			/*Запрос.Текст =
	"ВЫБРАТЬ
	|	Организации.ЮрФизЛицо
	|ИЗ
	|	Справочник.Организации КАК Организации
	|ГДЕ
	|	Организации.Ссылка = &Организация";*/
			//Выборка = Запрос.Выполнить().Выбрать();
			return null;
		}
		// ЭтоЮрЛицо()

		public object ЭтоДоступнаяОрганизация(/*Организация*/)
		{
			//Запрос = Новый Запрос;
			//Запрос.УстановитьПараметр("Организация",Организация);
			/*Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Организации.ПометкаУдаления
	|ИЗ
	|	Справочник.Организации КАК Организации
	|ГДЕ
	|	Организации.Ссылка = &Организация";*/
			/*// если удалось прочитать закрытое поле - организация доступна
*/
			return null;
		}
		// ЭтоДоступнаяОрганизация()
		///////////////////////////////////////////////////////////////////////////////
		// РАБОТА С ПЕРЕЧИСЛЕНИЕМ "ПЕРИОДИЧНОСТЬ"
		// Функции не обрабатывают значения "Декада" и "Полугодие"
		// Функция возвращает ближайшую дату начала периода планирования
		//
		// Параметры
		//	Периодичность (Перечисления.Периодичность)	- периодичность планирования по сценарию.
		//	ДатаВПериоде (Дата)							- произвольная дата
		//
		// Возвращаемое значение:
		//	ДатаНачалаПериода		– ближайшая дата начала периода планирования
		//

		public object ДатаНачалаПериода(/*ДатаВПериоде,Периодичность*/)
		{
			if(true/*НЕ ТипЗнч(ДатаВПериоде)=Тип("Дата")*/)
			{
			}
			if(true/*Периодичность=Перечисления.Периодичность.День*/)
			{
			}
			return null;
		}
		// ДатаНачалаПериода()
		// Функция возвращает ближайшую дату окончания периода планирования
		//
		// Параметры
		//	Периодичность (Перечисления.Периодичность)	- периодичность планирования по сценарию.
		//	ДатаВПериоде (Дата)							- произвольная дата
		//
		// Возвращаемое значение:
		//	ДатаКонцаПериода	– ближайшая дата окончания периода планирования
		//

		public object ДатаКонцаПериода(/*ДатаВПериоде,Периодичность*/)
		{
			if(true/*Периодичность=Перечисления.Периодичность.День*/)
			{
			}
			return null;
		}
		// ДатаКонцаПериода()
		// Функция добавляет интервал к дате
		//
		// Параметры:
		//	Периодичность (Перечисления.Периодичность)	- пнриодичность планирования по сценарию.
		//	ДатаВПериоде (Дата)							- произвольная дата
		//	Смещение (число)							- определяет направление и количество периодов, в котором сдвигается дата
		//
		// Возвращаемое значение:
		//	Дата, отстоящая от исходной на заданное количество периодов
		//

		public object ДобавитьИнтервал(/*ДатаПериода,Периодичность,Смещение*/)
		{
			if(true/*Смещение = 0*/)
			{
				//НоваяДатаПериода = ДатаПериода;
			}
			return null;
		}
		// ДобавитьИнтервал()
		// Возвращает число дней в переданном периоде
		//
		// Параметры
		//  Периодичность – Перечисление.Периодичность элемент перечисления,
		//		для которого вычисляется количество дней
		//
		// Возвращаемое значение:
		//   ЧислоДнейВПериоде (число)  – число дней в переданном периоде
		//

		public object ЧислоДнейВПериоде(/*Периодичность*/)
		{
			if(true/*Периодичность=Перечисления.Периодичность.День*/)
			{
				//ЧислоДнейВПериоде=1;
			}
			return null;
		}
		// ЧислоДнейВПериоде()
		///////////////////////////////////////////////////////////////////////////////

		public object ВопросПерезаполнитьКУДиР(/**/)
		{
			//Ответ = Ложь;
			/*ТекстВопроса = 
		"Отражение платежа в Книге учета доходов и расходов настроено вручную.
		|Перезаполнить показатели Книги учета доходов и расходов?";*/
			//Ответ = (Вопрос(ТекстВопроса, РежимДиалогаВопрос.ДаНет, , КодВозвратаДиалога.Да) = КодВозвратаДиалога.Да);
			return null;
		}
		// Формирует список обособленных структурных подразделений организации

		public object ПолучитьСписокОбособленныхПодразделенийОрганизации(/*Организация*/)
		{
			/*Запрос = Новый Запрос(
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Организации.Ссылка,
	|	Организации.Наименование
	|ИЗ
	|	Справочник.Организации КАК Организации
	|ГДЕ
	|	Организации.ГоловнаяОрганизация = &Организация");*/
			//Запрос.УстановитьПараметр("Организация", Организация);
			//СписокОрганизаций = Новый СписокЗначений;
			//Выборка = Запрос.Выполнить().Выбрать();
			while(true/*Выборка.Следующий()*/)
			{
				//СписокОрганизаций.Добавить(Выборка.Ссылка, Выборка.Наименование);
			}
			return null;
		}
		// ПолучитьСписокОбособленныхПодразделенийОрганизации()
		//Удалает повторяющиеся элементы массива.

		public object УдалитьПовторяющиесяЭлементыМассива(/*Массив, НеИспользоватьНеопределено = Ложь, УдалитьПустыеЭлементыСсылочногоТипа = Ложь*/)
		{
			//ОписаниеТиповСправочники  = Справочники.ТипВсеСсылки();
			//ОписаниеТиповДокументы    = Документы.ТипВсеСсылки();
			//ОписаниеТиповПВХ          = ПланыВидовХарактеристик.ТипВсеСсылки();
			//ОписаниеТиповПланыСчетов  = ПланыСчетов.ТипВсеСсылки();
			//ОписаниеТиповПланыРасчета = ПланыВидовРасчета.ТипВсеСсылки();
			if(true/*ТипЗнч(Массив) = Тип("Массив")*/)
			{
				//УжеВМасссиве = Новый Соответствие;
				//БылоНеопределено = Ложь;
				//КолвоЭлементовВМассиве = Массив.Количество();
			}
			return null;
		}
		//Функция возвращает информацию об уполномоченных лицах организации и сведения о приказе назначения

		public object ПолучитьДанныеУполномоченногоЛица(/*Организация, Пользователь = Неопределено*/)
		{
			//Запрос = Новый Запрос;
			//МассивПользователей = Новый Массив;
			//МассивПользователей.Добавить(Справочники.Пользователи.ПустаяСсылка());
			if(true/*Пользователь <> Неопределено*/)
			{
				//МассивПользователей.Добавить(Пользователь);
			}
			//Запрос.УстановитьПараметр("Организация",Организация);
			//Запрос.УстановитьПараметр("Пользователи",МассивПользователей);
			/*Запрос.Текст = "
		|ВЫБРАТЬ
		|	УполномоченныеЛица.УполномоченноеЛицо,
		|	УполномоченныеЛица.ЗаКогоПодписывает,
		|	УполномоченныеЛица.НомерДатаПриказа,
		|	ВЫБОР
		|		КОГДА УполномоченныеЛица.Пользователь = ЗНАЧЕНИЕ(Справочник.ФизическиеЛица.ПустаяСсылка) ТОГДА
		|			0
		|		ИНАЧЕ 1
		|	КОНЕЦ КАК ТипПользователя
		|ИЗ
		|	РегистрСведений.УполномоченныеЛицаОрганизаций КАК УполномоченныеЛица
		|ГДЕ
		|	УполномоченныеЛица.Организация = &Организация И
		|	УполномоченныеЛица.Пользователь В (&Пользователи)
		|УПОРЯДОЧИТЬ ПО
		|	ТипПользователя";*/
			//УстановитьПривилегированныйРежим(Истина);
			//Результат = Запрос.Выполнить();
			//УстановитьПривилегированныйРежим(Ложь);
			if(true/*Результат.Пустой()*/)
			{
			}
			return null;
		}
		// Функция собирает сведения об ответственных лицах организации
		//
		// Параметры:
		//  Организация - организация, для которой нужно определить руководящих лиц.
		//

		public object ОтветственныеЛица(/*Организация, ДатаСреза, Подразделение = Неопределено*/)
		{
			//СобиратьПоОрганизации = Истина;
			/*Результат = Новый Структура("Руководитель, РуководительДолжность, РуководительФИО, РуководительПредставление, 
								|ГлавныйБухгалтер, ГлавныйБухгалтерДолжность, ГлавныйБухгалтерФИО, ГлавныйБухгалтерПредставление, 
								|Кассир, КассирДолжность, КассирФИО, КассирПредставление,  
								|ОтветственныйЗаРегистры, ОтветственныйЗаРегистрыДолжность, ОтветственныйЗаРегистрыФИО, ОтветственныйЗаРегистрыПредставление");*/
			if(true/*Организация <> Неопределено*/)
			{
				//ЗапросПоЛицам = Новый Запрос();
				//ЗапросПоЛицам.УстановитьПараметр("ДатаСреза",   ДатаСреза);
				//ЗапросПоЛицам.УстановитьПараметр("Организация", Организация);
				//ЗапросПоЛицам.УстановитьПараметр("ПризнакФизЛица",   Перечисления.ЮрФизЛицо.ФизЛицо);
				/*ЗапросПоЛицам.Текст = "ВЫБРАТЬ
		                      |	ФИОФизЛицСрезПоследних.Фамилия,
		                      |	ФИОФизЛицСрезПоследних.Имя,
		                      |	ФИОФизЛицСрезПоследних.Отчество,
		                      |	ФИОФизЛицСрезПоследних.ФизЛицо КАК ФизическоеЛицо
		                      |ИЗ
		                      |	РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ) КАК ФИОФизЛицСрезПоследних
		                      |		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.Организации КАК Организации
		                      |		ПО ФИОФизЛицСрезПоследних.ФизЛицо = Организации.ИндивидуальныйПредприниматель
		                      |			И (Организации.Ссылка = &Организация)
		                      |			И (Организации.ЮрФизЛицо = &ПризнакФизЛица)";*/
				//Руководители = ЗапросПоЛицам.Выполнить().Выбрать();
				while(true/*Руководители.Следующий()*/)
				{
					//ФИО = Новый Структура("Фамилия, Имя, Отчество, Представление");
					if(true/*НЕ (НЕ ЗначениеЗаполнено(Руководители.Фамилия) или Руководители.Фамилия = NULL)*/)
					{
						//ФИО.Фамилия = Руководители.Фамилия;
					}
					if(true/*НЕ (НЕ ЗначениеЗаполнено(Руководители.Имя) или Руководители.Имя = NULL)*/)
					{
						//ФИО.Имя = Руководители.Имя;
					}
					if(true/*НЕ (НЕ ЗначениеЗаполнено(Руководители.Отчество) или Руководители.Отчество = NULL)*/)
					{
						//ФИО.Отчество = Руководители.Отчество;
					}
					//Представление = ПолучитьФамилиюИмяОтчество(ФИО.Фамилия, ФИО.Имя, ФИО.Отчество);
					//Результат.Руководитель               = Руководители.ФизическоеЛицо;
					//Результат.РуководительДолжность      = "";
					//Результат.РуководительФИО            = ФИО;
					//Результат.РуководительПредставление  = Представление;
				}
				if(true/*СобиратьПоОрганизации*/)
				{
					/*ЗапросПоЛицам.Текст = 
			"ВЫБРАТЬ
			|	ОтветственныеЛицаОрганизацийСрезПоследних.ОтветственноеЛицо,
			|	ОтветственныеЛицаОрганизацийСрезПоследних.ФизическоеЛицо,
			|	ОтветственныеЛицаОрганизацийСрезПоследних.Должность,
			|	ФИОФизЛицСрезПоследних.Фамилия,
			|	ФИОФизЛицСрезПоследних.Имя,
			|	ФИОФизЛицСрезПоследних.Отчество
			|ИЗ
			|	РегистрСведений.ОтветственныеЛицаОрганизаций.СрезПоследних(&ДатаСреза, СтруктурнаяЕдиница = &Организация) КАК ОтветственныеЛицаОрганизацийСрезПоследних
			|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо ССЫЛКА Справочник.ФизическиеЛица) КАК ФИОФизЛицСрезПоследних
			|		ПО ОтветственныеЛицаОрганизацийСрезПоследних.ФизическоеЛицо = ФИОФизЛицСрезПоследних.ФизЛицо";*/
					//Руководители = ЗапросПоЛицам.Выполнить().Выбрать();
				}
				while(true/*Руководители.Следующий()*/)
				{
					//ФИО = Новый Структура("Фамилия, Имя, Отчество, Представление");
					if(true/*НЕ (НЕ ЗначениеЗаполнено(Руководители.Фамилия) или Руководители.Фамилия = NULL)*/)
					{
						//ФИО.Фамилия = Руководители.Фамилия;
					}
					if(true/*НЕ (НЕ ЗначениеЗаполнено(Руководители.Имя) или Руководители.Имя = NULL)*/)
					{
						//ФИО.Имя = Руководители.Имя;
					}
					if(true/*НЕ (НЕ ЗначениеЗаполнено(Руководители.Отчество) или Руководители.Отчество = NULL)*/)
					{
						//ФИО.Отчество = Руководители.Отчество;
					}
					//Представление = ПолучитьФамилиюИмяОтчество(ФИО.Фамилия, ФИО.Имя, ФИО.Отчество);
					if(true/*Руководители.ОтветственноеЛицо      = Перечисления.ОтветственныеЛицаОрганизаций.Руководитель*/)
					{
						//Результат.Руководитель               = Руководители.ФизическоеЛицо;
						//Результат.РуководительДолжность      = Руководители.Должность;
						//Результат.РуководительФИО            = ФИО;
						//Результат.РуководительПредставление  = Представление;
					}
				}
				//;;
			}
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЧИЕ ПРОЦЕДУРЫ И ФУНКЦИИ
		// Получает первичную информацию об ошибке
		// Параметры:
		//	ИнформацияОбОшибке - информация об ошибке
		// Возвращает:
		//	Информацию об ошибке, которая является первопричиной возникновения переданной ИнформацияОбОшибке
		//  Если ошибка первичная, то возвращается сама ошибка, переданная в качестве параметра

		public object ПолучитьПричинуОшибки(/*ИнформацияОбОшибке*/)
		{
			//ПричинаОшибки = ИнформацияОбОшибке.Причина;
			if(true/*ПричинаОшибки = НеОпределено*/)
			{
			}
			while(true/*ПричинаОшибки.Причина <> НеОпределено*/)
			{
				//ПричинаОшибки = ПричинаОшибки.Причина;
			}
			return null;
		}
		// Считываем последнее состояние регистра сведений о физлице и заполняем переданный набор записей
		//
		// Параметры
		//  Физлицо -
		//  НаборЗаписей  -
		//

		public void ПолучитьСвязанныеДанныеФизлица(/*Физлицо, НаборЗаписей*/)
		{
			//НаборЗаписей.Очистить();
			if(true/*Физлицо.Пустая()*/)
			{
			}
			//ИмяТаблицы = НаборЗаписей.Метаданные().Имя;
			//Запрос = Новый Запрос;
			//Запрос.УстановитьПараметр("ПарамФизЛицо",Физлицо);
			//Запрос.УстановитьПараметр("парамДатаСреза", ОбщегоНазначения.ПолучитьРабочуюДату());
			/*Запрос.Текст = 
	"ВЫБРАТЬ
	|	СвязанныеДанные.*
	|ИЗ
	|	РегистрСведений." + ИмяТаблицы + ".СрезПоследних(&парамДатаСреза, ФизЛицо = &ПарамФизЛицо) КАК СвязанныеДанные";*/
			//Выборка = Запрос.Выполнить().Выбрать();
			if(true/*Выборка.Следующий()*/)
			{
				//ЗаполнитьЗначенияСвойств(НаборЗаписей.Добавить(), Выборка);
			}
		}
		// ПолучитьСвязанныеДанныеФизлица()
		////////////////////////////////////////////////////////////////////////////////
		// ПРОЦЕДУРЫ ОБСЛУЖИВАНИЯ ОБЪЕКТОВ, НЕ ПОДДЕРЖИВАЕМЫХ В КОНФИГУРАЦИИ
		//
		// Выводит сообщение о том, что объект не используется в конфигурации
		//

		public void СообщитьОбъектНеИспользуется(/*МетаданныеОбъекта = Неопределено, Отказ = Истина, СтандартнаяОбработка = Ложь*/)
		{
			//ТипОбъекта = "Объект";
			if(true/*МетаданныеОбъекта <> Неопределено*/)
			{
				//ПолноеИмяОбъекта = МетаданныеОбъекта.ПолноеИмя();
				//ПозицияТочки = Найти(ПолноеИмяОбъекта, ".");
				if(true/*ПозицияТочки <> 0*/)
				{
					//ТипОбъекта = Лев(ПолноеИмяОбъекта, ПозицияТочки-1);
				}
			}
			//ОбщегоНазначения.СообщитьОбОшибке(ТипОбъекта+" не используется в конфигурации """ + Метаданные.Синоним + """", Отказ);
			//СтандартнаяОбработка = Ложь;
		}
		// Заполняет указанную колонку таблицы значений числами по порядку, начиная с указанного номера
		//

		public void ПронумероватьСтрокиТаблицыЗначений(/*Таблица, ИмяКолонки = "НомерСтроки", ПервыйНомер = 1*/)
		{
			//НомерСтроки = ПервыйНомер;
		}
	}
}
