using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace V82.ОбщиеМодули
{
	public partial class ОбщегоНазначенияКлиентСервер
	{
		////////////////////////////////////////////////////////////////////////////////
		// Клиентские и серверные процедуры общего назначения
		// Формирует и выводит сообщение, которое может быть связано с элементом
		// управления формы.
		//
		//  Параметры
		//  ТекстСообщенияПользователю - Строка - текст сообщения.
		//  КлючДанных                - Любая ссылка на объект информационной базы.
		//                               Ссылка на объект информационной базы, к которому это сообщение относится,
		//                               или ключ записи.
		//  Поле                       - Строка - наименование реквизита формы
		//  ПутьКДанным                - Строка - путь к данным (путь к реквизиту формы)
		//  Отказ                      - Булево - Выходной параметр
		//                               Всегда устанавливается в значение Истина
		//
		//	Примеры использования:
		//
		//	1. Для вывода сообщения у поля управляемой формы, связанного с реквизитом объекта:
		//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
		//		НСтр("ru = 'Сообщение об ошибке.'"), ,
		//		"ПолеВРеквизитеФормыОбъект",
		//		"Объект");
		//
		//	Альтернативный вариант использования в форме объекта:
		//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
		//		НСтр("ru = 'Сообщение об ошибке.'"), ,
		//		"Объект.ПолеВРеквизитеФормыОбъект");
		//
		//	2. Для вывода сообщения рядом с полем управляемой формы, связанным с реквизитом формы:
		//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
		//		НСтр("ru = 'Сообщение об ошибке.'"), ,
		//		"ИмяРеквизитаФормы");
		//
		//	3. Для вывода сообщения связанного с объектом информационной базы
		//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
		//		НСтр("ru = 'Сообщение об ошибке.'"), ОбъектИнформационнойБазы, "Ответственный",,Отказ);
		//
		// 4. Для вывода сообщения по ссылке на объект информационной базы
		//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
		//		НСтр("ru = 'Сообщение об ошибке.'"), Ссылка, , , Отказ);
		//
		// Случаи некорректного использования:
		//  1. Передача одновременно параметров КлючДанных и ПутьКДанным
		//  2. Передача в параметре КлючДанных значения типа отличного от допустимых
		//  3. Установка ссылки без установки поля (и/или пути к данным)
		//

		public void СообщитьПользователю(/*
		Знач ТекстСообщенияПользователю,
		Знач КлючДанных = Неопределено,
		Знач Поле = "",
		Знач ПутьКДанным = "",
		Отказ = Ложь*/)
		{
			//Сообщение = Новый СообщениеПользователю;
			//Сообщение.Текст = ТекстСообщенияПользователю;
			//Сообщение.Поле = Поле;
			//ЭтоОбъект = Ложь;
			if(true/*КлючДанных <> Неопределено
	   И XMLТипЗнч(КлючДанных) <> Неопределено*/)
			{
				//ТипЗначенияСтрокой = XMLТипЗнч(КлючДанных).ИмяТипа;
				//ЭтоОбъект = Найти(ТипЗначенияСтрокой, "Object.") > 0;
			}
			if(true/*ЭтоОбъект*/)
			{
				//Сообщение.УстановитьДанные(КлючДанных);
			}
			if(true/*НЕ ПустаяСтрока(ПутьКДанным)*/)
			{
				//Сообщение.ПутьКДанным = ПутьКДанным;
			}
			//Сообщение.Сообщить();
			//Отказ = Истина;
		}
		// Формирует текст сообщения, подставляя значения
		// параметров в шаблоны сообщений.
		//
		// Параметры
		//  ВидПоля       - Строка - может принимать значения:
		//                  Поле, Колонка, Список
		//  ВидСообщения  - Строка - может принимать значения:
		//                  Заполнение, Корректность
		//  Параметр1     - Строка - имя поля
		//  Параметр2     - Строка - номер строки
		//  Параметр3     - Строка - имя списка
		//  Параметр4     - Строка - текст сообщения о некорректности заполнения
		//
		// Возвращаемое значение:
		//   Строка - текст сообщения
		//

		public object ПолучитьТекстСообщения(/*ВидПоля = "Поле", ВидСообщения = "Заполнение",
	Параметр1 = "", Параметр2 = "",	Параметр3 = "", Параметр4 = ""*/)
		{
			//ТекстСообщения = "";
			if(true/*ВРег(ВидПоля) = "ПОЛЕ"*/)
			{
				if(true/*ВРег(ВидСообщения) = "ЗАПОЛНЕНИЕ"*/)
				{
					//Шаблон = НСтр("ru = 'Поле ""%1"" не заполнено'");
				}
			}
			return null;
		}
		// Формирует путь к заданной строке НомерСтроки и колонке ИмяРеквизита
		// табличной части ИмяТабличнойЧасти для выдачи сообщений в форме.
		// Для совместного использования с процедурой СообщитьПользователю
		// (для передачи в параметры Поле или ПутьКДанным).
		//
		// Параметры:
		//  ИмяТабличнойЧасти - Строка - имя табличной части.
		//  НомерСтроки       - Число - номер строки табличной части.
		//  ИмяРеквизита      - Строка - имя реквизита.
		//
		// Возвращаемое значение:
		//  Строка.
		//

		public object ПутьКТабличнойЧасти(/*Знач ИмяТабличнойЧасти, Знач НомерСтроки, 
	Знач ИмяРеквизита*/)
		{
			//Возврат ИмяТабличнойЧасти + "[" + Формат(НомерСтроки - 1, "ЧН=0; ЧГ=0") + "]." + ИмяРеквизита;
			return null;
		}
		// Дополняет таблицу значений-приемник данными из таблицы значений-источник
		//
		// Параметры:
		//  ТаблицаИсточник - Таблица значений - таблица из которой будут браться строки для заполнения
		//  ТаблицаПриемник - Таблица значений - таблица в которую будут добавлены строки из таблицы-источника
		//

		public void ДополнитьТаблицу(/*ТаблицаИсточник, ТаблицаПриемник*/)
		{
		}
		// Дополняет таблицу значений Таблица значениями из массива Массив.
		//
		// Параметры:
		//  Таблица - ТаблицаЗначений - таблица, которую необходимо заполнить значениями из массива
		//  Массив - Массив - массив значений для заполнения таблицы
		//  ИмяПоля - Строка - имя поля таблицы значений, в которое необходимо загрузить значения из массива
		//

		public void ДополнитьТаблицуИзМассива(/*Таблица, Массив, ИмяПоля*/)
		{
		}
		// Снимает один элемент условного оформления, если это список значений.
		// Параметры
		// УсловноеОформление - условное оформление элемента формы
		// ИдентификаторПользовательскойНастройки - строка - идентификатор настройки
		// Значение - значение, которое требуется удалить из списка оформления
		//

		public void СнятьУсловноеОформлениеСпискаЗначений(/*
						УсловноеОформление,
						знач ИдентификаторПользовательскойНастройки,
						знач Значение*/)
		{
		}
		// Удаляет одно значение из массива
		//
		// Параметры:
		//  Массив - массив, из которого необходимо удалить значение
		//  Значение - удаляемое значение из массива
		//

		public void УдалитьЗначениеИзМассива(/*Массив, Значение*/)
		{
			//Индекс = Массив.Найти(Значение);
			if(true/*Индекс <> Неопределено*/)
			{
				//Массив.Удалить(Индекс);
			}
		}
		// Удаляет все вхождения переданного значения из массива
		//
		// Параметры:
		//  Массив - массив, из которого необходимо удалить значение
		//  Значение - удаляемое значение из массива
		//

		public void УдалитьВсеВхожденияЗначенияИзМассива(/*Массив, Значение*/)
		{
			//КолвоЭлементовКоллекции = Массив.Количество();
		}
		// Удаляет все вхождения значений указанного типа
		//
		// Параметры:
		//  Массив - массив, из которого необходимо удалить значения
		//  Тип – тип, значения которых следует удалить из коллекции
		//

		public void УдалитьВсеВхожденияТипаИзМассива(/*Массив, Тип*/)
		{
			//КолвоЭлементовКоллекции = Массив.Количество();
		}
		// Заполняет коллекцию-приемник значениями из коллекции-источник
		// В качестве коллекций источника и приемника могут выступать типы:
		// ТаблицаЗначений; ДеревоЗначений; СписокЗначений и пр.
		//
		// Параметры:
		//  КоллекцияИсточник - коллекция значений, которая является источником для заполнения данных
		//  КоллекцияПриемник - коллекция значений, которая является приемником для заполнения данных
		//

		public void ЗаполнитьКоллекциюСвойств(/*КоллекцияИсточник, КоллекцияПриемник*/)
		{
		}
		// Получает массив значений из отмеченных элементов списка значений
		//
		// Параметры:
		//  Список - СписокЗначений - список значений из которого будет формироваться массив значений
		//
		// Возвращаемое значение:
		//  Массив - массив значений из отмеченных элементов списка значений
		//

		public object ПолучитьМассивОтмеченныхЭлементовСписка(/*Список*/)
		{
			/*// возвращаемое значение функции
*/
			//Массив = Новый Массив;
			return null;
		}
		// Вычитает один массив элементов из другого массива. Возвращает результат вычитания.
		//
		// Параметры:
		//  Массив - массив элементов, из которого необходимо выполнить вычитание
		//  МассивВычитания - массив элементов, который будет вычитаться
		//
		//  Возвращаемое значение:
		//  Массив – результат вычитания двух массивов
		//

		public object СократитьМассив(/*Массив, МассивВычитания*/)
		{
			//Результат = Новый Массив;
			return null;
		}
		// Преобразует РасписаниеРегламентногоЗадания в структуру.
		//
		// Параметры:
		//  Расписание - РасписаниеРегламентногоЗадания
		//
		// Возвращаемое значение:
		//  Структура
		//

		public object РасписаниеВСтруктуру(/*Знач Расписание*/)
		{
			//ЗначениеРасписания = Расписание;
			if(true/*ЗначениеРасписания = Неопределено*/)
			{
				//ЗначениеРасписания = Новый РасписаниеРегламентногоЗадания();
			}
			/*СписокПолей = "ВремяЗавершения,ВремяКонца,ВремяНачала,ДатаКонца,ДатаНачала,ДеньВМесяце,ДеньНеделиВМесяце," + 
		"ДниНедели,ИнтервалЗавершения,Месяцы,ПаузаПовтора,ПериодНедель,ПериодПовтораВТечениеДня,ПериодПовтораДней";*/
			//Результат = Новый Структура(СписокПолей);
			//ЗаполнитьЗначенияСвойств(Результат, ЗначениеРасписания, СписокПолей);
			//ДетальныеРасписанияДня = Новый Массив;
			//Результат.Вставить("ДетальныеРасписанияДня", ДетальныеРасписанияДня);
			return null;
		}
		// Преобразует структуру в РасписаниеРегламентногоЗадания.
		//
		// Параметры:
		//  СтруктураРасписания - Структура
		//
		// Возвращаемое значение:
		//  РасписаниеРегламентногоЗадания
		//

		public object СтруктураВРасписание(/*Знач СтруктураРасписания*/)
		{
			if(true/*СтруктураРасписания = Неопределено*/)
			{
			}
			/*СписокПолей = "ВремяЗавершения,ВремяКонца,ВремяНачала,ДатаКонца,ДатаНачала,ДеньВМесяце,ДеньНеделиВМесяце," + 
		"ДниНедели,ИнтервалЗавершения,Месяцы,ПаузаПовтора,ПериодНедель,ПериодПовтораВТечениеДня,ПериодПовтораДней";*/
			//Результат = Новый РасписаниеРегламентногоЗадания;
			//ЗаполнитьЗначенияСвойств(Результат, СтруктураРасписания, СписокПолей);
			//ДетальныеРасписанияДня = Новый Массив;
			//Результат.ДетальныеРасписанияДня = ДетальныеРасписанияДня;
			return null;
		}
		// Создает новый экземпляр объекта Структура, заполняет объект данными указанной структуры.
		//
		// Параметры:
		//  СтруктураИсточник – Структура – структура, копию которой необходимо получить
		//
		//  Возвращаемое значение:
		//  Тип: Структура.
		//

		public object СкопироватьСтруктуру(/*СтруктураИсточник*/)
		{
			//СтруктураРезультат = Новый Структура;
			return null;
		}
		// Функция выполняет поиск элемента в коллекции: списке значений или массиве
		//

		public object НайтиВСписке(/*Список, Элемент*/)
		{
			if(true/*ТипЗнч(Список) = Тип("СписокЗначений")*/)
			{
				if(true/*ТипЗнч(Элемент) = Тип("ЭлементСпискаЗначений")*/)
				{
					//ЭлементВСписке = Список.НайтиПоЗначению(Элемент.Значение);
				}
			}
			if(true/*ТипЗнч(Список) = Тип("Массив")*/)
			{
				//ЭлементВСписке = Список.Найти(Элемент);
			}
			return null;
		}
		// ЭлементПрисутствуетВСписке
		// Сравнивает элементы списков значений или массивов по значениям
		//

		public object СпискиЗначенийИдентичны(/*Список1, Список2*/)
		{
			//СпискиИдентичны = Истина;
			if(true/*СпискиИдентичны*/)
			{
			}
			return null;
		}
		// СпискиЗначенийИдентичны
		// Возвращает шаблон структуры параметров для установки внешнего соединения.
		// Параметрам необходимо задать требуемые значения и передать
		// в метод ОбщегоНазначения.УстановитьВнешнееСоединение()
		//

		public object СтруктураПараметровДляУстановкиВнешнегоСоединения(/**/)
		{
			//СтруктураПараметров = Новый Структура;
			//СтруктураПараметров.Вставить("ВариантРаботыИнформационнойБазы", 0);
			//СтруктураПараметров.Вставить("КаталогИнформационнойБазы", "");
			//СтруктураПараметров.Вставить("ИмяСервера1СПредприятия", "");
			//СтруктураПараметров.Вставить("ИмяИнформационнойБазыНаСервере1СПредприятия", "");
			//СтруктураПараметров.Вставить("АутентификацияОперационнойСистемы", Ложь);
			//СтруктураПараметров.Вставить("ИмяПользователя", "");
			//СтруктураПараметров.Вставить("ПарольПользователя", "");
			return null;
		}
		// Извлекает из строки соединения с информационной базой параметры подключения
		// и передает параметры в структуру для установки внешнего соединения.
		//

		public object ПолучитьПараметрыПодключенияИзСтрокиСоединенияИнформационнойБазы(/*Знач СтрокаСоединения*/)
		{
			//Результат = СтруктураПараметровДляУстановкиВнешнегоСоединения();
			//Параметры = СтроковыеФункцииКлиентСервер.ПолучитьПараметрыИзСтроки(СтрокаСоединения);
			//Параметры.Свойство("File", Результат.КаталогИнформационнойБазы);
			//Параметры.Свойство("Srvr", Результат.ИмяСервера1СПредприятия);
			//Параметры.Свойство("Ref",  Результат.ИмяИнформационнойБазыНаСервере1СПредприятия);
			//Результат.ВариантРаботыИнформационнойБазы = ?(Параметры.Свойство("File"), 0, 1);
			return null;
		}
		// Получает идентификатор (метод ПолучитьИдентификатор()) строки дерева значений для заданного значения поля строки дерева.
		// Используется для позиционирования курсора в иерархических списках.
		//

		public void ПолучитьИдентификаторСтрокиДереваПоЗначениюПоля(/*ИмяПоля, ИдентификаторСтроки, КоллекцияЭлементовДерева, КлючСтроки, ПрекратитьПоиск*/)
		{
		}
		// Заменяет недопустимые символы в XML-строке на заданные символы
		//
		// Параметры:
		//   Текст – Строка – строка, в которой требуется выполнить замену недопустимых символов.
		//   СимволЗамены – Строка – строка, на которую требуется выполнить замену недопустимого символа в XML-строке
		//
		//  Возвращаемое значение:
		//    Строка - cтрока, полученная заменой недопустимых символов в XML-строке.
		//

		public object ЗаменитьНедопустимыеСимволыXML(/*Знач Текст, СимволЗамены = " "*/)
		{
			//ПозицияНачала = 1;
			while(true/*Истина*/)
			{
				//Позиция = НайтиНедопустимыеСимволыXML(Текст, ПозицияНачала);
				if(true/*Позиция = 0*/)
				{
				}
				/*// Если возращается позиция, больше чем должна быть, то корректируем ее.
*/
				if(true/*Позиция > 1*/)
				{
					//НедопустимыйСимвол = Сред(Текст, Позиция - 1, 1);
					if(true/*НайтиНедопустимыеСимволыXML(НедопустимыйСимвол) > 0*/)
					{
						//Текст = СтрЗаменить(Текст, НедопустимыйСимвол, СимволЗамены);
					}
				}
				//НедопустимыйСимвол = Сред(Текст, Позиция, 1);
				if(true/*НайтиНедопустимыеСимволыXML(НедопустимыйСимвол) > 0*/)
				{
					//Текст = СтрЗаменить(Текст, НедопустимыйСимвол, СимволЗамены);
				}
				//ПозицияНачала = Позиция + 1;
			}
			return null;
		}
		// Удаляет недопустимые символы в XML-строке.
		//
		// Параметры:
		//  Текст – Строка – строка, в которой требуется удалить недопустимые символы.
		//
		//  Возвращаемое значение:
		//  Тип: Строка. Строка, полученная при удалении недопустимых символов в XML-строке.
		//

		public object УдалитьНедопустимыеСимволыXML(/*Знач Текст*/)
		{
			return null;
		}
		// Сравнивает расписания между собой.
		//
		// Параметры
		//	Расписание1, Расписание2 - РасписаниеРегламентногоЗадания
		//
		// Возвращаемое значение
		//  Булево - истина, если расписания идентичны, иначе ложь.

		public object РасписанияОдинаковые(/*Знач Расписание1, Знач Расписание2*/)
		{
			//Расписание1 = РасписаниеВСтруктуру(Расписание1);
			//Расписание2 = РасписаниеВСтруктуру(Расписание2);
			return null;
		}
		// Удаляет заданный литерал (префикс) в именах ключей переданной структуры.
		// Создает новую структуру.
		//
		//  Параметры:
		// Структура. Тип: Структура.
		// Структура элементов, на основании которой необходимо создать новую структуру с ключами без заданного литерала.
		//
		// Литерал. Тип: Строка.
		// Строка символов, которую необходимо исключить из имени ключей переданной структуры.
		//
		//  Возвращающее значение:
		// Тип. Структура.
		// Возвращаемая структура получается на основании копирования исходной структуры.
		//

		public object УдалитьПрефиксВКлючахКоллекции(/*Структура, Литерал*/)
		{
			//Результат = Новый Структура;
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// Функции для поддержки формирования печатных форм
		//
		// Возвращает заголовок документа в том виде, в котором его формирует платформа для представления ссылки на документ.
		//
		// Параметры
		//  Шапка - Структура с ключами
		//          Номер - строка или число - номер документа
		//          Дата  - дата - дата документа
		//  НазваниеДокумента - Строка - название документа (например, синоним объекта метаданных)
		//
		// Возвращаемое значение
		//  Строка - заголовок документа
		//

		public object СформироватьЗаголовокДокумента(/*Шапка, знач НазваниеДокумента = ""*/)
		{
			/*// Если название документа не передано, получим название по представлению документа
*/
			if(true/*НазваниеДокумента = ""	И Шапка.Свойство("Представление") И ЗначениеЗаполнено(Шапка.Представление)*/)
			{
				//ПоложениеНомера = Найти(Шапка.Представление, Шапка.Номер);
				if(true/*ПоложениеНомера > 0*/)
				{
					//НазваниеДокумента = СокрЛП(Лев(Шапка.Представление, ПоложениеНомера - 1));
				}
			}
			//НомерНаПечать = Шапка.Номер;
			//СтандартнаяОбработка = Истина;
			//СтандартныеПодсистемыКлиентСерверПереопределяемый.ПолучитьНомерНаПечать(НомерНаПечать, СтандартнаяОбработка);
			if(true/*СтандартнаяОбработка*/)
			{
				//НомерНаПечать = Шапка.Номер;
			}
			/*Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = '%1 № %2 от %3'"),
		НазваниеДокумента, НомерНаПечать, Формат(Шапка.Дата, "ДФ='дд ММММ гггг'"));*/
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// Функции для работы с файловой системой
		//
		// Процедура УдалитьКаталогСФайлами удаляет все файлы в заданном каталоге.
		//
		// Параметры:
		//  Путь         - Строка, полный путь каталога, в котором требуется
		//                 удалить все файлы.
		//

		public void УдалитьКаталогСФайлами(/*Путь*/)
		{
			//Каталог = Новый Файл(Путь);
			if(true/*Каталог.Существует()*/)
			{
				//УдалитьФайлы(Путь);
			}
		}
		// УдалитьКаталогСФайлами()
		// Добавляет к переданному пути каталога конечный символ-разделитель, если он отсутствует.
		// В случае, когда параметр "Платформа" не указан, разделитель выбирается, исходя из уже имеющихся
		// разделителей в параметре "ПутьКаталога".
		//
		// Параметры:
		//  ПутьКаталога - Строка - путь к каталогу;
		//  Платформа - ТипПлатформы - тип платформы, в рамках которой осуществляется работа (влияет на выбор разделителя).
		//
		// Возвращаемое значение:
		//  Строка   - путь к каталогу с конечным символом-разделителем.
		//
		// Примеры использования:
		//  Результат = ДобавитьКонечныйРазделительПути("C:\Мой каталог"); // возвращает "C:\Мой каталог\"
		//  Результат = ДобавитьКонечныйРазделительПути("C:\Мой каталог\"); // возвращает "C:\Мой каталог\"
		//  Результат = ДобавитьКонечныйРазделительПути("ftp://Мой каталог"); // возвращает "ftp://Мой каталог/"
		//	Результат = ДобавитьКонечныйРазделительПути("%APPDATA%", ТипПлатформы.Windows_x86_64); // возвращает "%APPDATA%\"
		//

		public object ДобавитьКонечныйРазделительПути(/*Знач ПутьКаталога, Знач Платформа = Неопределено*/)
		{
			if(true/*ПустаяСтрока(ПутьКаталога)*/)
			{
			}
			//ДобавляемыйСимвол = "\";
			if(true/*Платформа = Неопределено*/)
			{
				if(true/*Найти(ПутьКаталога, "/") > 0*/)
				{
					//ДобавляемыйСимвол = "/";
				}
			}
			if(true/*Прав(ПутьКаталога, 1) <> ДобавляемыйСимвол*/)
			{
			}
			return null;
		}
		// Составляет полное имя файла из имени каталога и имени файла.
		//
		// Параметры
		//  ИмяКаталога  – Строка, содержащая путь к каталогу файла на диске.
		//  ИмяФайла     – Строка, содержащая имя файла, без имени каталога.
		//
		// Возвращаемое значение:
		//   Строка – полное имя файла с учетом каталога.
		//

		public object ПолучитьПолноеИмяФайла(/*Знач ИмяКаталога, Знач ИмяФайла*/)
		{
			if(true/*НЕ ПустаяСтрока(ИмяФайла)*/)
			{
				//Слэш = "";
				if(true/*(Прав(ИмяКаталога, 1) <> "\") И (Прав(ИмяКаталога, 1) <> "/")*/)
				{
					//Слэш = ?(Найти(ИмяКаталога, "\") = 0, "/", "\");
				}
			}
			return null;
		}
		// Раскладывает полное имя файла на составляющие.
		//
		// Параметры
		//  ПолноеИмяФайла – Строка, содержащая полный путь к файлу.
		//  ЭтоПапка – Булево, признак того, что требуется разложить полное имя папки, а не файла.
		//
		// Возвращаемое значение:
		//   Структура – имя файла, разложенное на составные части(аналогично свойствам объекта Файл):
		//		ПолноеИмя - Содержит полный путь к файлу, т.е. полностью соответствует входному параметру ПолноеИмяФайла.
		//		Путь - Содержит путь к каталогу, в котором лежит файл.
		//		Имя - Содержит имя файла с расширением, без пути к файлу.
		//		Расширение - Содержит расширение файла
		//		ИмяБезРасширения - Содержит имя файла без расширения и без пути к файлу.
		//			Пример: если ПолноеИмяФайла = "c:\temp\test.txt", то структура заполнится следующим образом:
		//				ПолноеИмя: "c:\temp\test.txt"
		//				Путь: "c:\temp\"
		//				Имя: "test.txt"
		//				Расширение: ".txt"
		//				ИмяБезРасширения: "test"
		//

		public object РазложитьПолноеИмяФайла(/*Знач ПолноеИмяФайла, ЭтоПапка = Ложь*/)
		{
			//СтруктураИмениФайла = Новый Структура("ПолноеИмя,Путь,Имя,Расширение,ИмяБезРасширения");
			/*// Убераем из полного имени файла завершающий слеш и сохраняем получившееся полное имя в структуре
*/
			if(true/*ЭтоПапка И (Прав(ПолноеИмяФайла, 1) = "/" Или Прав(ПолноеИмяФайла, 1) = "\")*/)
			{
				if(true/*ЭтоПапка*/)
				{
					//ПолноеИмяФайла = Сред(ПолноеИмяФайла, 1, СтрДлина(ПолноеИмяФайла) - 1);
				}
			}
			//СтруктураИмениФайла.Вставить("ПолноеИмя", ПолноеИмяФайла);
			/*// Если полное имя файла оказалось пустым - то остальные параметры структуры возвращаем пустыми
*/
			if(true/*СтрДлина(ПолноеИмяФайла) = 0*/)
			{
				//СтруктураИмениФайла.Вставить("Путь", "");
				//СтруктураИмениФайла.Вставить("Имя", "");
				//СтруктураИмениФайла.Вставить("Расширение", "");
				//СтруктураИмениФайла.Вставить("ИмяБезРасширения", "");
			}
			/*// Выделяем путь к файлу и имя файла									 
*/
			if(true/*Найти(ПолноеИмяФайла, "/") > 0*/)
			{
				//ПозицияРазделителя = СтроковыеФункцииКлиентСервер.НайтиСимволСКонца(ПолноеИмяФайла, "/");
			}
			//СтруктураИмениФайла.Вставить("Путь", Лев(ПолноеИмяФайла, ПозицияРазделителя));
			//СтруктураИмениФайла.Вставить("Имя", Сред(ПолноеИмяФайла, ПозицияРазделителя + 1));
			/*// Папки не имеют расширений, а для файла выделяем расширение
*/
			if(true/*ЭтоПапка*/)
			{
				//СтруктураИмениФайла.Вставить("Расширение", "");
				//СтруктураИмениФайла.Вставить("ИмяБезРасширения", СтруктураИмениФайла.Имя);
			}
			return null;
		}
		// Возвращает строку недопустимых символов
		// Возвращаемое значение:
		//   Строка - строка недопустимых символов

		public object ПолучитьНедопустимыеСимволыВИмениФайла(/**/)
		{
			//НедопустимыеСимволы = """/\[]:;|=,?*<>";
			return null;
		}
		// Проверяет наличение недопустимых символов в имени файла
		//
		// Параметры
		//  ИмяФайла  - Строка
		// Возвращаемое значение:
		//   Массив   - массив обнаруженных в имени файла недопустимых символов.
		//              Если недопустимых символов не обнаружено возвращается пустой массив.

		public object НайтиНедопустимыеСимволыВИмениФайла(/*ИмяФайла*/)
		{
			//НедопустимыеСимволы = ПолучитьНедопустимыеСимволыВИмениФайла();
			//МассивНайденныхНедопустимыхСимволов = Новый Массив;
			return null;
		}
		// Заменяет недопустимые символы в имени файла
		//
		// Параметры
		//  ИмяФайла     - Строка - исходное имя файла.
		//  НаЧтоМенять  - Строка - строка на которые неоходимо заменить недопустимые символы.
		//
		// Возвращаемое значение:
		//   Строка   - имя файла в котором недопустимые символы заменены.
		//

		public object ЗаменитьНедопустимыеСимволыВИмениФайла(/*ИмяФайла, НаЧтоМенять = " "*/)
		{
			//МассивНайденныхНедопустимыхСимволов = НайтиНедопустимыеСимволыВИмениФайла(ИмяФайла);
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// Блок функций для работы с почтовыми адресами
		//
		// Функция проверяет что введенная строка с e-mail адресами введена правильно
		//
		// Формат строки:
		// Z = ИмяПользователя|[Имя Пользователя] [<]пользователь@почтовый_сервер[>], Строка = Z[<разделитель*>Z]..
		//
		//   прим.: разделитель* - имеется в виду любой разделитель адресов
		//
		// Параметры:
		// СтрокаПереданныхАдресов - строка - правильная строка с почтовыми адресами
		//
		// Возвращаемое значение:
		// Структура
		// ключ Статус - булево - успех или неуспех преобразования
		// в случае успеха содержит ключ Значение:
		//           Массив структур, где
		//                  Адрес- e-mail получателя
		//                  Представление   - имя получателя
		// в случае неуспеха содержит ключ СообщениеОбОшибке - строка
		//
		//  ВАЖНО: Функция возвращает массив структур, в которых одно поле (любое)
		//         может быть незаполнено. Может использоваться различными
		//         подсистемами для собственного сопоставления имени пользователя
		//         некому e-mail адресу. Поэтому, необходимо перед непосредственной
		//         отправкой проверить, что поле почтового адреса заполнено.
		//

		public object РазобратьСтрокуСПочтовымиАдресами(/*знач СтрокаПереданныхАдресов*/)
		{
			//Результат = Новый Массив;
			//НедопустимыеСимволы = "!#$%^&*()+`~|\/=";
			//СообщениеНедопустимыеСимволы = НСтр("ru = 'Недопустимый символ %1 в адресе электронной почты %2'");
			//СообщениеНеверныйФорматПочтовогоАдреса = НСтр("ru = 'Некорректный адрес электронной почты %1'");
			//МассивПодстрок = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрокаПереданныхАдресов,";", Истина);
			//МассивПодстрокКОбработке = Новый Массив;
			return null;
		}
		// Проверяет, что почтовый адрес не содержит символов обрамления
		// если символы обрамления вставлены правильно убирает их
		// Параметры:
		//  ПолноеИмяАдресата - строка - имя получателя
		//  ПочтовыйАдрес     - строка - email адрес
		// Возвращаемое значение:
		//  Структура:
		//   Ключ статус - булево - успех или неуспех операции
		//   СообщениеОбОшибке - в случае неуспеха операции содержит сообщение об ошибке
		//   Значение - структура - в случае успеха операции содержит записанную структуру почтового
		//                          адреса: ключи - Адрес, Представление (строки)
		//

		public object ПроверитьИПодготовитьПочтовыйАдрес(/*знач ПолноеИмяАдресата, знач ПочтовыйАдрес*/)
		{
			//НедопустимыйСимволВИмениАдресата = НСтр("ru = 'Недопустимый символ в имени адресата.'");
			//НедопустимыйСимволВПочтовомАдресе = НСтр("ru = 'Недопустимый символ в почтовом адресе.'");
			//СимволыОбрамления = "<>[]";
			//ПочтовыйАдрес     = СокрЛП(ПочтовыйАдрес);
			//ПолноеИмяАдресата = СокрЛП(ПолноеИмяАдресата);
			if(true/*Лев(ПолноеИмяАдресата, 1) = "<"*/)
			{
				if(true/*Прав(ПолноеИмяАдресата, 1) = ">"*/)
				{
					//ПолноеИмяАдресата = Сред(ПолноеИмяАдресата, 2, СтрДлина(ПолноеИмяАдресата)-2);
				}
			}
			if(true/*Лев(ПочтовыйАдрес, 1) = "<"*/)
			{
				if(true/*Прав(ПочтовыйАдрес, 1) = ">"*/)
				{
					//ПочтовыйАдрес = Сред(ПочтовыйАдрес, 2, СтрДлина(ПочтовыйАдрес)-2);
				}
			}
			return null;
		}
		// Разбирает строку с адресами электронной почты согласно стандарту RFC 5322 с ограничениями.
		//
		// Ограничения:
		//  1. В адресе разрешаются только буквы, цифры, символ подчеркивания, дефис и символ "@".
		//  2. Символы скобок "<>[]()" допускаются, но игнорируются путём замены на пробелы.
		//  3. Группы запрещены.
		//
		// Параметры:
		//  Строка - Строка - Строка, содержащая электронные адреса (mailbox-list).
		//
		// Возвращаемое значение:
		//  Массив - содержит массив структур адресов.
		//           Поля структуры:
		//             Псевдоним      - Строка - представление адресата.
		//             Адрес          - Строка - найденный и соответствующий требованиям почтовый адрес;
		//                                       Если текст, похожий на адрес найден, но не соответствует требованиям
		//                                       стандартов, то такой текст записывается в поле "Псевдоним".
		//             ОписаниеОшибки - Строка - текстовое представление ошибки, либо пустая строка, если ошибок нет.

		public object АдресаЭлектроннойПочтыИзСтроки(/*Знач Строка*/)
		{
			//Результат = Новый Массив;
			/*// заменяем скобки на пробелы
*/
			//СимволыСкобок = "<>()[]";
			//Строка = ЗаменитьСимволыВСтрокеНаПробелы(Строка, СимволыСкобок);
			/*// приводим разделители к одному виду
*/
			//Строка = СтрЗаменить(Строка, ",", ";");
			/*// раскладываем mailbox-list на mailbox'ы
*/
			//МассивАдресов = РазложитьСтрокуНаМассивПодстрок(Строка);
			/*// допустимые символы для псевдонима (display-name)
*/
			//Буквы = "abcdefghijklmnopqrstuvwxyzабвгдеёжзийклмнопрстуфхцчшщъыьэюя";
			//Цифры = "0123456789";
			//ДополнительныеСимволы = "._- ";
			/*// выделяем из строки адреса (mailbox'а) псевдоним (display-name) и адрес (addr-spec)
*/
			return null;
		}

		public object ЗаменитьСимволыВСтрокеНаПробелы(/*Строка, ЗаменяемыеСимволы*/)
		{
			//Результат = Строка;
			return null;
		}

		public object РазложитьСтрокуНаМассивПодстрок(/*Знач Строка, Разделитель = ";", ПропускатьПустыеСтроки = Истина*/)
		{
			//Результат = Новый Массив;
			//Позиция = Найти(Строка, Разделитель);
			while(true/*Позиция > 0*/)
			{
				//Подстрока = Лев(Строка, Позиция - 1);
				if(true/*Не ПустаяСтрока(Подстрока) или не ПропускатьПустыеСтроки*/)
				{
					//Результат.Добавить(Подстрока);
				}
				//Строка = Сред(Строка, Позиция + СтрДлина(Разделитель));
				//Позиция = Найти(Строка, Разделитель);
			}
			/*;
	
	Результат.Добавить(Строка);*/
			return null;
		}
		// Проверяет email адрес на соответствие требованиям стандартов RFC 5321, RFC 5322,
		// а также RFC 5335, RFC 5336 и RFC 3696.
		// Кроме того, функция ограничивает использование спецсимволов.
		//
		// Параметры:
		//  Адрес - Строка - проверяемый email.
		//
		// Возвращаемое значение:
		//  Булево - Истина, если ошибок нет.
		//

		public object АдресЭлектроннойПочтыСоответствуетТребованиям(/*Знач Адрес*/)
		{
			/*// допустимые символы для email
*/
			//Буквы = "abcdefghijklmnopqrstuvwxyzабвгдеёжзийклмнопрстуфхцчшщъыьэюя";
			//Цифры = "0123456789";
			//СпецСимволы = ".@_-";
			/*// проверяем любые сочетания спецсимволов
*/
			if(true/*СтрДлина(СпецСимволы) > 1*/)
			{
			}
			/*// проверяем символ @
*/
			if(true/*СтрЧислоВхождений(Адрес, "@") <> 1*/)
			{
			}
			/*// проверяем две точки подряд
*/
			if(true/*Найти(Адрес, "..") > 0*/)
			{
			}
			/*// приводим строку адреса к нижнему регистру
*/
			//Адрес = НРег(Адрес);
			/*// проверяем допустимые символы
*/
			if(true/*Не СтрокаСодержитТолькоДопустимыеСимволы(Адрес, Буквы + Цифры + СпецСимволы)*/)
			{
			}
			/*// разбираем адрес на local-part и domain
*/
			//Позиция = Найти(Адрес,"@");
			//ЛокальноеИмя = Лев(Адрес, Позиция - 1);
			//Домен = Сред(Адрес, Позиция + 1);
			/*// проверяем на заполненность и допустимость длины
*/
			if(true/*ПустаяСтрока(ЛокальноеИмя)
	 	или ПустаяСтрока(Домен)
		или СтрДлина(ЛокальноеИмя) > 64
		или СтрДлина(Домен) > 255*/)
			{
			}
			/*// проверяем наличие спецсимволов в начале и в конце частей адреса
*/
			if(true/*ЕстьСимволыВНачалеВКонце(ЛокальноеИмя, СпецСимволы) или ЕстьСимволыВНачалеВКонце(Домен, СпецСимволы)*/)
			{
			}
			/*// в домене должна быть минимум одна точка
*/
			if(true/*Найти(Домен,".") = 0*/)
			{
			}
			/*// в домене не должно быть символа подчеркивания
*/
			if(true/*Найти(Домен,"_") > 0*/)
			{
			}
			/*// выделяем зону (TLD) из имени домена 
*/
			//Зона = Домен;
			//Позиция = Найти(Зона,".");
			while(true/*Позиция > 0*/)
			{
				//Зона = Сред(Зона, Позиция + 1);
				//Позиция = Найти(Зона,".");
			}
			/*// проверяем зону домена (минимум 2 символа, только буквы)
*/
			//Возврат СтрДлина(Зона) >= 2 и СтрокаСодержитТолькоДопустимыеСимволы(Зона,Буквы);
			return null;
		}

		public object ЕстьСимволыВНачалеВКонце(/*Строка, ПроверяемыеСимволы*/)
		{
			return null;
		}

		public object СтрокаСодержитТолькоДопустимыеСимволы(/*Строка, ДопустимыеСимволы*/)
		{
			//МассивСимволов = Новый Массив;
			return null;
		}
		// Формирует структуру с ключами Статус (Истина) и Значение
		//

		public object ЗаполнитьРезультат(/*знач Значение, знач Статус = Истина*/)
		{
			if(true/*Статус*/)
			{
			}
			return null;
		}
		// Сдвигает маркер позиции пока встречается символ Символ
		// возвращает номер позиции в строке, на которое установился маркер
		//

		public object ПропуститьПробелы(/*знач Строка,
                          знач ТекущийИндекс,
                          знач ПропускаемыйСимвол*/)
		{
			//Результат = ТекущийИндекс;
			/*// убираем лишние пробелы если они есть
*/
			while(true/*ТекущийИндекс < СтрДлина(Строка)*/)
			{
				if(true/*Сред(Строка, ТекущийИндекс, 1) <> ПропускаемыйСимвол*/)
				{
				}
				//ТекущийИндекс = ТекущийИндекс + 1;
			}
			return null;
		}
		// Возвращает полный путь к новому каталогу в каталоге временных файлов.
		//
		// Параметры:
		//  Идентификатор - Строка, начальная часть имени каталога во временном каталоге.
		//
		// Возвращаемое значение:
		//  Строка - полное имя временного каталога, например "КаталогВременныхФайлов() + Обработка123\".
		//

		public object ПолучитьИмяКаталога(/*знач Идентификатор*/)
		{
			//Индекс = 0;
			while(true/*Истина*/)
			{
				//ПутьККаталогу = КаталогВременныхФайлов () + Идентификатор + строка(Индекс) + "/";
				//КаталогНаДиске = Новый Файл(ПутьККаталогу);
				if(true/*НЕ КаталогНаДиске.Существует()*/)
				{
					//СоздатьКаталог(ПутьККаталогу);
				}
				//Индекс = Индекс + 1;
			}
			//;;
			return null;
		}
		// ПолучитьИмяКаталога()
		////////////////////////////////////////////////////////////////////////////////
		// Функции для работы с отборами динамических списков
		//
		// Поиск элементов и групп отбора динамического списка
		// Параметры:
		//  ОбластьПоиска - контейнер с элементами и группами отбора, например
		//                  Список.Отбор или группа в отборе
		//  ИмяПоля - имя поля компоновки (не используется для групп)
		//  Представление - представление поля компоновки
		//  Примечание: поиск может осуществляться или по ЛевомуЗначению, или по Представлению
		//

		public object НайтиЭлементыИГруппыОтбора(/*знач ОбластьПоиска,
									знач ИмяПоля = Неопределено,
									знач Представление = Неопределено*/)
		{
			if(true/*ЗначениеЗаполнено(ИмяПоля)*/)
			{
				//ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
				//СпособПоиска = 1;
			}
			//МассивЭлементов = Новый Массив;
			//НайтиРекурсивно(ОбластьПоиска.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
			return null;
		}
		// Добавление группы отбора
		// Параметры:
		//  КоллекцияЭлементов - контейнер с элементами и группами отбора, например
		//                      Список.Отбор.Элементы или группа в отборе
		//  ТипГруппы - ТипГруппыЭлементовОтбораКомпоновкиДанных - тип группы
		//  Представление строка - представление группы
		//

		public object СоздатьГруппуЭлементовОтбора(/*КоллекцияЭлементов, Представление, ТипГруппы*/)
		{
			//ГруппаЭлементовОтбора = НайтиЭлементОтбораПоПредставлению(КоллекцияЭлементов, Представление);
			if(true/*ГруппаЭлементовОтбора = Неопределено*/)
			{
				//ГруппаЭлементовОтбора = КоллекцияЭлементов.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
			}
			//ГруппаЭлементовОтбора.Представление    = Представление;
			//ГруппаЭлементовОтбора.Применение       = ТипПримененияОтбораКомпоновкиДанных.Элементы;
			//ГруппаЭлементовОтбора.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
			//ГруппаЭлементовОтбора.ТипГруппы        = ТипГруппы;
			//ГруппаЭлементовОтбора.Использование    = Истина;
			return null;
		}
		// Добавление элемента компоновки в контейнер элементов компоновки
		// Параметры:
		//  ОбластьДобавления - контейнер с элементами и группами отбора, например
		//                  Список.Отбор или группа в отборе
		//  ИмяПоля - строка - имя для поля компоновки данных
		//  ВидСравнения - ВидСравненияКомпоновкиДанных - вид сравнения
		//  ПравоеЗначение - произвольный
		//  Представление - представление элемента компоновки данных
		//  Использование - булево - использование элемента
		//  РежимОтображения - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения
		//

		public object ДобавитьЭлементКомпоновки(/*ОбластьДобавления,
									знач ИмяПоля,
									знач ВидСравнения,
									знач ПравоеЗначение = Неопределено,
									знач Представление  = Неопределено,
									знач Использование  = Неопределено,
									знач РежимОтображения = Неопределено*/)
		{
			//Элемент = ОбластьДобавления.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
			//Элемент.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПоля);
			//Элемент.ВидСравнения = ВидСравнения;
			if(true/*РежимОтображения = Неопределено*/)
			{
				//Элемент.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
			}
			if(true/*ПравоеЗначение <> Неопределено*/)
			{
				//Элемент.ПравоеЗначение = ПравоеЗначение;
			}
			if(true/*Представление <> Неопределено*/)
			{
				//Элемент.Представление = Представление;
			}
			if(true/*Использование <> Неопределено*/)
			{
				//Элемент.Использование = Использование;
			}
			return null;
		}
		// Изменение элементов отбора
		// Параметры
		//  ИмяПоля - строка - имя поля компоновки
		//  ВидСравнения - ВидСравненияКомпоновкиДанных - вид сравнения
		//  ПравоеЗначение - произвольный
		//  Представление - строка - представление элемента компоновки данных
		//  Использование - булево - использование элемента
		//  РежимОтображения - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения
		//

		public object ИзменитьЭлементыОтбора(/*ОбластьПоиска,
								знач ИмяПоля = Неопределено,
								знач Представление = Неопределено,
								знач ПравоеЗначение = Неопределено,
								знач ВидСравнения = Неопределено,
								знач Использование = Неопределено,
								знач РежимОтображения = Неопределено*/)
		{
			if(true/*ЗначениеЗаполнено(ИмяПоля)*/)
			{
				//ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
				//СпособПоиска = 1;
			}
			//МассивЭлементов = Новый Массив;
			//НайтиРекурсивно(ОбластьПоиска.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
			return null;
		}
		// Поиск элементов и групп отбора динамического списка
		// Параметры:
		//  ОбластьУдаления - контейнер с элементами и группами отбора, например
		//                  Список.Отбор или группа в отборе
		//  ИмяПоля - имя поля компоновки (не используется для групп)
		//  Представление - представление поля компоновки
		//  Примечание: поиск может осуществляться или по ЛевомуЗначению, или по Представлению
		//

		public void УдалитьЭлементыГруппыОтбора(/*знач ОбластьУдаления,
										знач ИмяПоля = Неопределено,
										знач Представление = Неопределено*/)
		{
			if(true/*ЗначениеЗаполнено(ИмяПоля)*/)
			{
				//ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
				//СпособПоиска = 1;
			}
			//МассивЭлементов = Новый Массив;
			//НайтиРекурсивно(ОбластьУдаления.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
		}
		// Используется для создания элемента отбора или, если таковой не найден,
		// установления существующим элементам свойств
		// Параметры
		//  ОбластьПоискаДобавления - контейнер с элементами и группами отбора, например
		//                  Список.Отбор или группа в отборе
		//  ИмяПоля - строка - имя для поля компоновки данных (заполняется всегда)
		// Устанавливаемые поля:
		//  ВидСравнения - ВидСравненияКомпоновкиДанных - вид сравнения
		//  ПравоеЗначение - произвольный
		//  Представление - представление элемента компоновки данных
		//  Использование - булево - использование элемента
		//  РежимОтображения - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения
		//

		public void УстановитьЭлементОтбора(/*ОбластьПоискаДобавления,
								знач ИмяПоля,
								знач ПравоеЗначение = Неопределено,
								знач ВидСравнения = Неопределено,
								знач Представление = Неопределено,
								знач Использование = Неопределено,
								знач РежимОтображения = Неопределено*/)
		{
			/*ЧислоИзмененных = ИзменитьЭлементыОтбора(ОбластьПоискаДобавления, ИмяПоля, Представление,
							ПравоеЗначение, ВидСравнения, Использование, РежимОтображения);*/
			if(true/*ЧислоИзмененных = 0*/)
			{
				if(true/*ВидСравнения = Неопределено*/)
				{
					//ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
				}
				/*ДобавитьЭлементКомпоновки(ОбластьПоискаДобавления, ИмяПоля, ВидСравнения,
								ПравоеЗначение, Представление, Использование, РежимОтображения);*/
			}
		}
		// Устанавливает значение Значение параметра ИмяПараметра динамического списка Список
		// или отключает его использование в зависимости от признака Использование.
		//

		public void УстановитьПараметрДинамическогоСписка(/*Список, ИмяПараметра, Значение, Использование = Истина*/)
		{
			if(true/*Использование*/)
			{
				//Список.Параметры.УстановитьЗначениеПараметра(ИмяПараметра, Значение);
			}
		}
		////////////////////////////////////////////////////////////////////////////////
		// Функции для работы с управляемыми формами
		//
		// Получает значение реквизита формы
		// Параметры:
		//		Форма
		//		ПутьРеквизита - строка, путь к данным, например: "Объект.МесяцНачисления"

		public object ПолучитьРеквизитФормыПоПути(/*Форма, ПутьРеквизита*/)
		{
			//МассивИмен = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПутьРеквизита, ".");
			//Объект        = Форма;
			//ПоследнееПоле = МассивИмен[МассивИмен.Количество()-1];
			return null;
		}
		// Устанавливает значение реквизиту формы
		// Параметры:
		//		Форма
		//		ПутьРеквизита - строка, путь к данным, например: "Объект.МесяцНачисления"
		//		Значение

		public void УстановитьРеквизитФормыПоПути(/*Форма, ПутьРеквизита, Значение, ТолькоЕслиНеЗаполнен = Ложь*/)
		{
			//МассивИмен = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПутьРеквизита, ".");
			//Объект        = Форма;
			//ПоследнееПоле = МассивИмен[МассивИмен.Количество()-1];
			if(true/*НЕ ТолькоЕслиНеЗаполнен ИЛИ НЕ ЗначениеЗаполнено(Объект[ПоследнееПоле])*/)
			{
				//Объект[ПоследнееПоле] = Значение;
			}
		}
		// Выполняет поиск элемента отбора в коллекции по заданному представлению
		//
		// Параметры:
		//  КоллекцияЭлементов - контейнер с элементами и группами отбора, например
		//                      Список.Отбор.Элементы или группа в отборе
		//  Представление строка - представление группы
		//

		public object НайтиЭлементОтбораПоПредставлению(/*КоллекцияЭлементов, Представление*/)
		{
			//ВозвращаемоеЗначение = Неопределено;
			return null;
		}
		// Устанавливает свойство ИмяСвойства элемента формы с именем ИмяЭлемента в значение Значение.
		// Применяется в тех случаях, когда элемент формы может не быть на форме из-за отсутствия прав у пользователя
		// на объект, реквизит объекта или команду.
		//
		// Параметры:
		//  ЭлементыФормы - свойство ЭлементыФормы управляемой формы.
		//  ИмяЭлемента   - Строка       - имя элемента формы
		//  ИмяСвойства   - Строка       - имя устанавливаемого свойства элемента формы
		//  Значение      - Произвольный - новое значение элемента
		//

		public void УстановитьСвойствоЭлементаФормы(/*ЭлементыФормы, ИмяЭлемента, ИмяСвойства, Значение*/)
		{
			//ЭлементФормы = ЭлементыФормы.Найти(ИмяЭлемента);
			if(true/*ЭлементФормы <> Неопределено*/)
			{
				//ЭлементФормы[ИмяСвойства] = Значение;
			}
		}
		// Возвращает значение свойства ИмяСвойства элемента формы с именем ИмяЭлемента.
		// Применяется в тех случаях, когда элемент формы может не быть на форме из-за отсутствия прав у пользователя
		// на объект, реквизит объекта или команду.
		//
		// Параметры:
		//  ЭлементыФормы - свойство ЭлементыФормы управляемой формы.
		//  ИмяЭлемента   - Строка       - имя элемента формы
		//  ИмяСвойства   - Строка       - имя свойства элемента формы
		//
		// Возвращаемое значение:
		//   Произвольный - значение свойства ИмяСвойства элемента формы ИмяЭлемента.
		//

		public object ЗначениеСвойстваЭлементаФормы(/*ЭлементыФормы, ИмяЭлемента, ИмяСвойства*/)
		{
			//ЭлементФормы = ЭлементыФормы.Найти(ИмяЭлемента);
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// Служебные и вспомогательные функции
		//

		public void НайтиРекурсивно(/*КоллекцияЭлементов, МассивЭлементов, СпособПоиска, ЗначениеПоиска*/)
		{
		}
		// добавляет в конце "\" или "/"

		public void ДобавитьСлешЕслиНужно(/*НовыйПуть, ТипПлатформыТекущий*/)
		{
			if(true/*СтрДлина(НовыйПуть) = 0*/)
			{
			}
			if(true/*Прав(НовыйПуть, 1) <> "\" И Прав(НовыйПуть,1) <> "/"*/)
			{
				if(true/*ТипПлатформыТекущий = ТипПлатформы.Windows_x86 ИЛИ ТипПлатформыТекущий = ТипПлатформы.Windows_x86_64*/)
				{
					//НовыйПуть = НовыйПуть + "\";
				}
			}
		}
		// Получает представление сообщения ошибке на основании Информации об ошибке
		// Может вызываться в операторных скобках Попытка ... Исключение ... КонецПопытки;
		// для получения сообщения об ошибке.
		//

		public object ПолучитьПредставлениеОписанияОшибки(/*ИнформацияОбОшибке*/)
		{
			//Возврат ? (ИнформацияОбОшибке.Причина = Неопределено, ИнформацияОбОшибке.Описание, ИнформацияОбОшибке.Причина.Описание);
			return null;
		}
		// Копирует элементы из одной коллекции в другую
		//

		public void СкопироватьЭлементы(/*ПриемникЗначения, ИсточникЗначения, ПроверятьДоступность = Ложь, ОчищатьПриемник = Истина*/)
		{
			if(true/*ТипЗнч(ИсточникЗначения) = Тип("УсловноеОформлениеКомпоновкиДанных")
		ИЛИ ТипЗнч(ИсточникЗначения) = Тип("ВариантыПользовательскогоПоляВыборКомпоновкиДанных")
		ИЛИ ТипЗнч(ИсточникЗначения) = Тип("ОформляемыеПоляКомпоновкиДанных")
		ИЛИ ТипЗнч(ИсточникЗначения) = Тип("ЗначенияПараметровДанныхКомпоновкиДанных")*/)
			{
				//СоздаватьПоТипу = Ложь;
			}
			//ПриемникЭлементов = ПриемникЗначения.Элементы;
			//ИсточникЭлементов = ИсточникЗначения.Элементы;
			if(true/*ОчищатьПриемник*/)
			{
				//ПриемникЭлементов.Очистить();
			}
		}

		public void ЗаполнитьЭлементы(/*ПриемникЗначения, ИсточникЗначения, ПервыйУровень = Неопределено*/)
		{
			if(true/*ТипЗнч(ПриемникЗначения) = Тип("КоллекцияЗначенийПараметровКомпоновкиДанных")*/)
			{
				//КоллекцияЗначений = ИсточникЗначения;
			}
		}
		// Функция выполняет получение имени поля из доступных полей компоновки данных.
		//

		public object ПолучитьИмяПоляВШаблоне(/*Знач ИмяПоля*/)
		{
			//ИмяПоля = СтрЗаменить(ИмяПоля, ".DeletionMark", ".ПометкаУдаления");
			//ИмяПоля = СтрЗаменить(ИмяПоля, ".Owner", ".Владелец");
			//ИмяПоля = СтрЗаменить(ИмяПоля, ".Code", ".Код");
			//ИмяПоля = СтрЗаменить(ИмяПоля, ".Parent", ".Родитель");
			//ИмяПоля = СтрЗаменить(ИмяПоля, ".Predefined", ".Предопределенный");
			//ИмяПоля = СтрЗаменить(ИмяПоля, ".IsFolder", ".ЭтоГруппа");
			//ИмяПоля = СтрЗаменить(ИмяПоля, ".Description", ".Наименование");
			return null;
		}
		// ПолучитьИмяПоляВШаблоне()
		////////////////////////////////////////////////////////////////////////////////
		// Клиентские и серверные процедуры общего назначения
		// Функция формирует текст в формате, необходимом для выдачи сообщений по табличной части.
		//
		// Параметры:
		//  ИмяТЧ - Строка. Имя табличной части.
		//  НомерСтроки - Число. Номер строки табличной части.
		//  ИмяРеквизита - Строка. Имя реквизита.
		//
		// Возвращаемое значение:
		//  Строка.
		//

		public object ПолучитьТекстДляВыдачиСообщенийПоСтрокеТЧ(/*ИмяТЧ, НомерСтроки, ИмяРеквизита*/)
		{
			//Возврат ИмяТЧ + "[" + Формат(НомерСтроки - 1, "ЧН=0; ЧГ=0") + "]." + ИмяРеквизита;
			return null;
		}
		// ПолучитьТекстДляВыдачиСообщенийПоСтрокеТЧ()
		//Процедуры подготовки исходных данных при проведении документов
		// Обрабатывает таблицу значений: заполняет незаполненные колонки с НоменклатурнойГруппой и СтатьейЗатрат по данным других реквизитов
		// Параметры:
		// 	ТаблицаДокумента - обрабатываемая таблица значений
		// 	СтруктураОбрабатываемыхКолонок - Структура, содержит обрабатываемые колонки
		// 		Ключ - имя колонки которую необходимо заполнить
		// 		Значение - имя колонки являющейся источником для заполнения
		// 	СтруктураЗависимыхКолонок - Структура - содержит сведения о колонках, необходимость заполнения которых зависит от заполнения других колонок
		// 		Ключ - имя зависимой колонки
		// 		Значение - имя колонки, от заполнения которой зависит нужно ли заполнять зависимую колонку
		//

		public void ЗаполнитьНоменклатурнуюГруппуИСтатьюЗатратВТаблицеДокумента(/*ТаблицаДокумента, СтруктураОбрабатываемыхКолонок, СтруктураЗависимыхКолонок = Неопределено*/)
		{
			if(true/*СтруктураЗависимыхКолонок = Неопределено*/)
			{
				//СтруктураЗависимыхКолонок = Новый Структура();
			}
		}
		//Процедура добавляет в СтруктуруШапкиДокумента сведения о счетах расчетов по умолчанию, если эти данные не заполнились из шапки документа

		public void ДобавитьВСтруктуруШапкиСведенияОСчетахРасчетов(/*ДокументОбъект, СтруктураШапкиДокумента*/)
		{
			if(true/*НЕ СтруктураШапкиДокумента.ОтражатьВБухгалтерскомУчете*/)
			{
			}
			/*//Получим структуру счетов учета расчетов: 
*/
			/*//	ключ - имя реквизита шапки, значение - счет учета расчетов по умолчанию
*/
			//СтруктураСчетовУчетаРасчетов = ДокументОбъект.ЗаполнитьСтруктуруСчетовУчетаШапки();
			/*//Заполним недостающие свойства в структуре шапки документа 
*/
		}
		//Процедура добавляет в СтруктуруШапкиДокумента сведения о подразделении организации,
		//Если в шапке документа «Подразделение организации» оказалось незаполненным, то соответствующее свойство структуры заполняется вычисленным по подразделению
		//Если Подразделение организации не удалось определить по подразделению, то выдается ошибка

		public void ДополнитьСтруктуруШапкиПодразделениемОрганизации(/*Заголовок, СтруктураШапкиДокумента, Отказ*/)
		{
			if(true/*НЕ СтруктураШапкиДокумента.ОтражатьВБухгалтерскомУчете*/)
			{
			}
			if(true/*НЕ ЗначениеЗаполнено(СтруктураШапкиДокумента.ПодразделениеОрганизации)*/)
			{
				//СтруктураШапкиДокумента.ПодразделениеОрганизации = РаботаСДиалогамиСервер.ПодразделениеОрганизации(СтруктураШапкиДокумента.Подразделение, СтруктураШапкиДокумента.Организация);
			}
			if(true/*НЕ ЗначениеЗаполнено(СтруктураШапкиДокумента.ПодразделениеОрганизации)*/)
			{
				//ОбщегоНазначения.СообщитьОбОшибке(Нстр("ru = 'Не заполнено подразделение организации'"), Отказ, Заголовок);
			}
		}
		//ДополнитьСтруктуруШапкиПодразделениемОрганизации()
		//Процедура добавляет в ТаблицуДокумента сведения о подразделении организации,
		//Если в табличной части документа «Подразделение организации» оказалось незаполненным, то соответствующая колонка таблицы заполняется вычисленным значением по подразделению
		//Окончательная проверка заполненности подразделения организации выполняется в модуле документа

		public void ДополнитьТаблицуДокументаПодразделениемОрганизации(/*СтруктураШапкиДокумента, ТаблицаДокумента*/)
		{
			if(true/*НЕ СтруктураШапкиДокумента.ОтражатьВБухгалтерскомУчете*/)
			{
			}
			if(true/*ТаблицаДокумента.Колонки.Найти("Подразделение") <> Неопределено*/)
			{
				//ИмяКолонкиПодразделение = "Подразделение";
				//ИмяКолонкиПодразделениеОрганизации = "ПодразделениеОрганизации";
			}
		}
		// Проверяет правильность заполнения шапки документа по структуре шапки документа.
		// Если какой-то из реквизитов шапки, влияющий на проведение, не заполнен или
		// заполнен не корректно, то выставляется флаг отказа в проведении.
		// Проверяется также правильность заполнения реквизитов ссылочных полей документа.
		// Проверка выполняется по объекту и по выборке из результата запроса по шапке.
		//
		// Параметры:
		//  ДокументОбъект             - объект проводимого документа,
		//  СтруктураОбязательныхПолей - структура, содержащая имена полей, которые собственно и надо проверить.
		//  СтруктураШапкиДокумента    - структура шапки проводимого документа
		//  Отказ                      - флаг отказа в проведении.
		//  Заголовок                  - строка, заголовок сообщения об ошибке проведения.
		//

		public void ПроверитьЗаполнениеВычисляемыхРеквизитовШапки(/*ДокументОбъект, СтруктураОбязательныхПолей, СтруктураШапкиДокумента, Отказ, Заголовок*/)
		{
			//МетаданныеРеквизиты = ДокументОбъект.Метаданные().Реквизиты;
		}
	}
}
