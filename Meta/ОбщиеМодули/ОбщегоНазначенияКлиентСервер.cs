using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace V82.ОбщиеМодули
{
	public partial class ОбщегоНазначенияКлиентСервер
	{
		////////////////////////////////////////////////////////////////////////////////
		// Клиентские и серверные процедуры общего назначения
		// Формирует и выводит сообщение, которое может быть связано с элементом
		// управления формы.
		//
		//  Параметры
		//  ТекстСообщенияПользователю - Строка - текст сообщения.
		//  КлючДанных                - Любая ссылка на объект информационной базы.
		//                               Ссылка на объект информационной базы, к которому это сообщение относится,
		//                               или ключ записи.
		//  Поле                       - Строка - наименование реквизита формы
		//  ПутьКДанным                - Строка - путь к данным (путь к реквизиту формы)
		//  Отказ                      - Булево - Выходной параметр
		//                               Всегда устанавливается в значение Истина
		//
		//	Примеры использования:
		//
		//	1. Для вывода сообщения у поля управляемой формы, связанного с реквизитом объекта:
		//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
		//		НСтр("ru = 'Сообщение об ошибке.'"), ,
		//		"ПолеВРеквизитеФормыОбъект",
		//		"Объект");
		//
		//	Альтернативный вариант использования в форме объекта:
		//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
		//		НСтр("ru = 'Сообщение об ошибке.'"), ,
		//		"Объект.ПолеВРеквизитеФормыОбъект");
		//
		//	2. Для вывода сообщения рядом с полем управляемой формы, связанным с реквизитом формы:
		//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
		//		НСтр("ru = 'Сообщение об ошибке.'"), ,
		//		"ИмяРеквизитаФормы");
		//
		//	3. Для вывода сообщения связанного с объектом информационной базы
		//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
		//		НСтр("ru = 'Сообщение об ошибке.'"), ОбъектИнформационнойБазы, "Ответственный",,Отказ);
		//
		// 4. Для вывода сообщения по ссылке на объект информационной базы
		//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
		//		НСтр("ru = 'Сообщение об ошибке.'"), Ссылка, , , Отказ);
		//
		// Случаи некорректного использования:
		//  1. Передача одновременно параметров КлючДанных и ПутьКДанным
		//  2. Передача в параметре КлючДанных значения типа отличного от допустимых
		//  3. Установка ссылки без установки поля (и/или пути к данным)
		//

		public void СообщитьПользователю(/*
		Знач ТекстСообщенияПользователю,
		Знач КлючДанных = Неопределено,
		Знач Поле = "",
		Знач ПутьКДанным = "",
		Отказ = Ложь*/)
		{
			/*Сообщение = Новый СообщениеПользователю;*/
			/*Сообщение.Текст = ТекстСообщенияПользователю;*/
			/*Сообщение.Поле = Поле;*/
			/*ЭтоОбъект = Ложь;*/
			if(true/*КлючДанных <> Неопределено
	   И XMLТипЗнч(КлючДанных) <> Неопределено*/)
			{
				/*ТипЗначенияСтрокой = XMLТипЗнч(КлючДанных).ИмяТипа;*/
				/*ЭтоОбъект = Найти(ТипЗначенияСтрокой, "Object.") > 0;*/
			}
			if(true/*ЭтоОбъект*/)
			{
				/*Сообщение.УстановитьДанные(КлючДанных);*/
			}
			if(true/*НЕ ПустаяСтрока(ПутьКДанным)*/)
			{
				/*Сообщение.ПутьКДанным = ПутьКДанным;*/
			}
			/*Сообщение.Сообщить();*/
			/*Отказ = Истина;*/
		}
		// Формирует текст сообщения, подставляя значения
		// параметров в шаблоны сообщений.
		//
		// Параметры
		//  ВидПоля       - Строка - может принимать значения:
		//                  Поле, Колонка, Список
		//  ВидСообщения  - Строка - может принимать значения:
		//                  Заполнение, Корректность
		//  Параметр1     - Строка - имя поля
		//  Параметр2     - Строка - номер строки
		//  Параметр3     - Строка - имя списка
		//  Параметр4     - Строка - текст сообщения о некорректности заполнения
		//
		// Возвращаемое значение:
		//   Строка - текст сообщения
		//

		public object ПолучитьТекстСообщения(/*ВидПоля = "Поле", ВидСообщения = "Заполнение",
	Параметр1 = "", Параметр2 = "",	Параметр3 = "", Параметр4 = ""*/)
		{
			/*ТекстСообщения = "";*/
			if(true/*ВРег(ВидПоля) = "ПОЛЕ"*/)
			{
				if(true/*ВРег(ВидСообщения) = "ЗАПОЛНЕНИЕ"*/)
				{
					/*Шаблон = НСтр("ru = 'Поле ""%1"" не заполнено'");*/
				}
			}
			return null;
		}
		// Формирует путь к заданной строке НомерСтроки и колонке ИмяРеквизита
		// табличной части ИмяТабличнойЧасти для выдачи сообщений в форме.
		// Для совместного использования с процедурой СообщитьПользователю
		// (для передачи в параметры Поле или ПутьКДанным).
		//
		// Параметры:
		//  ИмяТабличнойЧасти - Строка - имя табличной части.
		//  НомерСтроки       - Число - номер строки табличной части.
		//  ИмяРеквизита      - Строка - имя реквизита.
		//
		// Возвращаемое значение:
		//  Строка.
		//

		public object ПутьКТабличнойЧасти(/*Знач ИмяТабличнойЧасти, Знач НомерСтроки, 
	Знач ИмяРеквизита*/)
		{
			return null;
		}
		// Дополняет таблицу значений-приемник данными из таблицы значений-источник
		//
		// Параметры:
		//  ТаблицаИсточник - Таблица значений - таблица из которой будут браться строки для заполнения
		//  ТаблицаПриемник - Таблица значений - таблица в которую будут добавлены строки из таблицы-источника
		//

		public void ДополнитьТаблицу(/*ТаблицаИсточник, ТаблицаПриемник*/)
		{
		}
		// Дополняет таблицу значений Таблица значениями из массива Массив.
		//
		// Параметры:
		//  Таблица - ТаблицаЗначений - таблица, которую необходимо заполнить значениями из массива
		//  Массив - Массив - массив значений для заполнения таблицы
		//  ИмяПоля - Строка - имя поля таблицы значений, в которое необходимо загрузить значения из массива
		//

		public void ДополнитьТаблицуИзМассива(/*Таблица, Массив, ИмяПоля*/)
		{
		}
		// Снимает один элемент условного оформления, если это список значений.
		// Параметры
		// УсловноеОформление - условное оформление элемента формы
		// ИдентификаторПользовательскойНастройки - строка - идентификатор настройки
		// Значение - значение, которое требуется удалить из списка оформления
		//

		public void СнятьУсловноеОформлениеСпискаЗначений(/*
						УсловноеОформление,
						знач ИдентификаторПользовательскойНастройки,
						знач Значение*/)
		{
		}
		// Удаляет одно значение из массива
		//
		// Параметры:
		//  Массив - массив, из которого необходимо удалить значение
		//  Значение - удаляемое значение из массива
		//

		public void УдалитьЗначениеИзМассива(/*Массив, Значение*/)
		{
			/*Индекс = Массив.Найти(Значение);*/
			if(true/*Индекс <> Неопределено*/)
			{
				/*Массив.Удалить(Индекс);*/
			}
		}
		// Удаляет все вхождения переданного значения из массива
		//
		// Параметры:
		//  Массив - массив, из которого необходимо удалить значение
		//  Значение - удаляемое значение из массива
		//

		public void УдалитьВсеВхожденияЗначенияИзМассива(/*Массив, Значение*/)
		{
			/*КолвоЭлементовКоллекции = Массив.Количество();*/
		}
		// Удаляет все вхождения значений указанного типа
		//
		// Параметры:
		//  Массив - массив, из которого необходимо удалить значения
		//  Тип – тип, значения которых следует удалить из коллекции
		//

		public void УдалитьВсеВхожденияТипаИзМассива(/*Массив, Тип*/)
		{
			/*КолвоЭлементовКоллекции = Массив.Количество();*/
		}
		// Заполняет коллекцию-приемник значениями из коллекции-источник
		// В качестве коллекций источника и приемника могут выступать типы:
		// ТаблицаЗначений; ДеревоЗначений; СписокЗначений и пр.
		//
		// Параметры:
		//  КоллекцияИсточник - коллекция значений, которая является источником для заполнения данных
		//  КоллекцияПриемник - коллекция значений, которая является приемником для заполнения данных
		//

		public void ЗаполнитьКоллекциюСвойств(/*КоллекцияИсточник, КоллекцияПриемник*/)
		{
		}
		// Получает массив значений из отмеченных элементов списка значений
		//
		// Параметры:
		//  Список - СписокЗначений - список значений из которого будет формироваться массив значений
		//
		// Возвращаемое значение:
		//  Массив - массив значений из отмеченных элементов списка значений
		//

		public object ПолучитьМассивОтмеченныхЭлементовСписка(/*Список*/)
		{
			/*// возвращаемое значение функции
*/
			/*Массив = Новый Массив;*/
			return null;
		}
		// Вычитает один массив элементов из другого массива. Возвращает результат вычитания.
		//
		// Параметры:
		//  Массив - массив элементов, из которого необходимо выполнить вычитание
		//  МассивВычитания - массив элементов, который будет вычитаться
		//
		//  Возвращаемое значение:
		//  Массив – результат вычитания двух массивов
		//

		public object СократитьМассив(/*Массив, МассивВычитания*/)
		{
			/*Результат = Новый Массив;*/
			return null;
		}
		// Преобразует РасписаниеРегламентногоЗадания в структуру.
		//
		// Параметры:
		//  Расписание - РасписаниеРегламентногоЗадания
		//
		// Возвращаемое значение:
		//  Структура
		//

		public object РасписаниеВСтруктуру(/*Знач Расписание*/)
		{
			/*ЗначениеРасписания = Расписание;*/
			if(true/*ЗначениеРасписания = Неопределено*/)
			{
				/*ЗначениеРасписания = Новый РасписаниеРегламентногоЗадания();*/
			}
			/*СписокПолей = "ВремяЗавершения,ВремяКонца,ВремяНачала,ДатаКонца,ДатаНачала,ДеньВМесяце,ДеньНеделиВМесяце," + 
		"ДниНедели,ИнтервалЗавершения,Месяцы,ПаузаПовтора,ПериодНедель,ПериодПовтораВТечениеДня,ПериодПовтораДней";*/
			/*Результат = Новый Структура(СписокПолей);*/
			/*ЗаполнитьЗначенияСвойств(Результат, ЗначениеРасписания, СписокПолей);*/
			/*ДетальныеРасписанияДня = Новый Массив;*/
			/*Результат.Вставить("ДетальныеРасписанияДня", ДетальныеРасписанияДня);*/
			return null;
		}
		// Преобразует структуру в РасписаниеРегламентногоЗадания.
		//
		// Параметры:
		//  СтруктураРасписания - Структура
		//
		// Возвращаемое значение:
		//  РасписаниеРегламентногоЗадания
		//

		public object СтруктураВРасписание(/*Знач СтруктураРасписания*/)
		{
			if(true/*СтруктураРасписания = Неопределено*/)
			{
			}
			/*СписокПолей = "ВремяЗавершения,ВремяКонца,ВремяНачала,ДатаКонца,ДатаНачала,ДеньВМесяце,ДеньНеделиВМесяце," + 
		"ДниНедели,ИнтервалЗавершения,Месяцы,ПаузаПовтора,ПериодНедель,ПериодПовтораВТечениеДня,ПериодПовтораДней";*/
			/*Результат = Новый РасписаниеРегламентногоЗадания;*/
			/*ЗаполнитьЗначенияСвойств(Результат, СтруктураРасписания, СписокПолей);*/
			/*ДетальныеРасписанияДня = Новый Массив;*/
			/*Результат.ДетальныеРасписанияДня = ДетальныеРасписанияДня;*/
			return null;
		}
		// Создает новый экземпляр объекта Структура, заполняет объект данными указанной структуры.
		//
		// Параметры:
		//  СтруктураИсточник – Структура – структура, копию которой необходимо получить
		//
		//  Возвращаемое значение:
		//  Тип: Структура.
		//

		public object СкопироватьСтруктуру(/*СтруктураИсточник*/)
		{
			/*СтруктураРезультат = Новый Структура;*/
			return null;
		}
		// Функция выполняет поиск элемента в коллекции: списке значений или массиве
		//

		public object НайтиВСписке(/*Список, Элемент*/)
		{
			if(true/*ТипЗнч(Список) = Тип("СписокЗначений")*/)
			{
				if(true/*ТипЗнч(Элемент) = Тип("ЭлементСпискаЗначений")*/)
				{
					/*ЭлементВСписке = Список.НайтиПоЗначению(Элемент.Значение);*/
				}
			}
			if(true/*ТипЗнч(Список) = Тип("Массив")*/)
			{
				/*ЭлементВСписке = Список.Найти(Элемент);*/
			}
			return null;
		}
		// ЭлементПрисутствуетВСписке
		// Сравнивает элементы списков значений или массивов по значениям
		//

		public object СпискиЗначенийИдентичны(/*Список1, Список2*/)
		{
			/*СпискиИдентичны = Истина;*/
			if(true/*СпискиИдентичны*/)
			{
			}
			return null;
		}
		// СпискиЗначенийИдентичны
		// Возвращает шаблон структуры параметров для установки внешнего соединения.
		// Параметрам необходимо задать требуемые значения и передать
		// в метод ОбщегоНазначения.УстановитьВнешнееСоединение()
		//

		public object СтруктураПараметровДляУстановкиВнешнегоСоединения(/**/)
		{
			/*СтруктураПараметров = Новый Структура;*/
			/*СтруктураПараметров.Вставить("ВариантРаботыИнформационнойБазы", 0);*/
			/*СтруктураПараметров.Вставить("КаталогИнформационнойБазы", "");*/
			/*СтруктураПараметров.Вставить("ИмяСервера1СПредприятия", "");*/
			/*СтруктураПараметров.Вставить("ИмяИнформационнойБазыНаСервере1СПредприятия", "");*/
			/*СтруктураПараметров.Вставить("АутентификацияОперационнойСистемы", Ложь);*/
			/*СтруктураПараметров.Вставить("ИмяПользователя", "");*/
			/*СтруктураПараметров.Вставить("ПарольПользователя", "");*/
			return null;
		}
		// Извлекает из строки соединения с информационной базой параметры подключения
		// и передает параметры в структуру для установки внешнего соединения.
		//

		public object ПолучитьПараметрыПодключенияИзСтрокиСоединенияИнформационнойБазы(/*Знач СтрокаСоединения*/)
		{
			/*Результат = СтруктураПараметровДляУстановкиВнешнегоСоединения();*/
			/*Параметры = СтроковыеФункцииКлиентСервер.ПолучитьПараметрыИзСтроки(СтрокаСоединения);*/
			/*Параметры.Свойство("File", Результат.КаталогИнформационнойБазы);*/
			/*Параметры.Свойство("Srvr", Результат.ИмяСервера1СПредприятия);*/
			/*Параметры.Свойство("Ref",  Результат.ИмяИнформационнойБазыНаСервере1СПредприятия);*/
			/*Результат.ВариантРаботыИнформационнойБазы = ?(Параметры.Свойство("File"), 0, 1);*/
			return null;
		}
		// Получает идентификатор (метод ПолучитьИдентификатор()) строки дерева значений для заданного значения поля строки дерева.
		// Используется для позиционирования курсора в иерархических списках.
		//

		public void ПолучитьИдентификаторСтрокиДереваПоЗначениюПоля(/*ИмяПоля, ИдентификаторСтроки, КоллекцияЭлементовДерева, КлючСтроки, ПрекратитьПоиск*/)
		{
		}
		// Заменяет недопустимые символы в XML-строке на заданные символы
		//
		// Параметры:
		//   Текст – Строка – строка, в которой требуется выполнить замену недопустимых символов.
		//   СимволЗамены – Строка – строка, на которую требуется выполнить замену недопустимого символа в XML-строке
		//
		//  Возвращаемое значение:
		//    Строка - cтрока, полученная заменой недопустимых символов в XML-строке.
		//

		public object ЗаменитьНедопустимыеСимволыXML(/*Знач Текст, СимволЗамены = " "*/)
		{
			/*#Если НЕ ВебКлиент Тогда
	ПозицияНачала = 1;*/
			while(true/*Истина*/)
			{
				/*Позиция = НайтиНедопустимыеСимволыXML(Текст, ПозицияНачала);*/
				if(true/*Позиция = 0*/)
				{
					/*Прервать;*/
				}
				/*// Если возращается позиция, больше чем должна быть, то корректируем ее.
*/
				if(true/*Позиция > 1*/)
				{
					/*НедопустимыйСимвол = Сред(Текст, Позиция - 1, 1);*/
					if(true/*НайтиНедопустимыеСимволыXML(НедопустимыйСимвол) > 0*/)
					{
						/*Текст = СтрЗаменить(Текст, НедопустимыйСимвол, СимволЗамены);*/
					}
				}
				/*НедопустимыйСимвол = Сред(Текст, Позиция, 1);*/
				if(true/*НайтиНедопустимыеСимволыXML(НедопустимыйСимвол) > 0*/)
				{
					/*Текст = СтрЗаменить(Текст, НедопустимыйСимвол, СимволЗамены);*/
				}
				/*ПозицияНачала = Позиция + 1;*/
			}
			/*;
#КонецЕсли

	Возврат Текст;*/
			return null;
		}
		// Удаляет недопустимые символы в XML-строке.
		//
		// Параметры:
		//  Текст – Строка – строка, в которой требуется удалить недопустимые символы.
		//
		//  Возвращаемое значение:
		//  Тип: Строка. Строка, полученная при удалении недопустимых символов в XML-строке.
		//

		public object УдалитьНедопустимыеСимволыXML(/*Знач Текст*/)
		{
			return null;
		}
		// Сравнивает расписания между собой.
		//
		// Параметры
		//	Расписание1, Расписание2 - РасписаниеРегламентногоЗадания
		//
		// Возвращаемое значение
		//  Булево - истина, если расписания идентичны, иначе ложь.

		public object РасписанияОдинаковые(/*Знач Расписание1, Знач Расписание2*/)
		{
			/*Расписание1 = РасписаниеВСтруктуру(Расписание1);*/
			/*Расписание2 = РасписаниеВСтруктуру(Расписание2);*/
			return null;
		}
		// Удаляет заданный литерал (префикс) в именах ключей переданной структуры.
		// Создает новую структуру.
		//
		//  Параметры:
		// Структура. Тип: Структура.
		// Структура элементов, на основании которой необходимо создать новую структуру с ключами без заданного литерала.
		//
		// Литерал. Тип: Строка.
		// Строка символов, которую необходимо исключить из имени ключей переданной структуры.
		//
		//  Возвращающее значение:
		// Тип. Структура.
		// Возвращаемая структура получается на основании копирования исходной структуры.
		//

		public object УдалитьПрефиксВКлючахКоллекции(/*Структура, Литерал*/)
		{
			/*Результат = Новый Структура;*/
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// Функции для поддержки формирования печатных форм
		//
		// Возвращает заголовок документа в том виде, в котором его формирует платформа для представления ссылки на документ.
		//
		// Параметры
		//  Шапка - Структура с ключами
		//          Номер - строка или число - номер документа
		//          Дата  - дата - дата документа
		//  НазваниеДокумента - Строка - название документа (например, синоним объекта метаданных)
		//
		// Возвращаемое значение
		//  Строка - заголовок документа
		//

		public object СформироватьЗаголовокДокумента(/*Шапка, знач НазваниеДокумента = ""*/)
		{
			/*// Если название документа не передано, получим название по представлению документа
*/
			if(true/*НазваниеДокумента = ""	И Шапка.Свойство("Представление") И ЗначениеЗаполнено(Шапка.Представление)*/)
			{
				/*ПоложениеНомера = Найти(Шапка.Представление, Шапка.Номер);*/
				if(true/*ПоложениеНомера > 0*/)
				{
					/*НазваниеДокумента = СокрЛП(Лев(Шапка.Представление, ПоложениеНомера - 1));*/
				}
			}
			/*НомерНаПечать = Шапка.Номер;*/
			/*СтандартнаяОбработка = Истина;*/
			/*СтандартныеПодсистемыКлиентСерверПереопределяемый.ПолучитьНомерНаПечать(НомерНаПечать, СтандартнаяОбработка);*/
			if(true/*СтандартнаяОбработка*/)
			{
				/*НомерНаПечать = Шапка.Номер;*/
			}
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// Функции для работы с файловой системой
		//
		// Процедура УдалитьКаталогСФайлами удаляет все файлы в заданном каталоге.
		//
		// Параметры:
		//  Путь         - Строка, полный путь каталога, в котором требуется
		//                 удалить все файлы.
		//

		public void УдалитьКаталогСФайлами(/*Путь*/)
		{
			/*Каталог = Новый Файл(Путь);*/
			if(true/*Каталог.Существует()*/)
			{
				/*УдалитьФайлы(Путь);*/
			}
		}
		// УдалитьКаталогСФайлами()
		// Добавляет к переданному пути каталога конечный символ-разделитель, если он отсутствует.
		// В случае, когда параметр "Платформа" не указан, разделитель выбирается, исходя из уже имеющихся
		// разделителей в параметре "ПутьКаталога".
		//
		// Параметры:
		//  ПутьКаталога - Строка - путь к каталогу;
		//  Платформа - ТипПлатформы - тип платформы, в рамках которой осуществляется работа (влияет на выбор разделителя).
		//
		// Возвращаемое значение:
		//  Строка   - путь к каталогу с конечным символом-разделителем.
		//
		// Примеры использования:
		//  Результат = ДобавитьКонечныйРазделительПути("C:\Мой каталог"); // возвращает "C:\Мой каталог\"
		//  Результат = ДобавитьКонечныйРазделительПути("C:\Мой каталог\"); // возвращает "C:\Мой каталог\"
		//  Результат = ДобавитьКонечныйРазделительПути("ftp://Мой каталог"); // возвращает "ftp://Мой каталог/"
		//	Результат = ДобавитьКонечныйРазделительПути("%APPDATA%", ТипПлатформы.Windows_x86_64); // возвращает "%APPDATA%\"
		//

		public object ДобавитьКонечныйРазделительПути(/*Знач ПутьКаталога, Знач Платформа = Неопределено*/)
		{
			if(true/*ПустаяСтрока(ПутьКаталога)*/)
			{
			}
			/*ДобавляемыйСимвол = "\";*/
			if(true/*Платформа = Неопределено*/)
			{
				if(true/*Найти(ПутьКаталога, "/") > 0*/)
				{
					/*ДобавляемыйСимвол = "/";*/
				}
			}
			if(true/*Прав(ПутьКаталога, 1) <> ДобавляемыйСимвол*/)
			{
			}
			return null;
		}
		// Составляет полное имя файла из имени каталога и имени файла.
		//
		// Параметры
		//  ИмяКаталога  – Строка, содержащая путь к каталогу файла на диске.
		//  ИмяФайла     – Строка, содержащая имя файла, без имени каталога.
		//
		// Возвращаемое значение:
		//   Строка – полное имя файла с учетом каталога.
		//

		public object ПолучитьПолноеИмяФайла(/*Знач ИмяКаталога, Знач ИмяФайла*/)
		{
			if(true/*НЕ ПустаяСтрока(ИмяФайла)*/)
			{
				/*Слэш = "";*/
				if(true/*(Прав(ИмяКаталога, 1) <> "\") И (Прав(ИмяКаталога, 1) <> "/")*/)
				{
					/*Слэш = ?(Найти(ИмяКаталога, "\") = 0, "/", "\");*/
				}
			}
			return null;
		}
		// Раскладывает полное имя файла на составляющие.
		//
		// Параметры
		//  ПолноеИмяФайла – Строка, содержащая полный путь к файлу.
		//  ЭтоПапка – Булево, признак того, что требуется разложить полное имя папки, а не файла.
		//
		// Возвращаемое значение:
		//   Структура – имя файла, разложенное на составные части(аналогично свойствам объекта Файл):
		//		ПолноеИмя - Содержит полный путь к файлу, т.е. полностью соответствует входному параметру ПолноеИмяФайла.
		//		Путь - Содержит путь к каталогу, в котором лежит файл.
		//		Имя - Содержит имя файла с расширением, без пути к файлу.
		//		Расширение - Содержит расширение файла
		//		ИмяБезРасширения - Содержит имя файла без расширения и без пути к файлу.
		//			Пример: если ПолноеИмяФайла = "c:\temp\test.txt", то структура заполнится следующим образом:
		//				ПолноеИмя: "c:\temp\test.txt"
		//				Путь: "c:\temp\"
		//				Имя: "test.txt"
		//				Расширение: ".txt"
		//				ИмяБезРасширения: "test"
		//

		public object РазложитьПолноеИмяФайла(/*Знач ПолноеИмяФайла, ЭтоПапка = Ложь*/)
		{
			/*СтруктураИмениФайла = Новый Структура("ПолноеИмя,Путь,Имя,Расширение,ИмяБезРасширения");*/
			/*// Убераем из полного имени файла завершающий слеш и сохраняем получившееся полное имя в структуре
*/
			if(true/*ЭтоПапка И (Прав(ПолноеИмяФайла, 1) = "/" Или Прав(ПолноеИмяФайла, 1) = "\")*/)
			{
				if(true/*ЭтоПапка*/)
				{
					/*ПолноеИмяФайла = Сред(ПолноеИмяФайла, 1, СтрДлина(ПолноеИмяФайла) - 1);*/
				}
			}
			/*СтруктураИмениФайла.Вставить("ПолноеИмя", ПолноеИмяФайла);*/
			/*// Если полное имя файла оказалось пустым - то остальные параметры структуры возвращаем пустыми
*/
			if(true/*СтрДлина(ПолноеИмяФайла) = 0*/)
			{
				/*СтруктураИмениФайла.Вставить("Путь", "");*/
				/*СтруктураИмениФайла.Вставить("Имя", "");*/
				/*СтруктураИмениФайла.Вставить("Расширение", "");*/
				/*СтруктураИмениФайла.Вставить("ИмяБезРасширения", "");*/
			}
			/*// Выделяем путь к файлу и имя файла									 
*/
			if(true/*Найти(ПолноеИмяФайла, "/") > 0*/)
			{
				/*ПозицияРазделителя = СтроковыеФункцииКлиентСервер.НайтиСимволСКонца(ПолноеИмяФайла, "/");*/
			}
			/*СтруктураИмениФайла.Вставить("Путь", Лев(ПолноеИмяФайла, ПозицияРазделителя));*/
			/*СтруктураИмениФайла.Вставить("Имя", Сред(ПолноеИмяФайла, ПозицияРазделителя + 1));*/
			/*// Папки не имеют расширений, а для файла выделяем расширение
*/
			if(true/*ЭтоПапка*/)
			{
				/*СтруктураИмениФайла.Вставить("Расширение", "");*/
				/*СтруктураИмениФайла.Вставить("ИмяБезРасширения", СтруктураИмениФайла.Имя);*/
			}
			return null;
		}
		// Возвращает строку недопустимых символов
		// Возвращаемое значение:
		//   Строка - строка недопустимых символов

		public object ПолучитьНедопустимыеСимволыВИмениФайла(/**/)
		{
			/*НедопустимыеСимволы = """/\[]:;|=,?*<>";*/
			return null;
		}
		// Проверяет наличение недопустимых символов в имени файла
		//
		// Параметры
		//  ИмяФайла  - Строка
		// Возвращаемое значение:
		//   Массив   - массив обнаруженных в имени файла недопустимых символов.
		//              Если недопустимых символов не обнаружено возвращается пустой массив.

		public object НайтиНедопустимыеСимволыВИмениФайла(/*ИмяФайла*/)
		{
			/*НедопустимыеСимволы = ПолучитьНедопустимыеСимволыВИмениФайла();*/
			/*МассивНайденныхНедопустимыхСимволов = Новый Массив;*/
			return null;
		}
		// Заменяет недопустимые символы в имени файла
		//
		// Параметры
		//  ИмяФайла     - Строка - исходное имя файла.
		//  НаЧтоМенять  - Строка - строка на которые неоходимо заменить недопустимые символы.
		//
		// Возвращаемое значение:
		//   Строка   - имя файла в котором недопустимые символы заменены.
		//

		public object ЗаменитьНедопустимыеСимволыВИмениФайла(/*ИмяФайла, НаЧтоМенять = " "*/)
		{
			/*МассивНайденныхНедопустимыхСимволов = НайтиНедопустимыеСимволыВИмениФайла(ИмяФайла);*/
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// Блок функций для работы с почтовыми адресами
		//
		// Функция проверяет что введенная строка с e-mail адресами введена правильно
		//
		// Формат строки:
		// Z = ИмяПользователя|[Имя Пользователя] [<]пользователь@почтовый_сервер[>], Строка = Z[<разделитель*>Z]..
		//
		//   прим.: разделитель* - имеется в виду любой разделитель адресов
		//
		// Параметры:
		// СтрокаПереданныхАдресов - строка - правильная строка с почтовыми адресами
		//
		// Возвращаемое значение:
		// Структура
		// ключ Статус - булево - успех или неуспех преобразования
		// в случае успеха содержит ключ Значение:
		//           Массив структур, где
		//                  Адрес- e-mail получателя
		//                  Представление   - имя получателя
		// в случае неуспеха содержит ключ СообщениеОбОшибке - строка
		//
		//  ВАЖНО: Функция возвращает массив структур, в которых одно поле (любое)
		//         может быть незаполнено. Может использоваться различными
		//         подсистемами для собственного сопоставления имени пользователя
		//         некому e-mail адресу. Поэтому, необходимо перед непосредственной
		//         отправкой проверить, что поле почтового адреса заполнено.
		//

		public object РазобратьСтрокуСПочтовымиАдресами(/*знач СтрокаПереданныхАдресов*/)
		{
			/*Результат = Новый Массив;*/
			/*НедопустимыеСимволы = "!#$%^&*()+`~|\/=";*/
			/*СообщениеНедопустимыеСимволы = НСтр("ru = 'Недопустимый символ %1 в адресе электронной почты %2'");*/
			/*СообщениеНеверныйФорматПочтовогоАдреса = НСтр("ru = 'Некорректный адрес электронной почты %1'");*/
			/*МассивПодстрок = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрокаПереданныхАдресов,";", Истина);*/
			/*МассивПодстрокКОбработке = Новый Массив;*/
			return null;
		}
		// Проверяет, что почтовый адрес не содержит символов обрамления
		// если символы обрамления вставлены правильно убирает их
		// Параметры:
		//  ПолноеИмяАдресата - строка - имя получателя
		//  ПочтовыйАдрес     - строка - email адрес
		// Возвращаемое значение:
		//  Структура:
		//   Ключ статус - булево - успех или неуспех операции
		//   СообщениеОбОшибке - в случае неуспеха операции содержит сообщение об ошибке
		//   Значение - структура - в случае успеха операции содержит записанную структуру почтового
		//                          адреса: ключи - Адрес, Представление (строки)
		//

		public object ПроверитьИПодготовитьПочтовыйАдрес(/*знач ПолноеИмяАдресата, знач ПочтовыйАдрес*/)
		{
			/*НедопустимыйСимволВИмениАдресата = НСтр("ru = 'Недопустимый символ в имени адресата.'");*/
			/*НедопустимыйСимволВПочтовомАдресе = НСтр("ru = 'Недопустимый символ в почтовом адресе.'");*/
			/*СимволыОбрамления = "<>[]";*/
			/*ПочтовыйАдрес     = СокрЛП(ПочтовыйАдрес);*/
			/*ПолноеИмяАдресата = СокрЛП(ПолноеИмяАдресата);*/
			if(true/*Лев(ПолноеИмяАдресата, 1) = "<"*/)
			{
				if(true/*Прав(ПолноеИмяАдресата, 1) = ">"*/)
				{
					/*ПолноеИмяАдресата = Сред(ПолноеИмяАдресата, 2, СтрДлина(ПолноеИмяАдресата)-2);*/
				}
			}
			if(true/*Лев(ПочтовыйАдрес, 1) = "<"*/)
			{
				if(true/*Прав(ПочтовыйАдрес, 1) = ">"*/)
				{
					/*ПочтовыйАдрес = Сред(ПочтовыйАдрес, 2, СтрДлина(ПочтовыйАдрес)-2);*/
				}
			}
			return null;
		}
		// Разбирает строку с адресами электронной почты согласно стандарту RFC 5322 с ограничениями.
		//
		// Ограничения:
		//  1. В адресе разрешаются только буквы, цифры, символ подчеркивания, дефис и символ "@".
		//  2. Символы скобок "<>[]()" допускаются, но игнорируются путём замены на пробелы.
		//  3. Группы запрещены.
		//
		// Параметры:
		//  Строка - Строка - Строка, содержащая электронные адреса (mailbox-list).
		//
		// Возвращаемое значение:
		//  Массив - содержит массив структур адресов.
		//           Поля структуры:
		//             Псевдоним      - Строка - представление адресата.
		//             Адрес          - Строка - найденный и соответствующий требованиям почтовый адрес;
		//                                       Если текст, похожий на адрес найден, но не соответствует требованиям
		//                                       стандартов, то такой текст записывается в поле "Псевдоним".
		//             ОписаниеОшибки - Строка - текстовое представление ошибки, либо пустая строка, если ошибок нет.

		public object АдресаЭлектроннойПочтыИзСтроки(/*Знач Строка*/)
		{
			/*Результат = Новый Массив;*/
			/*// заменяем скобки на пробелы
*/
			/*СимволыСкобок = "<>()[]";*/
			/*Строка = ЗаменитьСимволыВСтрокеНаПробелы(Строка, СимволыСкобок);*/
			/*// приводим разделители к одному виду
*/
			/*Строка = СтрЗаменить(Строка, ",", ";");*/
			/*// раскладываем mailbox-list на mailbox'ы
*/
			/*МассивАдресов = РазложитьСтрокуНаМассивПодстрок(Строка);*/
			/*// допустимые символы для псевдонима (display-name)
*/
			/*Буквы = "abcdefghijklmnopqrstuvwxyzабвгдеёжзийклмнопрстуфхцчшщъыьэюя";*/
			/*Цифры = "0123456789";*/
			/*ДополнительныеСимволы = "._- ";*/
			/*// выделяем из строки адреса (mailbox'а) псевдоним (display-name) и адрес (addr-spec)
*/
			return null;
		}

		public object ЗаменитьСимволыВСтрокеНаПробелы(/*Строка, ЗаменяемыеСимволы*/)
		{
			/*Результат = Строка;*/
			return null;
		}

		public object РазложитьСтрокуНаМассивПодстрок(/*Знач Строка, Разделитель = ";", ПропускатьПустыеСтроки = Истина*/)
		{
			/*Результат = Новый Массив;*/
			/*Позиция = Найти(Строка, Разделитель);*/
			while(true/*Позиция > 0*/)
			{
				/*Подстрока = Лев(Строка, Позиция - 1);*/
				if(true/*Не ПустаяСтрока(Подстрока) или не ПропускатьПустыеСтроки*/)
				{
					/*Результат.Добавить(Подстрока);*/
				}
				/*Строка = Сред(Строка, Позиция + СтрДлина(Разделитель));*/
				/*Позиция = Найти(Строка, Разделитель);*/
			}
			/*;
	
	Результат.Добавить(Строка);*/
			return null;
		}
		// Проверяет email адрес на соответствие требованиям стандартов RFC 5321, RFC 5322,
		// а также RFC 5335, RFC 5336 и RFC 3696.
		// Кроме того, функция ограничивает использование спецсимволов.
		//
		// Параметры:
		//  Адрес - Строка - проверяемый email.
		//
		// Возвращаемое значение:
		//  Булево - Истина, если ошибок нет.
		//

		public object АдресЭлектроннойПочтыСоответствуетТребованиям(/*Знач Адрес*/)
		{
			/*// допустимые символы для email
*/
			/*Буквы = "abcdefghijklmnopqrstuvwxyzабвгдеёжзийклмнопрстуфхцчшщъыьэюя";*/
			/*Цифры = "0123456789";*/
			/*СпецСимволы = ".@_-";*/
			/*// проверяем любые сочетания спецсимволов
*/
			if(true/*СтрДлина(СпецСимволы) > 1*/)
			{
			}
			/*// проверяем символ @
*/
			if(true/*СтрЧислоВхождений(Адрес, "@") <> 1*/)
			{
			}
			/*// проверяем две точки подряд
*/
			if(true/*Найти(Адрес, "..") > 0*/)
			{
			}
			/*// приводим строку адреса к нижнему регистру
*/
			/*Адрес = НРег(Адрес);*/
			/*// проверяем допустимые символы
*/
			if(true/*Не СтрокаСодержитТолькоДопустимыеСимволы(Адрес, Буквы + Цифры + СпецСимволы)*/)
			{
			}
			/*// разбираем адрес на local-part и domain
*/
			/*Позиция = Найти(Адрес,"@");*/
			/*ЛокальноеИмя = Лев(Адрес, Позиция - 1);*/
			/*Домен = Сред(Адрес, Позиция + 1);*/
			/*// проверяем на заполненность и допустимость длины
*/
			if(true/*ПустаяСтрока(ЛокальноеИмя)
	 	или ПустаяСтрока(Домен)
		или СтрДлина(ЛокальноеИмя) > 64
		или СтрДлина(Домен) > 255*/)
			{
			}
			/*// проверяем наличие спецсимволов в начале и в конце частей адреса
*/
			if(true/*ЕстьСимволыВНачалеВКонце(ЛокальноеИмя, СпецСимволы) или ЕстьСимволыВНачалеВКонце(Домен, СпецСимволы)*/)
			{
			}
			/*// в домене должна быть минимум одна точка
*/
			if(true/*Найти(Домен,".") = 0*/)
			{
			}
			/*// в домене не должно быть символа подчеркивания
*/
			if(true/*Найти(Домен,"_") > 0*/)
			{
			}
			/*// выделяем зону (TLD) из имени домена 
*/
			/*Зона = Домен;*/
			/*Позиция = Найти(Зона,".");*/
			while(true/*Позиция > 0*/)
			{
				/*Зона = Сред(Зона, Позиция + 1);*/
				/*Позиция = Найти(Зона,".");*/
			}
			/*// проверяем зону домена (минимум 2 символа, только буквы)
*/
			return null;
		}

		public object ЕстьСимволыВНачалеВКонце(/*Строка, ПроверяемыеСимволы*/)
		{
			return null;
		}

		public object СтрокаСодержитТолькоДопустимыеСимволы(/*Строка, ДопустимыеСимволы*/)
		{
			/*МассивСимволов = Новый Массив;*/
			return null;
		}
		// Формирует структуру с ключами Статус (Истина) и Значение
		//

		public object ЗаполнитьРезультат(/*знач Значение, знач Статус = Истина*/)
		{
			if(true/*Статус*/)
			{
			}
			return null;
		}
		// Сдвигает маркер позиции пока встречается символ Символ
		// возвращает номер позиции в строке, на которое установился маркер
		//

		public object ПропуститьПробелы(/*знач Строка,
                          знач ТекущийИндекс,
                          знач ПропускаемыйСимвол*/)
		{
			/*Результат = ТекущийИндекс;*/
			/*// убираем лишние пробелы если они есть
*/
			while(true/*ТекущийИндекс < СтрДлина(Строка)*/)
			{
				if(true/*Сред(Строка, ТекущийИндекс, 1) <> ПропускаемыйСимвол*/)
				{
				}
				/*ТекущийИндекс = ТекущийИндекс + 1;*/
			}
			return null;
		}
		// Возвращает полный путь к новому каталогу в каталоге временных файлов.
		//
		// Параметры:
		//  Идентификатор - Строка, начальная часть имени каталога во временном каталоге.
		//
		// Возвращаемое значение:
		//  Строка - полное имя временного каталога, например "КаталогВременныхФайлов() + Обработка123\".
		//

		public object ПолучитьИмяКаталога(/*знач Идентификатор*/)
		{
			/*Индекс = 0;*/
			while(true/*Истина*/)
			{
				/*ПутьККаталогу = КаталогВременныхФайлов () + Идентификатор + строка(Индекс) + "/";*/
				/*КаталогНаДиске = Новый Файл(ПутьККаталогу);*/
				if(true/*НЕ КаталогНаДиске.Существует()*/)
				{
					/*СоздатьКаталог(ПутьККаталогу);*/
				}
				/*Индекс = Индекс + 1;*/
			}
			/*;;*/
			return null;
		}
		// ПолучитьИмяКаталога()
		////////////////////////////////////////////////////////////////////////////////
		// Функции для работы с отборами динамических списков
		//
		// Поиск элементов и групп отбора динамического списка
		// Параметры:
		//  ОбластьПоиска - контейнер с элементами и группами отбора, например
		//                  Список.Отбор или группа в отборе
		//  ИмяПоля - имя поля компоновки (не используется для групп)
		//  Представление - представление поля компоновки
		//  Примечание: поиск может осуществляться или по ЛевомуЗначению, или по Представлению
		//

		public object НайтиЭлементыИГруппыОтбора(/*знач ОбластьПоиска,
									знач ИмяПоля = Неопределено,
									знач Представление = Неопределено*/)
		{
			if(true/*ЗначениеЗаполнено(ИмяПоля)*/)
			{
				/*ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);*/
				/*СпособПоиска = 1;*/
			}
			/*МассивЭлементов = Новый Массив;*/
			/*НайтиРекурсивно(ОбластьПоиска.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);*/
			return null;
		}
		// Добавление группы отбора
		// Параметры:
		//  КоллекцияЭлементов - контейнер с элементами и группами отбора, например
		//                      Список.Отбор.Элементы или группа в отборе
		//  ТипГруппы - ТипГруппыЭлементовОтбораКомпоновкиДанных - тип группы
		//  Представление строка - представление группы
		//

		public object СоздатьГруппуЭлементовОтбора(/*КоллекцияЭлементов, Представление, ТипГруппы*/)
		{
			/*ГруппаЭлементовОтбора = НайтиЭлементОтбораПоПредставлению(КоллекцияЭлементов, Представление);*/
			if(true/*ГруппаЭлементовОтбора = Неопределено*/)
			{
				/*ГруппаЭлементовОтбора = КоллекцияЭлементов.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));*/
			}
			/*ГруппаЭлементовОтбора.Представление    = Представление;*/
			/*ГруппаЭлементовОтбора.Применение       = ТипПримененияОтбораКомпоновкиДанных.Элементы;*/
			/*ГруппаЭлементовОтбора.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;*/
			/*ГруппаЭлементовОтбора.ТипГруппы        = ТипГруппы;*/
			/*ГруппаЭлементовОтбора.Использование    = Истина;*/
			return null;
		}
		// Добавление элемента компоновки в контейнер элементов компоновки
		// Параметры:
		//  ОбластьДобавления - контейнер с элементами и группами отбора, например
		//                  Список.Отбор или группа в отборе
		//  ИмяПоля - строка - имя для поля компоновки данных
		//  ВидСравнения - ВидСравненияКомпоновкиДанных - вид сравнения
		//  ПравоеЗначение - произвольный
		//  Представление - представление элемента компоновки данных
		//  Использование - булево - использование элемента
		//  РежимОтображения - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения
		//

		public object ДобавитьЭлементКомпоновки(/*ОбластьДобавления,
									знач ИмяПоля,
									знач ВидСравнения,
									знач ПравоеЗначение = Неопределено,
									знач Представление  = Неопределено,
									знач Использование  = Неопределено,
									знач РежимОтображения = Неопределено*/)
		{
			/*Элемент = ОбластьДобавления.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));*/
			/*Элемент.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПоля);*/
			/*Элемент.ВидСравнения = ВидСравнения;*/
			if(true/*РежимОтображения = Неопределено*/)
			{
				/*Элемент.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;*/
			}
			if(true/*ПравоеЗначение <> Неопределено*/)
			{
				/*Элемент.ПравоеЗначение = ПравоеЗначение;*/
			}
			if(true/*Представление <> Неопределено*/)
			{
				/*Элемент.Представление = Представление;*/
			}
			if(true/*Использование <> Неопределено*/)
			{
				/*Элемент.Использование = Использование;*/
			}
			return null;
		}
		// Изменение элементов отбора
		// Параметры
		//  ИмяПоля - строка - имя поля компоновки
		//  ВидСравнения - ВидСравненияКомпоновкиДанных - вид сравнения
		//  ПравоеЗначение - произвольный
		//  Представление - строка - представление элемента компоновки данных
		//  Использование - булево - использование элемента
		//  РежимОтображения - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения
		//

		public object ИзменитьЭлементыОтбора(/*ОбластьПоиска,
								знач ИмяПоля = Неопределено,
								знач Представление = Неопределено,
								знач ПравоеЗначение = Неопределено,
								знач ВидСравнения = Неопределено,
								знач Использование = Неопределено,
								знач РежимОтображения = Неопределено*/)
		{
			if(true/*ЗначениеЗаполнено(ИмяПоля)*/)
			{
				/*ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);*/
				/*СпособПоиска = 1;*/
			}
			/*МассивЭлементов = Новый Массив;*/
			/*НайтиРекурсивно(ОбластьПоиска.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);*/
			return null;
		}
		// Поиск элементов и групп отбора динамического списка
		// Параметры:
		//  ОбластьУдаления - контейнер с элементами и группами отбора, например
		//                  Список.Отбор или группа в отборе
		//  ИмяПоля - имя поля компоновки (не используется для групп)
		//  Представление - представление поля компоновки
		//  Примечание: поиск может осуществляться или по ЛевомуЗначению, или по Представлению
		//

		public void УдалитьЭлементыГруппыОтбора(/*знач ОбластьУдаления,
										знач ИмяПоля = Неопределено,
										знач Представление = Неопределено*/)
		{
			if(true/*ЗначениеЗаполнено(ИмяПоля)*/)
			{
				/*ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);*/
				/*СпособПоиска = 1;*/
			}
			/*МассивЭлементов = Новый Массив;*/
			/*НайтиРекурсивно(ОбластьУдаления.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);*/
		}
		// Используется для создания элемента отбора или, если таковой не найден,
		// установления существующим элементам свойств
		// Параметры
		//  ОбластьПоискаДобавления - контейнер с элементами и группами отбора, например
		//                  Список.Отбор или группа в отборе
		//  ИмяПоля - строка - имя для поля компоновки данных (заполняется всегда)
		// Устанавливаемые поля:
		//  ВидСравнения - ВидСравненияКомпоновкиДанных - вид сравнения
		//  ПравоеЗначение - произвольный
		//  Представление - представление элемента компоновки данных
		//  Использование - булево - использование элемента
		//  РежимОтображения - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения
		//

		public void УстановитьЭлементОтбора(/*ОбластьПоискаДобавления,
								знач ИмяПоля,
								знач ПравоеЗначение = Неопределено,
								знач ВидСравнения = Неопределено,
								знач Представление = Неопределено,
								знач Использование = Неопределено,
								знач РежимОтображения = Неопределено*/)
		{
			/*ЧислоИзмененных = ИзменитьЭлементыОтбора(ОбластьПоискаДобавления, ИмяПоля, Представление,
							ПравоеЗначение, ВидСравнения, Использование, РежимОтображения);*/
			if(true/*ЧислоИзмененных = 0*/)
			{
				if(true/*ВидСравнения = Неопределено*/)
				{
					/*ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;*/
				}
				/*ДобавитьЭлементКомпоновки(ОбластьПоискаДобавления, ИмяПоля, ВидСравнения,
								ПравоеЗначение, Представление, Использование, РежимОтображения);*/
			}
		}
		// Устанавливает значение Значение параметра ИмяПараметра динамического списка Список
		// или отключает его использование в зависимости от признака Использование.
		//

		public void УстановитьПараметрДинамическогоСписка(/*Список, ИмяПараметра, Значение, Использование = Истина*/)
		{
			if(true/*Использование*/)
			{
				/*Список.Параметры.УстановитьЗначениеПараметра(ИмяПараметра, Значение);*/
			}
		}
		////////////////////////////////////////////////////////////////////////////////
		// Функции для работы с управляемыми формами
		//
		// Получает значение реквизита формы
		// Параметры:
		//		Форма
		//		ПутьРеквизита - строка, путь к данным, например: "Объект.МесяцНачисления"

		public object ПолучитьРеквизитФормыПоПути(/*Форма, ПутьРеквизита*/)
		{
			/*МассивИмен = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПутьРеквизита, ".");*/
			/*Объект        = Форма;*/
			/*ПоследнееПоле = МассивИмен[МассивИмен.Количество()-1];*/
			return null;
		}
		// Устанавливает значение реквизиту формы
		// Параметры:
		//		Форма
		//		ПутьРеквизита - строка, путь к данным, например: "Объект.МесяцНачисления"
		//		Значение

		public void УстановитьРеквизитФормыПоПути(/*Форма, ПутьРеквизита, Значение, ТолькоЕслиНеЗаполнен = Ложь*/)
		{
			/*МассивИмен = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПутьРеквизита, ".");*/
			/*Объект        = Форма;*/
			/*ПоследнееПоле = МассивИмен[МассивИмен.Количество()-1];*/
			if(true/*НЕ ТолькоЕслиНеЗаполнен ИЛИ НЕ ЗначениеЗаполнено(Объект[ПоследнееПоле])*/)
			{
				/*Объект[ПоследнееПоле] = Значение;*/
			}
		}
		// Выполняет поиск элемента отбора в коллекции по заданному представлению
		//
		// Параметры:
		//  КоллекцияЭлементов - контейнер с элементами и группами отбора, например
		//                      Список.Отбор.Элементы или группа в отборе
		//  Представление строка - представление группы
		//

		public object НайтиЭлементОтбораПоПредставлению(/*КоллекцияЭлементов, Представление*/)
		{
			/*ВозвращаемоеЗначение = Неопределено;*/
			return null;
		}
		// Устанавливает свойство ИмяСвойства элемента формы с именем ИмяЭлемента в значение Значение.
		// Применяется в тех случаях, когда элемент формы может не быть на форме из-за отсутствия прав у пользователя
		// на объект, реквизит объекта или команду.
		//
		// Параметры:
		//  ЭлементыФормы - свойство ЭлементыФормы управляемой формы.
		//  ИмяЭлемента   - Строка       - имя элемента формы
		//  ИмяСвойства   - Строка       - имя устанавливаемого свойства элемента формы
		//  Значение      - Произвольный - новое значение элемента
		//

		public void УстановитьСвойствоЭлементаФормы(/*ЭлементыФормы, ИмяЭлемента, ИмяСвойства, Значение*/)
		{
			/*ЭлементФормы = ЭлементыФормы.Найти(ИмяЭлемента);*/
			if(true/*ЭлементФормы <> Неопределено*/)
			{
				/*ЭлементФормы[ИмяСвойства] = Значение;*/
			}
		}
		// Возвращает значение свойства ИмяСвойства элемента формы с именем ИмяЭлемента.
		// Применяется в тех случаях, когда элемент формы может не быть на форме из-за отсутствия прав у пользователя
		// на объект, реквизит объекта или команду.
		//
		// Параметры:
		//  ЭлементыФормы - свойство ЭлементыФормы управляемой формы.
		//  ИмяЭлемента   - Строка       - имя элемента формы
		//  ИмяСвойства   - Строка       - имя свойства элемента формы
		//
		// Возвращаемое значение:
		//   Произвольный - значение свойства ИмяСвойства элемента формы ИмяЭлемента.
		//

		public object ЗначениеСвойстваЭлементаФормы(/*ЭлементыФормы, ИмяЭлемента, ИмяСвойства*/)
		{
			/*ЭлементФормы = ЭлементыФормы.Найти(ИмяЭлемента);*/
			return null;
		}
		////////////////////////////////////////////////////////////////////////////////
		// Служебные и вспомогательные функции
		//

		public void НайтиРекурсивно(/*КоллекцияЭлементов, МассивЭлементов, СпособПоиска, ЗначениеПоиска*/)
		{
		}
		// добавляет в конце "\" или "/"

		public void ДобавитьСлешЕслиНужно(/*НовыйПуть, ТипПлатформыТекущий*/)
		{
			if(true/*СтрДлина(НовыйПуть) = 0*/)
			{
			}
			if(true/*Прав(НовыйПуть, 1) <> "\" И Прав(НовыйПуть,1) <> "/"*/)
			{
				if(true/*ТипПлатформыТекущий = ТипПлатформы.Windows_x86 ИЛИ ТипПлатформыТекущий = ТипПлатформы.Windows_x86_64*/)
				{
					/*НовыйПуть = НовыйПуть + "\";*/
				}
			}
		}
		// Получает представление сообщения ошибке на основании Информации об ошибке
		// Может вызываться в операторных скобках Попытка ... Исключение ... КонецПопытки;
		// для получения сообщения об ошибке.
		//

		public object ПолучитьПредставлениеОписанияОшибки(/*ИнформацияОбОшибке*/)
		{
			return null;
		}
		// Копирует элементы из одной коллекции в другую
		//

		public void СкопироватьЭлементы(/*ПриемникЗначения, ИсточникЗначения, ПроверятьДоступность = Ложь, ОчищатьПриемник = Истина*/)
		{
			if(true/*ТипЗнч(ИсточникЗначения) = Тип("УсловноеОформлениеКомпоновкиДанных")
		ИЛИ ТипЗнч(ИсточникЗначения) = Тип("ВариантыПользовательскогоПоляВыборКомпоновкиДанных")
		ИЛИ ТипЗнч(ИсточникЗначения) = Тип("ОформляемыеПоляКомпоновкиДанных")
		ИЛИ ТипЗнч(ИсточникЗначения) = Тип("ЗначенияПараметровДанныхКомпоновкиДанных")*/)
			{
				/*СоздаватьПоТипу = Ложь;*/
			}
			/*ПриемникЭлементов = ПриемникЗначения.Элементы;*/
			/*ИсточникЭлементов = ИсточникЗначения.Элементы;*/
			if(true/*ОчищатьПриемник*/)
			{
				/*ПриемникЭлементов.Очистить();*/
			}
		}

		public void ЗаполнитьЭлементы(/*ПриемникЗначения, ИсточникЗначения, ПервыйУровень = Неопределено*/)
		{
			if(true/*ТипЗнч(ПриемникЗначения) = Тип("КоллекцияЗначенийПараметровКомпоновкиДанных")*/)
			{
				/*КоллекцияЗначений = ИсточникЗначения;*/
			}
		}
		// Функция выполняет получение имени поля из доступных полей компоновки данных.
		//

		public object ПолучитьИмяПоляВШаблоне(/*Знач ИмяПоля*/)
		{
			/*ИмяПоля = СтрЗаменить(ИмяПоля, ".DeletionMark", ".ПометкаУдаления");*/
			/*ИмяПоля = СтрЗаменить(ИмяПоля, ".Owner", ".Владелец");*/
			/*ИмяПоля = СтрЗаменить(ИмяПоля, ".Code", ".Код");*/
			/*ИмяПоля = СтрЗаменить(ИмяПоля, ".Parent", ".Родитель");*/
			/*ИмяПоля = СтрЗаменить(ИмяПоля, ".Predefined", ".Предопределенный");*/
			/*ИмяПоля = СтрЗаменить(ИмяПоля, ".IsFolder", ".ЭтоГруппа");*/
			/*ИмяПоля = СтрЗаменить(ИмяПоля, ".Description", ".Наименование");*/
			return null;
		}
		// ПолучитьИмяПоляВШаблоне()
		////////////////////////////////////////////////////////////////////////////////
		// Клиентские и серверные процедуры общего назначения
		// Функция формирует текст в формате, необходимом для выдачи сообщений по табличной части.
		//
		// Параметры:
		//  ИмяТЧ - Строка. Имя табличной части.
		//  НомерСтроки - Число. Номер строки табличной части.
		//  ИмяРеквизита - Строка. Имя реквизита.
		//
		// Возвращаемое значение:
		//  Строка.
		//

		public object ПолучитьТекстДляВыдачиСообщенийПоСтрокеТЧ(/*ИмяТЧ, НомерСтроки, ИмяРеквизита*/)
		{
			return null;
		}
		// ПолучитьТекстДляВыдачиСообщенийПоСтрокеТЧ()
		//Процедуры подготовки исходных данных при проведении документов
		// Обрабатывает таблицу значений: заполняет незаполненные колонки с НоменклатурнойГруппой и СтатьейЗатрат по данным других реквизитов
		// Параметры:
		// 	ТаблицаДокумента - обрабатываемая таблица значений
		// 	СтруктураОбрабатываемыхКолонок - Структура, содержит обрабатываемые колонки
		// 		Ключ - имя колонки которую необходимо заполнить
		// 		Значение - имя колонки являющейся источником для заполнения
		// 	СтруктураЗависимыхКолонок - Структура - содержит сведения о колонках, необходимость заполнения которых зависит от заполнения других колонок
		// 		Ключ - имя зависимой колонки
		// 		Значение - имя колонки, от заполнения которой зависит нужно ли заполнять зависимую колонку
		//

		public void ЗаполнитьНоменклатурнуюГруппуИСтатьюЗатратВТаблицеДокумента(/*ТаблицаДокумента, СтруктураОбрабатываемыхКолонок, СтруктураЗависимыхКолонок = Неопределено*/)
		{
			if(true/*СтруктураЗависимыхКолонок = Неопределено*/)
			{
				/*СтруктураЗависимыхКолонок = Новый Структура();*/
			}
		}
		//Процедура добавляет в СтруктуруШапкиДокумента сведения о счетах расчетов по умолчанию, если эти данные не заполнились из шапки документа

		public void ДобавитьВСтруктуруШапкиСведенияОСчетахРасчетов(/*ДокументОбъект, СтруктураШапкиДокумента*/)
		{
			if(true/*НЕ СтруктураШапкиДокумента.ОтражатьВБухгалтерскомУчете*/)
			{
			}
			/*//Получим структуру счетов учета расчетов: 
*/
			/*//	ключ - имя реквизита шапки, значение - счет учета расчетов по умолчанию
*/
			/*СтруктураСчетовУчетаРасчетов = ДокументОбъект.ЗаполнитьСтруктуруСчетовУчетаШапки();*/
			/*//Заполним недостающие свойства в структуре шапки документа 
*/
		}
		//Процедура добавляет в СтруктуруШапкиДокумента сведения о подразделении организации,
		//Если в шапке документа «Подразделение организации» оказалось незаполненным, то соответствующее свойство структуры заполняется вычисленным по подразделению
		//Если Подразделение организации не удалось определить по подразделению, то выдается ошибка

		public void ДополнитьСтруктуруШапкиПодразделениемОрганизации(/*Заголовок, СтруктураШапкиДокумента, Отказ*/)
		{
			if(true/*НЕ СтруктураШапкиДокумента.ОтражатьВБухгалтерскомУчете*/)
			{
			}
			if(true/*НЕ ЗначениеЗаполнено(СтруктураШапкиДокумента.ПодразделениеОрганизации)*/)
			{
				/*СтруктураШапкиДокумента.ПодразделениеОрганизации = РаботаСДиалогамиСервер.ПодразделениеОрганизации(СтруктураШапкиДокумента.Подразделение, СтруктураШапкиДокумента.Организация);*/
			}
			if(true/*НЕ ЗначениеЗаполнено(СтруктураШапкиДокумента.ПодразделениеОрганизации)*/)
			{
				/*ОбщегоНазначения.СообщитьОбОшибке(Нстр("ru = 'Не заполнено подразделение организации'"), Отказ, Заголовок);*/
			}
		}
		//ДополнитьСтруктуруШапкиПодразделениемОрганизации()
		//Процедура добавляет в ТаблицуДокумента сведения о подразделении организации,
		//Если в табличной части документа «Подразделение организации» оказалось незаполненным, то соответствующая колонка таблицы заполняется вычисленным значением по подразделению
		//Окончательная проверка заполненности подразделения организации выполняется в модуле документа

		public void ДополнитьТаблицуДокументаПодразделениемОрганизации(/*СтруктураШапкиДокумента, ТаблицаДокумента*/)
		{
			if(true/*НЕ СтруктураШапкиДокумента.ОтражатьВБухгалтерскомУчете*/)
			{
			}
			if(true/*ТаблицаДокумента.Колонки.Найти("Подразделение") <> Неопределено*/)
			{
				/*ИмяКолонкиПодразделение = "Подразделение";*/
				/*ИмяКолонкиПодразделениеОрганизации = "ПодразделениеОрганизации";*/
			}
		}
		// Проверяет правильность заполнения шапки документа по структуре шапки документа.
		// Если какой-то из реквизитов шапки, влияющий на проведение, не заполнен или
		// заполнен не корректно, то выставляется флаг отказа в проведении.
		// Проверяется также правильность заполнения реквизитов ссылочных полей документа.
		// Проверка выполняется по объекту и по выборке из результата запроса по шапке.
		//
		// Параметры:
		//  ДокументОбъект             - объект проводимого документа,
		//  СтруктураОбязательныхПолей - структура, содержащая имена полей, которые собственно и надо проверить.
		//  СтруктураШапкиДокумента    - структура шапки проводимого документа
		//  Отказ                      - флаг отказа в проведении.
		//  Заголовок                  - строка, заголовок сообщения об ошибке проведения.
		//

		public void ПроверитьЗаполнениеВычисляемыхРеквизитовШапки(/*ДокументОбъект, СтруктураОбязательныхПолей, СтруктураШапкиДокумента, Отказ, Заголовок*/)
		{
			/*МетаданныеРеквизиты = ДокументОбъект.Метаданные().Реквизиты;*/
		}
	}
}

